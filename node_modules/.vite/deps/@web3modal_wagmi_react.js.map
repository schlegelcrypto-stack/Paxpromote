{
  "version": 3,
  "sources": ["../../@web3modal/scaffold-react/index.ts", "../../ox/core/Ens.ts", "../../ox/core/Abi.ts", "../../ox/core/internal/abi.ts", "../../ox/core/AbiEvent.ts", "../../ox/_esm/core/AccountProof.js", "../../ox/core/AesGcm.ts", "../../ox/core/Base58.ts", "../../ox/core/internal/base58.ts", "../../ox/core/BinaryStateTree.ts", "../../@noble/hashes/src/_blake.ts", "../../@noble/hashes/src/blake2.ts", "../../@noble/hashes/src/blake3.ts", "../../ox/core/Blobs.ts", "../../ox/core/Kzg.ts", "../../ox/core/Block.ts", "../../ox/core/Bloom.ts", "../../ox/core/Bls.ts", "../../ox/core/BlsPoint.ts", "../../ox/core/ContractAddress.ts", "../../ox/core/Ed25519.ts", "../../@noble/curves/src/abstract/edwards.ts", "../../@noble/curves/src/abstract/montgomery.ts", "../../@noble/curves/src/ed25519.ts", "../../ox/_esm/core/Fee.js", "../../ox/core/Filter.ts", "../../ox/core/HdKey.ts", "../../ox/core/internal/hdKey.ts", "../../ox/core/Keystore.ts", "../../@noble/ciphers/src/utils.ts", "../../@noble/ciphers/src/_polyval.ts", "../../@noble/ciphers/src/aes.ts", "../../@noble/hashes/src/scrypt.ts", "../../ox/core/Mnemonic.ts", "../../ox/core/PersonalMessage.ts", "../../ox/core/Provider.ts", "../../ox/core/RpcResponse.ts", "../../ox/core/RpcRequest.ts", "../../ox/core/RpcSchema.ts", "../../ox/core/RpcTransport.ts", "../../ox/core/internal/promise.ts", "../../ox/core/internal/rpcTransport.ts", "../../ox/core/Siwe.ts", "../../ox/core/internal/uid.ts", "../../ox/core/StateOverrides.ts", "../../ox/core/TxEnvelopeEip1559.ts", "../../ox/core/TxEnvelopeEip2930.ts", "../../ox/core/TxEnvelopeEip4844.ts", "../../ox/core/TxEnvelopeEip7702.ts", "../../ox/core/TxEnvelopeLegacy.ts", "../../ox/core/ValidatorData.ts", "../../ox/core/WebCryptoP256.ts", "../../ox/core/X25519.ts", "../../ox/core/internal/ens.ts", "../../viem/utils/ens/normalize.ts", "../../@web3modal/wagmi/src/client.ts", "../../@web3modal/wagmi/exports/react/index.ts"],
  "sourcesContent": [null, "import { ens_normalize } from '@adraffy/ens-normalize'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as internal from './internal/ens.js'\n\n/**\n * Hashes ENS label.\n *\n * Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in {@link ox#Ens.(normalize:function)} function for this.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.labelhash('eth')\n * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'\n * ```\n *\n * @param label - ENS label.\n * @returns ENS labelhash.\n */\nexport function labelhash(label: string) {\n  const result = new Uint8Array(32).fill(0)\n  if (!label) return Hex.fromBytes(result)\n  return (\n    internal.unwrapLabelhash(label) || Hash.keccak256(Hex.fromString(label))\n  )\n}\n\nexport declare namespace labelhash {\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | internal.unwrapLabelhash.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Hashes ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in {@link ox#Ens.(normalize:function)} function for this.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.namehash('wevm.eth')\n * // @log: '0xf246651c1b9a6b141d19c2604e9a58f567973833990f830d882534a747801359'\n * ```\n *\n * @param name - ENS name.\n * @returns ENS namehash.\n */\nexport function namehash(name: string) {\n  let result = new Uint8Array(32).fill(0)\n  if (!name) return Hex.fromBytes(result)\n\n  const labels = name.split('.')\n  // Iterate in reverse order building up hash\n  for (let i = labels.length - 1; i >= 0; i -= 1) {\n    const hashFromEncodedLabel = internal.unwrapLabelhash(labels[i]!)\n    const hashed = hashFromEncodedLabel\n      ? Bytes.fromHex(hashFromEncodedLabel)\n      : Hash.keccak256(Bytes.fromString(labels[i]!), { as: 'Bytes' })\n    result = Hash.keccak256(Bytes.concat(result, hashed), { as: 'Bytes' })\n  }\n\n  return Hex.fromBytes(result)\n}\n\nexport declare namespace namehash {\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | internal.unwrapLabelhash.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Bytes.concat.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Normalizes ENS name according to [ENSIP-15](https://github.com/ensdomains/docs/blob/9edf9443de4333a0ea7ec658a870672d5d180d53/ens-improvement-proposals/ensip-15-normalization-standard.md).\n *\n * For more info see [ENS documentation](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) on name processing.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.normalize('wevm.eth')\n * // @log: 'wevm.eth'\n * ```\n *\n * @param name - ENS name.\n * @returns Normalized ENS name.\n */\nexport function normalize(name: string): string {\n  return ens_normalize(name)\n}\n\nexport declare namespace normalize {\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as abitype from 'abitype'\nimport type * as Errors from './Errors.js'\nimport * as internal from './internal/abi.js'\nimport type * as AbiItem_internal from './internal/abiItem.js'\n\n/** Root type for an ABI. */\nexport type Abi = abitype.Abi\n\n/** @internal */\nexport function format<const abi extends Abi>(abi: abi): format.ReturnType<abi>\n/**\n * Formats an {@link ox#Abi.Abi} into a **Human Readable ABI**.\n *\n * @example\n * ```ts twoslash\n * import { Abi } from 'ox'\n *\n * const formatted = Abi.format([{\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * }])\n *\n * formatted\n * //    ^?\n *\n *\n *\n * ```\n *\n * @param abi - The ABI to format.\n * @returns The formatted ABI.\n */\nexport function format(abi: Abi | readonly unknown[]): readonly string[]\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function format(abi: Abi | readonly unknown[]): format.ReturnType {\n  return abitype.formatAbi(abi) as never\n}\n\nexport declare namespace format {\n  type ReturnType<abi extends Abi | readonly unknown[] = Abi> =\n    abitype.FormatAbi<abi>\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function from<const abi extends Abi | readonly string[]>(\n  abi: abi &\n    (abi extends readonly string[]\n      ? AbiItem_internal.Signatures<abi>\n      : unknown),\n): from.ReturnType<abi>\n/**\n * Parses an arbitrary **JSON ABI** or **Human Readable ABI** into a typed {@link ox#Abi.Abi}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { Abi } from 'ox'\n *\n * const abi = Abi.from([{\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * }])\n *\n * abi\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * ```ts twoslash\n * import { Abi } from 'ox'\n *\n * const abi = Abi.from([\n *   'function approve(address spender, uint256 amount) returns (bool)'\n * ])\n *\n * abi\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @param abi - The ABI to parse.\n * @returns The typed ABI.\n */\nexport function from(abi: Abi | readonly string[]): Abi\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function from(abi: Abi | readonly string[]): from.ReturnType {\n  if (internal.isSignatures(abi)) return abitype.parseAbi(abi)\n  return abi\n}\n\nexport declare namespace from {\n  type ReturnType<\n    abi extends Abi | readonly string[] | readonly unknown[] = Abi,\n  > = abi extends readonly string[] ? abitype.ParseAbi<abi> : abi\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import type * as Abi from '../Abi.js'\n\n/** @internal */\nexport function isSignatures(\n  value: Abi.Abi | readonly string[],\n): value is readonly string[] {\n  for (const item of value) {\n    if (typeof item !== 'string') return false\n  }\n  return true\n}\n", "import * as abitype from 'abitype'\nimport type * as Abi from './Abi.js'\nimport * as AbiItem from './AbiItem.js'\nimport * as AbiParameters from './AbiParameters.js'\nimport * as Address from './Address.js'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type * as internal from './internal/abiEvent.js'\nimport type * as AbiItem_internal from './internal/abiItem.js'\nimport * as Cursor from './internal/cursor.js'\nimport { prettyPrint } from './internal/errors.js'\nimport type { Compute, IsNarrowable } from './internal/types.js'\n\n/** Root type for an {@link ox#AbiItem.AbiItem} with an `event` type. */\nexport type AbiEvent = abitype.AbiEvent & {\n  hash?: Hex.Hex | undefined\n  overloads?: readonly AbiEvent[] | undefined\n}\n\n/**\n * Extracts an {@link ox#AbiEvent.AbiEvent} item from an {@link ox#Abi.Abi}, given a name.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiEvent } from 'ox'\n *\n * const abi = Abi.from([\n *   'event Foo(string)',\n *   'event Bar(uint256)',\n * ])\n *\n * type Foo = AbiEvent.FromAbi<typeof abi, 'Foo'>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type FromAbi<\n  abi extends Abi.Abi,\n  name extends ExtractNames<abi>,\n> = abitype.ExtractAbiEvent<abi, name>\n\n/**\n * Extracts the names of all {@link ox#AbiError.AbiError} items in an {@link ox#Abi.Abi}.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiEvent } from 'ox'\n *\n * const abi = Abi.from([\n *   'event Foo(string)',\n *   'event Bar(uint256)',\n * ])\n *\n * type names = AbiEvent.Name<typeof abi>\n * //   ^?\n * ```\n */\nexport type Name<abi extends Abi.Abi | readonly unknown[] = Abi.Abi> =\n  abi extends Abi.Abi ? ExtractNames<abi> : string\n\nexport type ExtractNames<abi extends Abi.Abi> =\n  abitype.ExtractAbiEventNames<abi>\n\n/**\n * Asserts that the provided arguments match the decoded log arguments.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from('event Transfer(address indexed from, address indexed to, uint256 value)')\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   ],\n * })\n *\n * AbiEvent.assertArgs(abiEvent, args, {\n *   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad',\n *   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   value: 1n,\n * })\n *\n * // @error: AbiEvent.ArgsMismatchError: Given arguments to not match the arguments decoded from the log.\n * // @error: Event: event Transfer(address indexed from, address indexed to, uint256 value)\n * // @error: Expected Arguments:\n * // @error:   from:   0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac\n * // @error:   to:     0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad\n * // @error:   value:  1\n * // @error: Given Arguments:\n * // @error:   from:   0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad\n * // @error:   to:     0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac\n * // @error:   value:  1\n * ```\n *\n * @param abiEvent - ABI Event to check.\n * @param args - Decoded arguments.\n * @param matchArgs - The arguments to check.\n */\nexport function assertArgs<const abiEvent extends AbiEvent>(\n  abiEvent: abiEvent | AbiEvent,\n  args: unknown,\n  matchArgs: IsNarrowable<abiEvent, AbiEvent> extends true\n    ? abiEvent['inputs'] extends readonly []\n      ? never\n      : internal.ParametersToPrimitiveTypes<\n          abiEvent['inputs'],\n          { EnableUnion: true; IndexedOnly: false; Required: false }\n        >\n    : unknown,\n) {\n  if (!args || !matchArgs)\n    throw new ArgsMismatchError({\n      abiEvent,\n      expected: args,\n      given: matchArgs,\n    })\n\n  function isEqual(\n    input: abitype.AbiEventParameter,\n    value: unknown,\n    arg: unknown,\n  ) {\n    if (input.type === 'address')\n      return Address.isEqual(value as Address.Address, arg as Address.Address)\n    if (input.type === 'string')\n      return Hash.keccak256(Bytes.fromString(value as string)) === arg\n    if (input.type === 'bytes') return Hash.keccak256(value as Hex.Hex) === arg\n    return value === arg\n  }\n\n  if (Array.isArray(args) && Array.isArray(matchArgs)) {\n    for (const [index, value] of matchArgs.entries()) {\n      if (value === null || value === undefined) continue\n      const input = abiEvent.inputs[index]\n      if (!input)\n        throw new InputNotFoundError({\n          abiEvent,\n          name: `${index}`,\n        })\n      const value_ = Array.isArray(value) ? value : [value]\n      let equal = false\n      for (const value of value_) {\n        if (isEqual(input, value, args[index])) equal = true\n      }\n      if (!equal)\n        throw new ArgsMismatchError({\n          abiEvent,\n          expected: args,\n          given: matchArgs,\n        })\n    }\n  }\n\n  if (\n    typeof args === 'object' &&\n    !Array.isArray(args) &&\n    typeof matchArgs === 'object' &&\n    !Array.isArray(matchArgs)\n  )\n    for (const [key, value] of Object.entries(matchArgs)) {\n      if (value === null || value === undefined) continue\n      const input = abiEvent.inputs.find((input) => input.name === key)\n      if (!input) throw new InputNotFoundError({ abiEvent, name: key })\n      const value_ = Array.isArray(value) ? value : [value]\n      let equal = false\n      for (const value of value_) {\n        if (isEqual(input, value, (args as Record<string, unknown>)[key]))\n          equal = true\n      }\n      if (!equal)\n        throw new ArgsMismatchError({\n          abiEvent,\n          expected: args,\n          given: matchArgs,\n        })\n    }\n}\n\nexport declare namespace assertArgs {\n  type ErrorType =\n    | Address.isEqual.ErrorType\n    | Bytes.fromString.ErrorType\n    | Hash.keccak256.ErrorType\n    | ArgsMismatchError\n    | Errors.GlobalErrorType\n}\n\n/**\n * ABI-Decodes the provided [Log Topics and Data](https://info.etherscan.com/what-is-event-logs/) according to the ABI Event's parameter types (`input`).\n *\n * :::tip\n *\n * This function is typically used to decode an [Event Log](https://info.etherscan.com/what-is-event-logs/) that may be returned from a Log Query (e.g. `eth_getLogs`) or Transaction Receipt.\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)'\n * )\n *\n * const log = {\n *   // ...\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   ],\n * } as const\n *\n * const decoded = AbiEvent.decode(transfer, log)\n * // @log: {\n * // @log:   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n * // @log:   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n * // @log:   value: 1n\n * // @log: }\n * ```\n *\n * @example\n * ### ABI-shorthand\n *\n * You can also specify an entire ABI object and an event name as parameters to {@link ox#AbiEvent.(decode:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiEvent } from 'ox'\n *\n * const abi = Abi.from([...])\n * const log = {\n *   // ...\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   ],\n * } as const\n *\n * const decoded = AbiEvent.decode(\n *   abi, // [!code focus]\n *   'Transfer', // [!code focus]\n *   log\n * )\n * // @log: {\n * // @log:   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n * // @log:   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n * // @log:   value: 1n\n * // @log: }\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiEvent.decode` to decode the topics of a `Transfer` event on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiEvent, Hex } from 'ox'\n *\n * // 1. Instantiate the `Transfer` ABI Event.\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)',\n * )\n *\n * // 2. Encode the ABI Event into Event Topics.\n * const { topics } = AbiEvent.encode(transfer)\n *\n * // 3. Query for events matching the encoded Topics.\n * const logs = await window.ethereum!.request({\n *   method: 'eth_getLogs',\n *   params: [\n *     {\n *       address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *       fromBlock: Hex.fromNumber(19760235n),\n *       toBlock: Hex.fromNumber(19760240n),\n *       topics,\n *     },\n *   ],\n * })\n *\n * // 4. Decode the Log. // [!code focus]\n * const decoded = AbiEvent.decode(transfer, logs[0]!) // [!code focus]\n * // @log: {\n * // @log:   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n * // @log:   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n * // @log:   value: 603n\n * // @log: }\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiEvent - The ABI Event to decode.\n * @param log - `topics` & `data` to decode.\n * @returns The decoded event.\n */\nexport function decode<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends\n    | AbiItem_internal.ExtractArgs<abi, name>\n    | undefined = undefined,\n  //\n  abiEvent extends AbiEvent = AbiItem.fromAbi.ReturnType<\n    abi,\n    name,\n    args,\n    AbiEvent\n  >,\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  log: decode.Log,\n): decode.ReturnType<abiEvent>\nexport function decode<const abiEvent extends AbiEvent>(\n  abiEvent: abiEvent | AbiEvent,\n  log: decode.Log,\n): decode.ReturnType<abiEvent>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(\n  ...parameters:\n    | [\n        abi: Abi.Abi | readonly unknown[],\n        name: Hex.Hex | string,\n        log: decode.Log,\n      ]\n    | [abiEvent: AbiEvent, log: decode.Log]\n): decode.ReturnType {\n  const [abiEvent, log] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name, log] = parameters as [\n        Abi.Abi | readonly unknown[],\n        Hex.Hex | string,\n        decode.Log,\n      ]\n      return [fromAbi(abi, name), log]\n    }\n    return parameters as [AbiEvent, decode.Log]\n  })()\n\n  const { data, topics } = log\n\n  const [selector_, ...argTopics] = topics\n\n  const selector = getSelector(abiEvent)\n  if (selector_ !== selector)\n    throw new SelectorTopicMismatchError({\n      abiEvent,\n      actual: selector_,\n      expected: selector,\n    })\n\n  const { inputs } = abiEvent\n  const isUnnamed = inputs?.every((x) => !('name' in x && x.name))\n\n  let args: any = isUnnamed ? [] : {}\n\n  // Decode topics (indexed args).\n  const indexedInputs = inputs.filter((x) => 'indexed' in x && x.indexed)\n  for (let i = 0; i < indexedInputs.length; i++) {\n    const param = indexedInputs[i]!\n    const topic = argTopics[i]\n    if (!topic)\n      throw new TopicsMismatchError({\n        abiEvent,\n        param: param as abitype.AbiParameter & { indexed: boolean },\n      })\n    args[isUnnamed ? i : param.name || i] = (() => {\n      if (\n        param.type === 'string' ||\n        param.type === 'bytes' ||\n        param.type === 'tuple' ||\n        param.type.match(/^(.*)\\[(\\d+)?\\]$/)\n      )\n        return topic\n      const decoded = AbiParameters.decode([param], topic) || []\n      return decoded[0]\n    })()\n  }\n\n  // Decode data (non-indexed args).\n  const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed))\n  if (nonIndexedInputs.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = AbiParameters.decode(nonIndexedInputs, data)\n        if (decodedData) {\n          if (isUnnamed) args = [...args, ...decodedData]\n          else {\n            for (let i = 0; i < nonIndexedInputs.length; i++) {\n              const index = inputs.indexOf(nonIndexedInputs[i]!)\n              args[nonIndexedInputs[i]!.name! || index] = decodedData[i]\n            }\n          }\n        }\n      } catch (err) {\n        if (\n          err instanceof AbiParameters.DataSizeTooSmallError ||\n          err instanceof Cursor.PositionOutOfBoundsError\n        )\n          throw new DataMismatchError({\n            abiEvent,\n            data: data,\n            parameters: nonIndexedInputs,\n            size: Hex.size(data),\n          })\n        throw err\n      }\n    } else {\n      throw new DataMismatchError({\n        abiEvent,\n        data: '0x',\n        parameters: nonIndexedInputs,\n        size: 0,\n      })\n    }\n  }\n\n  return Object.values(args).length > 0 ? args : undefined\n}\n\nexport declare namespace decode {\n  type Log = {\n    data?: Hex.Hex | undefined\n    topics: readonly Hex.Hex[]\n  }\n\n  type ReturnType<abiEvent extends AbiEvent = AbiEvent> = IsNarrowable<\n    abiEvent,\n    AbiEvent\n  > extends true\n    ? abiEvent['inputs'] extends readonly []\n      ? undefined\n      : internal.ParametersToPrimitiveTypes<\n          abiEvent['inputs'],\n          { EnableUnion: false; IndexedOnly: false; Required: true }\n        >\n    : unknown\n\n  type ErrorType =\n    | AbiParameters.decode.ErrorType\n    | getSelector.ErrorType\n    | DataMismatchError\n    | SelectorTopicMismatchError\n    | TopicsMismatchError\n    | Errors.GlobalErrorType\n}\n\n/**\n * ABI-encodes the provided event input (`inputs`) into an array of [Event Topics](https://info.etherscan.com/what-is-event-logs/).\n *\n * :::tip\n *\n * This function is typically used to encode event arguments into [Event Topics](https://info.etherscan.com/what-is-event-logs/).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)'\n * )\n *\n * const { topics } = AbiEvent.encode(transfer)\n * // @log: ['0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0']\n * ```\n *\n * @example\n * ### Passing Arguments\n *\n * You can pass `indexed` parameter values to `AbiEvent.encode`.\n *\n * TypeScript types will be inferred from the ABI Event, to guard you from inserting the wrong values.\n *\n * For example, the `Transfer` event below accepts an `address` type for the `from` and `to` attributes.\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)'\n * )\n *\n * const { topics } = AbiEvent.encode(transfer, {\n *   from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code hl]\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8' // [!code hl]\n * })\n * // @log: [\n * // @log:   '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0',\n * // @log:   '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n * // @log:   '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8'\n * // @log: ]\n * ```\n *\n * @example\n * ### ABI-shorthand\n *\n * You can also specify an entire ABI object and an event name as parameters to {@link ox#AbiEvent.(encode:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiEvent } from 'ox'\n *\n * const abi = Abi.from([...])\n *\n * const { topics } = AbiEvent.encode(\n *   abi, // [!code focus]\n *   'Transfer', // [!code focus]\n *   {\n *     from: '0xf39fd6e51aad88f6f4ce6ab882779cfffb92266', // [!code focus]\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   }\n * )\n * // @log: [\n * // @log:   '0x406dade31f7ae4b5dbc276258c28dde5ae6d5c2773c5745802c493a2360e55e0',\n * // @log:   '0x00000000000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n * // @log:   '0x0000000000000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8'\n * // @log: ]\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiEvent.encode` to encode the topics of a `Transfer` event and query for events matching the encoded topics on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiEvent, Hex } from 'ox'\n *\n * // 1. Instantiate the `Transfer` ABI Event.\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)',\n * )\n *\n * // 2. Encode the ABI Event into Event Topics.\n * const { topics } = AbiEvent.encode(transfer)\n *\n * // 3. Query for events matching the encoded Topics.\n * const logs = await window.ethereum!.request({\n *   method: 'eth_getLogs',\n *   params: [\n *     {\n *       address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *       fromBlock: Hex.fromNumber(19760235n),\n *       toBlock: Hex.fromNumber(19760240n),\n *       topics,\n *     },\n *   ],\n * })\n * // @log: [\n * // @log:   \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n * // @log:   \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n * // @log:   \"0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1\",\n * // @log:   \"0x000000000000000000000000000000000000000000000000000000000000025b\",\n * // @log: ]\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiEvent - The event to encode.\n * @param args - The arguments to encode.\n * @returns The encoded event topics.\n */\nexport function encode<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends\n    | AbiItem_internal.ExtractArgs<abi, name>\n    | undefined = undefined,\n  //\n  abiEvent extends AbiEvent = AbiItem.fromAbi.ReturnType<\n    abi,\n    name,\n    args,\n    AbiEvent\n  >,\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  ...[args]: encode.Args<abiEvent>\n): encode.ReturnType\nexport function encode<const abiEvent extends AbiEvent>(\n  abiEvent: abiEvent | AbiEvent,\n  ...[args]: encode.Args<abiEvent>\n): encode.ReturnType\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function encode(\n  ...parameters:\n    | [\n        abi: Abi.Abi | readonly unknown[],\n        name: Hex.Hex | string,\n        args?: readonly unknown[] | Record<string, unknown>,\n      ]\n    | [abiEvent: AbiEvent, args?: readonly unknown[] | Record<string, unknown>]\n): encode.ReturnType {\n  const [abiEvent, args] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name, args] = parameters as [\n        Abi.Abi | readonly unknown[],\n        Hex.Hex | string,\n        readonly unknown[] | Record<string, unknown> | undefined,\n      ]\n      return [fromAbi(abi, name), args]\n    }\n    const [abiEvent, args] = parameters as [\n      AbiEvent,\n      readonly unknown[] | Record<string, unknown> | undefined,\n    ]\n    return [abiEvent, args]\n  })()\n\n  let topics: (Hex.Hex | Hex.Hex[] | null)[] = []\n  if (args && abiEvent.inputs) {\n    const indexedInputs = abiEvent.inputs.filter(\n      (param) => 'indexed' in param && param.indexed,\n    )\n    const args_ = Array.isArray(args)\n      ? args\n      : Object.values(args).length > 0\n        ? (indexedInputs?.map(\n            (x: any, i: number) => (args as any)[x.name ?? i],\n          ) ?? [])\n        : []\n\n    if (args_.length > 0) {\n      const encode = (param: abitype.AbiParameter, value: unknown) => {\n        if (param.type === 'string')\n          return Hash.keccak256(Hex.fromString(value as string))\n        if (param.type === 'bytes') return Hash.keccak256(value as Hex.Hex)\n        if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n          throw new FilterTypeNotSupportedError(param.type)\n        return AbiParameters.encode([param], [value])\n      }\n\n      topics =\n        indexedInputs?.map((param, i) => {\n          if (Array.isArray(args_[i]))\n            return args_[i].map((_: any, j: number) =>\n              encode(param, args_[i][j]),\n            )\n          return typeof args_[i] !== 'undefined' && args_[i] !== null\n            ? encode(param, args_[i])\n            : null\n        }) ?? []\n    }\n  }\n\n  const selector = (() => {\n    if (abiEvent.hash) return abiEvent.hash\n    return getSelector(abiEvent)\n  })()\n\n  return { topics: [selector, ...topics] }\n}\n\nexport declare namespace encode {\n  type Args<abiEvent extends AbiEvent> = IsNarrowable<\n    abiEvent,\n    AbiEvent\n  > extends true\n    ? abiEvent['inputs'] extends readonly []\n      ? []\n      : internal.ParametersToPrimitiveTypes<\n            abiEvent['inputs']\n          > extends infer result\n        ? result extends readonly []\n          ? []\n          : [result] | []\n        : []\n    : [readonly unknown[] | Record<string, unknown>] | []\n\n  type ReturnType = {\n    topics: Compute<\n      [selector: Hex.Hex, ...(Hex.Hex | readonly Hex.Hex[] | null)[]]\n    >\n  }\n\n  type ErrorType =\n    | AbiParameters.encode.ErrorType\n    | getSelector.ErrorType\n    | Hex.fromString.ErrorType\n    | Hash.keccak256.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Formats an {@link ox#AbiEvent.AbiEvent} into a **Human Readable ABI Error**.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const formatted = AbiEvent.format({\n *   type: 'event',\n *   name: 'Transfer',\n *   inputs: [\n *     { name: 'from', type: 'address', indexed: true },\n *     { name: 'to', type: 'address', indexed: true },\n *     { name: 'value', type: 'uint256' },\n *   ],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiEvent - The ABI Event to format.\n * @returns The formatted ABI Event.\n */\nexport function format<const abiEvent extends AbiEvent>(\n  abiEvent: abiEvent | AbiEvent,\n): abitype.FormatAbiItem<abiEvent> {\n  return abitype.formatAbiItem(abiEvent) as never\n}\n\nexport declare namespace format {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Parses an arbitrary **JSON ABI Event** or **Human Readable ABI Event** into a typed {@link ox#AbiEvent.AbiEvent}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from({\n *   name: 'Transfer',\n *   type: 'event',\n *   inputs: [\n *     { name: 'from', type: 'address', indexed: true },\n *     { name: 'to', type: 'address', indexed: true },\n *     { name: 'value', type: 'uint256' },\n *   ],\n * })\n *\n * transfer\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)' // [!code hl]\n * )\n *\n * transfer\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @param abiEvent - The ABI Event to parse.\n * @returns Typed ABI Event.\n */\nexport function from<\n  const abiEvent extends AbiEvent | string | readonly string[],\n>(\n  abiEvent: (abiEvent | AbiEvent | string | readonly string[]) &\n    (\n      | (abiEvent extends string ? internal.Signature<abiEvent> : never)\n      | (abiEvent extends readonly string[]\n          ? internal.Signatures<abiEvent>\n          : never)\n      | AbiEvent\n    ),\n  options: from.Options = {},\n): from.ReturnType<abiEvent> {\n  return AbiItem.from(abiEvent as AbiEvent, options) as never\n}\n\nexport declare namespace from {\n  type Options = {\n    /**\n     * Whether or not to prepare the extracted event (optimization for encoding performance).\n     * When `true`, the `hash` property is computed and included in the returned value.\n     *\n     * @default true\n     */\n    prepare?: boolean | undefined\n  }\n\n  type ReturnType<abiEvent extends AbiEvent | string | readonly string[]> =\n    AbiItem.from.ReturnType<abiEvent>\n\n  type ErrorType = AbiItem.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Extracts an {@link ox#AbiEvent.AbiEvent} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Events can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiEvent } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiEvent.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Events can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiEvent } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiEvent.fromAbi(abi, '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Event from the first topic of a Log.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends\n    | AbiItem_internal.ExtractArgs<abi, name>\n    | undefined = undefined,\n  //\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  options?: AbiItem.fromAbi.Options<\n    abi,\n    name,\n    args,\n    AbiItem_internal.ExtractArgs<abi, name>\n  >,\n): AbiItem.fromAbi.ReturnType<abi, name, args, AbiEvent> {\n  const item = AbiItem.fromAbi(abi, name, options as any)\n  if (item.type !== 'event')\n    throw new AbiItem.NotFoundError({ name, type: 'event' })\n  return item as never\n}\n\nexport declare namespace fromAbi {\n  type ErrorType = AbiItem.fromAbi.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes the event selector (hash of event signature) for an {@link ox#AbiEvent.AbiEvent}.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const selector = AbiEvent.getSelector('event Transfer(address indexed from, address indexed to, uint256 value)')\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f556a2'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const selector = AbiEvent.getSelector({\n *   name: 'Transfer',\n *   type: 'event',\n *   inputs: [\n *     { name: 'from', type: 'address', indexed: true },\n *     { name: 'to', type: 'address', indexed: true },\n *     { name: 'value', type: 'uint256' }\n *   ]\n * })\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f556a2'\n * ```\n *\n * @param abiItem - The ABI event to compute the selector for.\n * @returns The {@link ox#Hash.(keccak256:function)} hash of the event signature.\n */\nexport function getSelector(abiItem: string | AbiEvent): Hex.Hex {\n  return AbiItem.getSignatureHash(abiItem)\n}\n\nexport declare namespace getSelector {\n  type ErrorType = AbiItem.getSignatureHash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Thrown when the provided arguments do not match the expected arguments.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)',\n * )\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ad',\n *   ],\n * })\n *\n * AbiEvent.assertArgs(abiEvent, args, {\n *   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad',\n *   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   value: 1n,\n * })\n * // @error: AbiEvent.ArgsMismatchError: Given arguments do not match the expected arguments.\n * // @error: Event: event Transfer(address indexed from, address indexed to, uint256 value)\n * // @error: Expected Arguments:\n * // @error:   from:   0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac\n * // @error:   to:     0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad\n * // @error:   value:  1\n * // @error: Given Arguments:\n * // @error:   from:   0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad\n * // @error:   to:     0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac\n * // @error:   value:  1\n * ```\n *\n * ### Solution\n *\n * The provided arguments need to match the expected arguments.\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)',\n * )\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ad',\n *   ],\n * })\n *\n * AbiEvent.assertArgs(abiEvent, args, {\n *   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad', // [!code --]\n *   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac', // [!code ++]\n *   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac', // [!code --]\n *   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad', // [!code ++]\n *   value: 1n,\n * })\n * ```\n */\nexport class ArgsMismatchError extends Errors.BaseError {\n  override readonly name = 'AbiEvent.ArgsMismatchError'\n\n  constructor({\n    abiEvent,\n    expected,\n    given,\n  }: {\n    abiEvent: AbiEvent\n    expected: unknown\n    given: unknown\n  }) {\n    super('Given arguments do not match the expected arguments.', {\n      metaMessages: [\n        `Event: ${format(abiEvent)}`,\n        `Expected Arguments: ${!expected ? 'None' : ''}`,\n        expected ? prettyPrint(expected) : undefined,\n        `Given Arguments: ${!given ? 'None' : ''}`,\n        given ? prettyPrint(given) : undefined,\n      ],\n    })\n  }\n}\n\n/**\n * Thrown when no argument was found on the event signature.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)',\n * )\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ad',\n *   ],\n * })\n *\n * AbiEvent.assertArgs(abiEvent, args, {\n *   a: 'b',\n *   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad',\n *   value: 1n,\n * })\n * // @error: AbiEvent.InputNotFoundError: Parameter \"a\" not found on `event Transfer(address indexed from, address indexed to, uint256 value)`.\n * ```\n *\n * ### Solution\n *\n * Ensure the arguments match the event signature.\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)',\n * )\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ad',\n *   ],\n * })\n *\n * AbiEvent.assertArgs(abiEvent, args, {\n *   a: 'b', // [!code --]\n *   from: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   to: '0xa5cc3c03994db5b0d9a5eedd10cabab0813678ad',\n *   value: 1n,\n * })\n * ```\n */\nexport class InputNotFoundError extends Errors.BaseError {\n  override readonly name = 'AbiEvent.InputNotFoundError'\n\n  constructor({\n    abiEvent,\n    name,\n  }: {\n    abiEvent: AbiEvent\n    name: string\n  }) {\n    super(`Parameter \"${name}\" not found on \\`${format(abiEvent)}\\`.`)\n  }\n}\n\n/**\n * Thrown when the provided data size does not match the expected size from the non-indexed parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from(\n *   'event Transfer(address indexed from, address to, uint256 value)',\n *   //                                    ↑ 32 bytes + ↑ 32 bytes = 64 bytes\n * )\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0000000000000000000000000000000000000000000000000000000023c34600',\n *   //       ↑ 32 bytes ❌\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   ],\n * })\n * // @error: AbiEvent.DataMismatchError: Data size of 32 bytes is too small for non-indexed event parameters.\n * // @error: Non-indexed Parameters: (address to, uint256 value)\n * // @error: Data:   0x0000000000000000000000000000000000000000000000000000000023c34600 (32 bytes)\n * ```\n *\n * ### Solution\n *\n * Ensure that the data size matches the expected size.\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from(\n *   'event Transfer(address indexed from, address to, uint256 value)',\n *   //                                    ↑ 32 bytes + ↑ 32 bytes = 64 bytes\n * )\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000000000000023c34600',\n *   //       ↑ 64 bytes ✅\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   ],\n * })\n * ```\n */\nexport class DataMismatchError extends Errors.BaseError {\n  override readonly name = 'AbiEvent.DataMismatchError'\n\n  abiEvent: AbiEvent\n  data: Hex.Hex\n  parameters: readonly abitype.AbiParameter[]\n  size: number\n\n  constructor({\n    abiEvent,\n    data,\n    parameters,\n    size,\n  }: {\n    abiEvent: AbiEvent\n    data: Hex.Hex\n    parameters: readonly abitype.AbiParameter[]\n    size: number\n  }) {\n    super(\n      [\n        `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n      ].join('\\n'),\n      {\n        metaMessages: [\n          `Non-indexed Parameters: (${AbiParameters.format(parameters as any)})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n      },\n    )\n\n    this.abiEvent = abiEvent\n    this.data = data\n    this.parameters = parameters\n    this.size = size\n  }\n}\n\n/**\n * Thrown when the provided topics do not match the expected number of topics.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)',\n * )\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *   ],\n * })\n * // @error: AbiEvent.TopicsMismatchError: Expected a topic for indexed event parameter \"to\" for \"event Transfer(address indexed from, address indexed to, uint256 value)\".\n * ```\n *\n * ### Solution\n *\n * Ensure that the topics match the expected number of topics.\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const abiEvent = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 value)',\n * )\n *\n * const args = AbiEvent.decode(abiEvent, {\n *   data: '0x0000000000000000000000000000000000000000000000000000000000000001',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000a5cc3c03994db5b0d9a5eedd10cabab0813678ac',\n *     '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code ++]\n *   ],\n * })\n * ```\n *\n */\nexport class TopicsMismatchError extends Errors.BaseError {\n  override readonly name = 'AbiEvent.TopicsMismatchError'\n\n  abiEvent: AbiEvent\n\n  constructor({\n    abiEvent,\n    param,\n  }: {\n    abiEvent: AbiEvent\n    param: abitype.AbiParameter & { indexed: boolean }\n  }) {\n    super(\n      [\n        `Expected a topic for indexed event parameter${\n          param.name ? ` \"${param.name}\"` : ''\n        } for \"${format(abiEvent)}\".`,\n      ].join('\\n'),\n    )\n\n    this.abiEvent = abiEvent\n  }\n}\n\n/**\n * Thrown when the provided selector does not match the expected selector.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, bool sender)',\n * )\n *\n * AbiEvent.decode(transfer, {\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa96045',\n *     '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   ],\n * })\n * // @error: AbiEvent.SelectorTopicMismatchError: topics[0]=\"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\" does not match the expected topics[0]=\"0x3da3cd3cf420c78f8981e7afeefa0eab1f0de0eb56e78ad9ba918ed01c0b402f\".\n * // @error: Event: event Transfer(address indexed from, address indexed to, bool sender)\n * // @error: Selector: 0x3da3cd3cf420c78f8981e7afeefa0eab1f0de0eb56e78ad9ba918ed01c0b402f\n * ```\n *\n * ### Solution\n *\n * Ensure that the provided selector matches the selector of the event signature.\n *\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, bool sender)',\n * )\n *\n * AbiEvent.decode(transfer, {\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef', // [!code --]\n *     '0x3da3cd3cf420c78f8981e7afeefa0eab1f0de0eb56e78ad9ba918ed01c0b402f', // [!code ++]\n *     '0x000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa96045',\n *     '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   ],\n * })\n * ```\n */\nexport class SelectorTopicMismatchError extends Errors.BaseError {\n  override readonly name = 'AbiEvent.SelectorTopicMismatchError'\n\n  constructor({\n    abiEvent,\n    actual,\n    expected,\n  }: {\n    abiEvent: AbiEvent\n    actual: Hex.Hex | undefined\n    expected: Hex.Hex\n  }) {\n    super(\n      `topics[0]=\"${actual}\" does not match the expected topics[0]=\"${expected}\".`,\n      {\n        metaMessages: [`Event: ${format(abiEvent)}`, `Selector: ${expected}`],\n      },\n    )\n  }\n}\n\n/**\n * Thrown when the provided filter type is not supported.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from('event Transfer((string) indexed a, string b)')\n *\n * AbiEvent.encode(transfer, {\n *   a: ['hello'],\n * })\n * // @error: AbiEvent.FilterTypeNotSupportedError: Filter type \"tuple\" is not supported.\n * ```\n *\n * ### Solution\n *\n * Provide a valid event input type.\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiEvent } from 'ox'\n *\n * const transfer = AbiEvent.from('event Transfer((string) indexed a, string b)') // [!code --]\n * const transfer = AbiEvent.from('event Transfer(string indexed a, string b)') // [!code ++]\n * ```\n *\n *\n */\nexport class FilterTypeNotSupportedError extends Errors.BaseError {\n  override readonly name = 'AbiEvent.FilterTypeNotSupportedError'\n  constructor(type: string) {\n    super(`Filter type \"${type}\" is not supported.`)\n  }\n}\n", "export {};\n//# sourceMappingURL=AccountProof.js.map", "import * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\nexport const ivLength = 16\n\n/**\n * Decrypts encrypted data using AES-GCM.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm, Hex } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * const secret = Hex.fromString('i am a secret message')\n *\n * const encrypted = await AesGcm.encrypt(secret, key)\n *\n * const decrypted = await AesGcm.decrypt(encrypted, key) // [!code focus]\n * // @log: Hex.fromString('i am a secret message')\n * ```\n *\n * @param value - The data to encrypt.\n * @param key - The `CryptoKey` to use for encryption.\n * @param options - Decryption options.\n * @returns The decrypted data.\n */\nexport async function decrypt<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Bytes.Bytes | Hex.Hex,\n  key: CryptoKey,\n  options: decrypt.Options<as> = {},\n): Promise<decrypt.ReturnType<as>> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const encrypted = Bytes.from(value)\n  const iv = encrypted.slice(0, ivLength)\n  const data = encrypted.slice(ivLength)\n  const decrypted = await globalThis.crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    Bytes.from(data),\n  )\n  const result = new Uint8Array(decrypted)\n  if (as === 'Bytes') return result as never\n  return Hex.from(result) as never\n}\n\nexport declare namespace decrypt {\n  type Options<as extends 'Bytes' | 'Hex' = 'Bytes' | 'Hex'> = {\n    /** The output format. @default 'Bytes' */\n    as?: as | 'Bytes' | 'Hex' | undefined\n  }\n\n  type ReturnType<as extends 'Bytes' | 'Hex' = 'Bytes' | 'Hex'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encrypts data using AES-GCM.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm, Hex } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * const secret = Hex.fromString('i am a secret message')\n *\n * const encrypted = await AesGcm.encrypt(secret, key) // [!code focus]\n * // @log: '0x5e257b25bcf53d5431e54e5a68ca0138306d31bb6154f35a97bb8ea18111e7d82bcf619d3c76c4650688bc5310eed80b8fc86d1e3e'\n * ```\n *\n * @param value - The data to encrypt.\n * @param key - The `CryptoKey` to use for encryption.\n * @param options - Encryption options.\n * @returns The encrypted data.\n */\nexport async function encrypt<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Bytes' | 'Hex' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Bytes.Bytes | Hex.Hex,\n  key: CryptoKey,\n  options: encrypt.Options<as> = {},\n): Promise<encrypt.ReturnType<as>> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const iv = Bytes.random(ivLength)\n  const encrypted = await globalThis.crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    Bytes.from(value),\n  )\n  const result = Bytes.concat(iv, new Uint8Array(encrypted))\n  if (as === 'Bytes') return result as never\n  return Hex.from(result) as never\n}\n\nexport declare namespace encrypt {\n  type Options<as extends 'Bytes' | 'Hex' = 'Bytes' | 'Hex'> = {\n    /** The output format. @default 'Hex' */\n    as?: as | 'Bytes' | 'Hex' | undefined\n  }\n\n  type ReturnType<as extends 'Bytes' | 'Hex' = 'Bytes' | 'Hex'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.concat.ErrorType\n    | Bytes.from.ErrorType\n    | Bytes.random.ErrorType\n    | Hex.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Derives an AES-GCM key from a password using PBKDF2.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * // @log: CryptoKey {}\n * ```\n *\n * @param options - Options for key derivation.\n * @returns The derived key.\n */\nexport async function getKey(options: getKey.Options): Promise<CryptoKey> {\n  const { iterations = 900_000, password, salt = randomSalt(32) } = options\n  const baseKey = await globalThis.crypto.subtle.importKey(\n    'raw',\n    Bytes.fromString(password),\n    { name: 'PBKDF2' },\n    false,\n    ['deriveBits', 'deriveKey'],\n  )\n  const key = await globalThis.crypto.subtle.deriveKey(\n    {\n      name: 'PBKDF2',\n      salt,\n      iterations,\n      hash: 'SHA-256',\n    },\n    baseKey,\n    { name: 'AES-GCM', length: 256 },\n    false,\n    ['encrypt', 'decrypt'],\n  )\n  return key\n}\n\nexport declare namespace getKey {\n  type Options = {\n    /** The number of iterations to use. @default 900_000 */\n    iterations?: number | undefined\n    /** Password to derive key from. */\n    password: string\n    /** Salt to use for key derivation. @default `AesGcm.randomSalt(32)` */\n    salt?: Bytes.Bytes | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Generates a random salt of the specified size.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm } from 'ox'\n *\n * const salt = AesGcm.randomSalt()\n * // @log: Uint8Array [123, 79, 183, 167, 163, 136, 136, 16, 168, 126, 13, 165, 170, 166, 136, 136, 16, 168, 126, 13, 165, 170, 166, 136, 136, 16, 168, 126, 13, 165, 170, 166]\n * ```\n *\n * @param size - The size of the salt to generate. Defaults to `32`.\n * @returns A random salt of the specified size.\n */\nexport function randomSalt(size = 32): Bytes.Bytes {\n  return Bytes.random(size)\n}\n\nexport declare namespace randomSalt {\n  type ErrorType = Bytes.random.ErrorType | Errors.GlobalErrorType\n}\n", "import * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as internal from './internal/base58.js'\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} to a Base58-encoded string.\n *\n * @example\n * ```ts twoslash\n * import { Base58, Bytes } from 'ox'\n *\n * const value = Base58.fromBytes(Bytes.fromString('Hello World!'))\n * // @log: '2NEpo7TZRRrLZSi2U'\n * ```\n *\n * @param value - The byte array to encode.\n * @returns The Base58 encoded string.\n */\nexport function fromBytes(value: Bytes.Bytes) {\n  return internal.from(value)\n}\n\nexport declare namespace fromBytes {\n  type ErrorType = internal.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Hex.Hex} to a Base58-encoded string.\n *\n * @example\n * ```ts twoslash\n * import { Base58, Hex } from 'ox'\n *\n * const value = Base58.fromHex(Hex.fromString('Hello World!'))\n * // @log: '2NEpo7TZRRrLZSi2U'\n * ```\n *\n * @param value - The byte array to encode.\n * @returns The Base58 encoded string.\n */\nexport function fromHex(value: Hex.Hex) {\n  return internal.from(value)\n}\n\nexport declare namespace fromHex {\n  type ErrorType = internal.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a string to a Base58-encoded string.\n *\n * @example\n * ```ts twoslash\n * import { Base58 } from 'ox'\n *\n * const value = Base58.fromString('Hello World!')\n * // @log: '2NEpo7TZRRrLZSi2U'\n * ```\n *\n * @param value - The string to encode.\n * @returns The Base58 encoded string.\n */\nexport function fromString(value: string) {\n  return internal.from(Bytes.fromString(value))\n}\n\nexport declare namespace fromString {\n  type ErrorType = internal.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base58-encoded string to a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Base58 } from 'ox'\n *\n * const value = Base58.toBytes('2NEpo7TZRRrLZSi2U')\n * // @log: Uint8Array [ 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33 ]\n * ```\n *\n * @param value - The Base58 encoded string.\n * @returns The decoded byte array.\n */\nexport function toBytes(value: string): Bytes.Bytes {\n  return Bytes.fromHex(toHex(value))\n}\n\nexport declare namespace toBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base58-encoded string to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Base58 } from 'ox'\n *\n * const value = Base58.toHex('2NEpo7TZRRrLZSi2U')\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The Base58 encoded string.\n * @returns The decoded hex string.\n */\nexport function toHex(value: string): Hex.Hex {\n  let integer = BigInt(0)\n  let pad = 0\n  let checkPad = true\n\n  for (let i = 0; i < value.length; i++) {\n    const char = value[i]!\n\n    // check for leading 1s\n    if (checkPad && char === '1') pad++\n    else checkPad = false\n\n    // check for invalid characters\n    if (typeof internal.alphabetToInteger[char] !== 'bigint')\n      throw new Error('invalid base58 character: ' + char)\n\n    integer = integer * 58n\n    integer = integer + internal.alphabetToInteger[char]!\n  }\n\n  if (!pad) return `0x${integer.toString(16)}` as Hex.Hex\n  return `0x${'0'.repeat(pad * 2)}${integer.toString(16)}` as Hex.Hex\n}\n\nexport declare namespace toHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base58-encoded string to a string.\n *\n * @example\n * ```ts twoslash\n * import { Base58 } from 'ox'\n *\n * const value = Base58.toString('2NEpo7TZRRrLZSi2U')\n * // @log: 'Hello World!'\n * ```\n *\n * @param value - The Base58 encoded string.\n * @returns The decoded string.\n */\nexport function toString(value: string): string {\n  return Hex.toString(toHex(value))\n}\n\nexport declare namespace toString {\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as Bytes from '../Bytes.js'\nimport type * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\n\n/** @internal */\nexport const integerToAlphabet =\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\n/** @internal */\nexport const alphabetToInteger = /* __PURE__ */ Object.freeze<\n  Record<string, bigint>\n>({\n  1: 0n,\n  2: 1n,\n  3: 2n,\n  4: 3n,\n  5: 4n,\n  6: 5n,\n  7: 6n,\n  8: 7n,\n  9: 8n,\n  A: 9n,\n  B: 10n,\n  C: 11n,\n  D: 12n,\n  E: 13n,\n  F: 14n,\n  G: 15n,\n  H: 16n,\n  J: 17n,\n  K: 18n,\n  L: 19n,\n  M: 20n,\n  N: 21n,\n  P: 22n,\n  Q: 23n,\n  R: 24n,\n  S: 25n,\n  T: 26n,\n  U: 27n,\n  V: 28n,\n  W: 29n,\n  X: 30n,\n  Y: 31n,\n  Z: 32n,\n  a: 33n,\n  b: 34n,\n  c: 35n,\n  d: 36n,\n  e: 37n,\n  f: 38n,\n  g: 39n,\n  h: 40n,\n  i: 41n,\n  j: 42n,\n  k: 43n,\n  m: 44n,\n  n: 45n,\n  o: 46n,\n  p: 47n,\n  q: 48n,\n  r: 49n,\n  s: 50n,\n  t: 51n,\n  u: 52n,\n  v: 53n,\n  w: 54n,\n  x: 55n,\n  y: 56n,\n  z: 57n,\n})\n\n/** @internal */\nexport function from(value: Hex.Hex | Bytes.Bytes) {\n  let bytes = Bytes.from(value)\n\n  let integer = (() => {\n    let hex = value\n    if (value instanceof Uint8Array) hex = Hex.fromBytes(bytes)\n    return BigInt(hex as string)\n  })()\n\n  let result = ''\n  while (integer > 0n) {\n    const remainder = Number(integer % 58n)\n    integer = integer / 58n\n    result = integerToAlphabet[remainder] + result\n  }\n\n  while (bytes.length > 1 && bytes[0] === 0) {\n    result = '1' + result\n    bytes = bytes.slice(1)\n  }\n\n  return result\n}\n\n/** @internal */\nexport declare namespace from {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\n", "import { blake3 } from '@noble/hashes/blake3'\n\nimport * as Bytes from './Bytes.js'\nimport type { OneOf } from './internal/types.js'\n\n/** Type that defines a Binary State Tree instance. */\nexport type BinaryStateTree = {\n  root: Node\n}\n\n/** Type defining a node of the BST. */\nexport type Node = OneOf<EmptyNode | StemNode | InternalNode>\n\n/**\n * Creates a new Binary State Tree instance.\n *\n * @example\n * ```ts twoslash\n * import { BinaryStateTree } from 'ox'\n *\n * const tree = BinaryStateTree.create()\n * ```\n *\n * @returns A Binary State Tree.\n */\nexport function create(): BinaryStateTree {\n  return {\n    root: emptyNode(),\n  }\n}\n\n/**\n * Inserts a key-value pair into the Binary State Tree.\n *\n * @example\n * ```ts twoslash\n * import { BinaryStateTree, Bytes } from 'ox'\n *\n * const tree = BinaryStateTree.create()\n *\n * BinaryStateTree.insert( // [!code focus]\n *   tree, // [!code focus]\n *   Bytes.fromHex('0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54'), // [!code focus]\n *   Bytes.fromHex('0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1') // [!code focus]\n * ) // [!code focus]\n * ```\n *\n * @param tree - Binary State Tree instance.\n * @param key - Key to insert.\n * @param value - Value to insert.\n */\nexport function insert(\n  tree: BinaryStateTree,\n  key: Bytes.Bytes,\n  value: Bytes.Bytes,\n): void {\n  const stem = Bytes.slice(key, 0, 31)\n  const subIndex = Bytes.slice(key, 31)[0]!\n\n  if (tree.root.type === 'empty') {\n    tree.root = stemNode(stem)\n    tree.root.values[subIndex] = value\n    return\n  }\n\n  function inner(\n    node_: Node,\n    stem: Bytes.Bytes,\n    subIndex: number,\n    value: Bytes.Bytes,\n    depth: number,\n  ): Node {\n    let node = node_\n\n    if (node.type === 'empty') {\n      node = stemNode(stem)\n      node.values[subIndex!] = value\n      return node\n    }\n\n    const stemBits = bytesToBits(stem)\n    if (node.type === 'stem') {\n      if (Bytes.isEqual(node.stem, stem)) {\n        node.values[subIndex!] = value\n        return node\n      }\n      const existingStemBits = bytesToBits(node.stem)\n      return splitLeaf(node, stemBits, existingStemBits, subIndex, value, depth)\n    }\n\n    if (node.type === 'internal') {\n      const bit = stemBits[depth]\n      if (bit === 0) {\n        node.left = inner(node.left, stem, subIndex, value, depth + 1)\n      } else {\n        node.right = inner(node.right, stem, subIndex, value, depth + 1)\n      }\n      return node\n    }\n\n    return emptyNode()\n  }\n  tree.root = inner(tree.root, stem, subIndex, value, 0)\n}\n\n/**\n * Merkelizes a Binary State Tree.\n *\n * @example\n * ```ts twoslash\n * import { BinaryStateTree, Bytes } from 'ox'\n *\n * const tree = BinaryStateTree.create()\n *\n * BinaryStateTree.insert(\n *   tree,\n *   Bytes.fromHex('0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54'),\n *   Bytes.fromHex('0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1')\n * )\n *\n * const hash = BinaryStateTree.merkelize(tree) // [!code focus]\n * ```\n *\n * @param tree - Binary State Tree instance.\n * @returns Merkle hash.\n */\nexport function merkelize(tree: BinaryStateTree): Bytes.Bytes {\n  function inner(node: Node): Bytes.Bytes {\n    if (node.type === 'empty') return new Uint8Array(32).fill(0)\n    if (node.type === 'internal') {\n      const hash_left = inner(node.left)\n      const hash_right = inner(node.right)\n      return hash(Bytes.concat(hash_left, hash_right))\n    }\n\n    let level = node.values.map(hash)\n    while (level.length > 1) {\n      const level_ = []\n      for (let i = 0; i < level.length; i += 2)\n        level_.push(hash(Bytes.concat(level[i]!, level[i + 1]!)))\n      level = level_\n    }\n\n    return hash(Bytes.concat(node.stem, new Uint8Array(1).fill(0), level[0]!))\n  }\n\n  return inner(tree.root)\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Internal\n//////////////////////////////////////////////////////////////////////////////\n\n/** @internal */\ntype EmptyNode = {\n  type: 'empty'\n}\n\n/** @internal */\ntype InternalNode = {\n  left: Node\n  right: Node\n  type: 'internal'\n}\n\n/** @internal */\ntype StemNode = {\n  stem: Bytes.Bytes\n  values: (Bytes.Bytes | undefined)[]\n  type: 'stem'\n}\n\n/** @internal */\nfunction splitLeaf(\n  leaf: Node,\n  stemBits: number[],\n  existingStemBits: number[],\n  subIndex: number,\n  value: Bytes.Bytes,\n  depth: number,\n): Node {\n  if (stemBits[depth] === existingStemBits[depth]) {\n    const internal = internalNode()\n    const bit = stemBits[depth]\n    if (bit === 0) {\n      internal.left = splitLeaf(\n        leaf,\n        stemBits,\n        existingStemBits,\n        subIndex,\n        value,\n        depth + 1,\n      )\n    } else {\n      internal.right = splitLeaf(\n        leaf,\n        stemBits,\n        existingStemBits,\n        subIndex,\n        value,\n        depth + 1,\n      )\n    }\n    return internal\n  }\n\n  const internal = internalNode()\n  const bit = stemBits[depth]\n  const stem = bitsToBytes(stemBits)\n  if (bit === 0) {\n    internal.left = stemNode(stem)\n    internal.left.values[subIndex] = value\n    internal.right = leaf\n  } else {\n    internal.right = stemNode(stem)\n    internal.right.values[subIndex] = value\n    internal.left = leaf\n  }\n  return internal\n}\n\n/** @internal */\nfunction emptyNode(): EmptyNode {\n  return {\n    type: 'empty',\n  }\n}\n\n/** @internal */\nfunction internalNode(): InternalNode {\n  return {\n    left: emptyNode(),\n    right: emptyNode(),\n    type: 'internal',\n  }\n}\n\n/** @internal */\nfunction stemNode(stem: Bytes.Bytes): StemNode {\n  return {\n    stem,\n    values: Array.from({ length: 256 }, () => undefined),\n    type: 'stem',\n  }\n}\n\n/** @internal */\nfunction bytesToBits(bytes: Bytes.Bytes): number[] {\n  const bits = []\n  for (const byte of bytes)\n    for (let i = 0; i < 8; i++) bits.push((byte >> (7 - i)) & 1)\n  return bits\n}\n\n/** @internal */\nfunction bitsToBytes(bits: number[]): Bytes.Bytes {\n  const byte_data = new Uint8Array(bits.length / 8)\n  for (let i = 0; i < bits.length; i += 8) {\n    let byte = 0\n    for (let j = 0; j < 8; j++) byte |= bits[i + j]! << (7 - j)\n    byte_data[i / 8] = byte\n  }\n  return byte_data\n}\n\n/** @internal */\nfunction hash(bytes: Bytes.Bytes | undefined): Bytes.Bytes {\n  if (!bytes) return new Uint8Array(32).fill(0)\n  if (!bytes.some((byte) => byte !== 0)) return new Uint8Array(32).fill(0)\n  return blake3(bytes)\n}\n", "/**\n * Internal helpers for blake hash.\n * @module\n */\nimport { rotr } from './utils.ts';\n\n/**\n * Internal blake variable.\n * For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n */\n// prettier-ignore\nexport const BSIGMA: Uint8Array = /* @__PURE__ */ Uint8Array.from([\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  // Blake1, unused in others\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n]);\n\n// prettier-ignore\nexport type Num4 = { a: number; b: number; c: number; d: number; };\n\n// Mixing function G splitted in two halfs\nexport function G1s(a: number, b: number, c: number, d: number, x: number): Num4 {\n  a = (a + b + x) | 0;\n  d = rotr(d ^ a, 16);\n  c = (c + d) | 0;\n  b = rotr(b ^ c, 12);\n  return { a, b, c, d };\n}\n\nexport function G2s(a: number, b: number, c: number, d: number, x: number): Num4 {\n  a = (a + b + x) | 0;\n  d = rotr(d ^ a, 8);\n  c = (c + d) | 0;\n  b = rotr(b ^ c, 7);\n  return { a, b, c, d };\n}\n", "/**\n * blake2b (64-bit) & blake2s (8 to 32-bit) hash functions.\n * b could have been faster, but there is no fast u64 in js, so s is 1.5x faster.\n * @module\n */\nimport { BSIGMA, G1s, G2s } from './_blake.ts';\nimport { SHA256_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createOptHasher, Hash, swap32IfBE, swap8IfBE, toBytes, u32,\n  type CHashO, type Input\n} from './utils.ts';\n\n/** Blake hash options. dkLen is output length. key is used in MAC mode. salt is used in KDF mode. */\nexport type Blake2Opts = {\n  dkLen?: number;\n  key?: Input;\n  salt?: Input;\n  personalization?: Input;\n};\n\n// Same as SHA512_IV, but swapped endianness: LE instead of BE. iv[1] is iv[0], etc.\nconst B2B_IV = /* @__PURE__ */ Uint32Array.from([\n  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\n  0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19,\n]);\n// Temporary buffer\nconst BBUF = /* @__PURE__ */ new Uint32Array(32);\n\n// Mixing function G splitted in two halfs\nfunction G1b(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\n  // NOTE: V is LE here\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  let ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 32)\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });\n  // v[c] = (v[c] + v[d]) | 0;\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n  // v[b] = rotr(v[b] ^ v[c], 24)\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });\n  (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n  (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n  (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n  (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\n\nfunction G2b(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\n  // NOTE: V is LE here\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  let ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 16)\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });\n  // v[c] = (v[c] + v[d]) | 0;\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n  // v[b] = rotr(v[b] ^ v[c], 63)\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });\n  (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n  (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n  (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n  (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\n\nfunction checkBlake2Opts(\n  outputLen: number,\n  opts: Blake2Opts | undefined = {},\n  keyLen: number,\n  saltLen: number,\n  persLen: number\n) {\n  anumber(keyLen);\n  if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\n  const { key, salt, personalization } = opts;\n  if (key !== undefined && (key.length < 1 || key.length > keyLen))\n    throw new Error('key length must be undefined or 1..' + keyLen);\n  if (salt !== undefined && salt.length !== saltLen)\n    throw new Error('salt must be undefined or ' + saltLen);\n  if (personalization !== undefined && personalization.length !== persLen)\n    throw new Error('personalization must be undefined or ' + persLen);\n}\n\n/** Class, from which others are subclassed. */\nexport abstract class BLAKE2<T extends BLAKE2<T>> extends Hash<T> {\n  protected abstract compress(msg: Uint32Array, offset: number, isLast: boolean): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected buffer: Uint8Array;\n  protected buffer32: Uint32Array;\n  protected finished = false;\n  protected destroyed = false;\n  protected length: number = 0;\n  protected pos: number = 0;\n  readonly blockLen: number;\n  readonly outputLen: number;\n\n  constructor(blockLen: number, outputLen: number) {\n    super();\n    anumber(blockLen);\n    anumber(outputLen);\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.buffer = new Uint8Array(blockLen);\n    this.buffer32 = u32(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    // Main difference with other hashes: there is flag for last block,\n    // so we cannot process current block before we know that there\n    // is the next one. This significantly complicates logic and reduces ability\n    // to do zero-copy processing\n    const { blockLen, buffer, buffer32 } = this;\n    const len = data.length;\n    const offset = data.byteOffset;\n    const buf = data.buffer;\n    for (let pos = 0; pos < len; ) {\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\n      if (this.pos === blockLen) {\n        swap32IfBE(buffer32);\n        this.compress(buffer32, 0, false);\n        swap32IfBE(buffer32);\n        this.pos = 0;\n      }\n      const take = Math.min(blockLen - this.pos, len - pos);\n      const dataOffset = offset + pos;\n      // full block && aligned to 4 bytes && not last in input\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n        swap32IfBE(data32);\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n          this.length += blockLen;\n          this.compress(data32, pos32, false);\n        }\n        swap32IfBE(data32);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      this.length += take;\n      pos += take;\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    const { pos, buffer32 } = this;\n    this.finished = true;\n    // Padding\n    clean(this.buffer.subarray(pos));\n    swap32IfBE(buffer32);\n    this.compress(buffer32, 0, true);\n    swap32IfBE(buffer32);\n    const out32 = u32(out);\n    this.get().forEach((v, i) => (out32[i] = swap8IfBE(v)));\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    const { buffer, length, finished, destroyed, outputLen, pos } = this;\n    to ||= new (this.constructor as any)({ dkLen: outputLen }) as T;\n    to.set(...this.get());\n    to.buffer.set(buffer);\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    // @ts-ignore\n    to.outputLen = outputLen;\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\nexport class BLAKE2b extends BLAKE2<BLAKE2b> {\n  // Same as SHA-512, but LE\n  private v0l = B2B_IV[0] | 0;\n  private v0h = B2B_IV[1] | 0;\n  private v1l = B2B_IV[2] | 0;\n  private v1h = B2B_IV[3] | 0;\n  private v2l = B2B_IV[4] | 0;\n  private v2h = B2B_IV[5] | 0;\n  private v3l = B2B_IV[6] | 0;\n  private v3h = B2B_IV[7] | 0;\n  private v4l = B2B_IV[8] | 0;\n  private v4h = B2B_IV[9] | 0;\n  private v5l = B2B_IV[10] | 0;\n  private v5h = B2B_IV[11] | 0;\n  private v6l = B2B_IV[12] | 0;\n  private v6h = B2B_IV[13] | 0;\n  private v7l = B2B_IV[14] | 0;\n  private v7h = B2B_IV[15] | 0;\n\n  constructor(opts: Blake2Opts = {}) {\n    const olen = opts.dkLen === undefined ? 64 : opts.dkLen;\n    super(128, olen);\n    checkBlake2Opts(olen, opts, 64, 16, 16);\n    let { key, personalization, salt } = opts;\n    let keyLength = 0;\n    if (key !== undefined) {\n      key = toBytes(key);\n      keyLength = key.length;\n    }\n    this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n    if (salt !== undefined) {\n      salt = toBytes(salt);\n      const slt = u32(salt);\n      this.v4l ^= swap8IfBE(slt[0]);\n      this.v4h ^= swap8IfBE(slt[1]);\n      this.v5l ^= swap8IfBE(slt[2]);\n      this.v5h ^= swap8IfBE(slt[3]);\n    }\n    if (personalization !== undefined) {\n      personalization = toBytes(personalization);\n      const pers = u32(personalization);\n      this.v6l ^= swap8IfBE(pers[0]);\n      this.v6h ^= swap8IfBE(pers[1]);\n      this.v7l ^= swap8IfBE(pers[2]);\n      this.v7h ^= swap8IfBE(pers[3]);\n    }\n    if (key !== undefined) {\n      // Pad to blockLen and update\n      const tmp = new Uint8Array(this.blockLen);\n      tmp.set(key);\n      this.update(tmp);\n    }\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\n    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n  }\n  // prettier-ignore\n  protected set(\n    v0l: number, v0h: number, v1l: number, v1h: number,\n    v2l: number, v2h: number, v3l: number, v3h: number,\n    v4l: number, v4h: number, v5l: number, v5h: number,\n    v6l: number, v6h: number, v7l: number, v7h: number\n  ): void {\n    this.v0l = v0l | 0;\n    this.v0h = v0h | 0;\n    this.v1l = v1l | 0;\n    this.v1h = v1h | 0;\n    this.v2l = v2l | 0;\n    this.v2h = v2h | 0;\n    this.v3l = v3l | 0;\n    this.v3h = v3h | 0;\n    this.v4l = v4l | 0;\n    this.v4h = v4h | 0;\n    this.v5l = v5l | 0;\n    this.v5h = v5h | 0;\n    this.v6l = v6l | 0;\n    this.v6h = v6h | 0;\n    this.v7l = v7l | 0;\n    this.v7h = v7h | 0;\n  }\n  protected compress(msg: Uint32Array, offset: number, isLast: boolean): void {\n    this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.\n    BBUF.set(B2B_IV, 16); // Second half from IV.\n    let { h, l } = u64.fromBig(BigInt(this.length));\n    BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.\n    BBUF[25] = B2B_IV[9] ^ h; // High word.\n    // Invert all bits for last block\n    if (isLast) {\n      BBUF[28] = ~BBUF[28];\n      BBUF[29] = ~BBUF[29];\n    }\n    let j = 0;\n    const s = BSIGMA;\n    for (let i = 0; i < 12; i++) {\n      G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n      G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n      G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n      G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n      G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n      G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n      G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n      G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n\n      G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n      G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n      G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n      G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n      G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n      G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n      G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n      G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n    }\n    this.v0l ^= BBUF[0] ^ BBUF[16];\n    this.v0h ^= BBUF[1] ^ BBUF[17];\n    this.v1l ^= BBUF[2] ^ BBUF[18];\n    this.v1h ^= BBUF[3] ^ BBUF[19];\n    this.v2l ^= BBUF[4] ^ BBUF[20];\n    this.v2h ^= BBUF[5] ^ BBUF[21];\n    this.v3l ^= BBUF[6] ^ BBUF[22];\n    this.v3h ^= BBUF[7] ^ BBUF[23];\n    this.v4l ^= BBUF[8] ^ BBUF[24];\n    this.v4h ^= BBUF[9] ^ BBUF[25];\n    this.v5l ^= BBUF[10] ^ BBUF[26];\n    this.v5h ^= BBUF[11] ^ BBUF[27];\n    this.v6l ^= BBUF[12] ^ BBUF[28];\n    this.v6h ^= BBUF[13] ^ BBUF[29];\n    this.v7l ^= BBUF[14] ^ BBUF[30];\n    this.v7h ^= BBUF[15] ^ BBUF[31];\n    clean(BBUF);\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer32);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * Blake2b hash function. 64-bit. 1.5x slower than blake2s in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2b: CHashO = /* @__PURE__ */ createOptHasher<BLAKE2b, Blake2Opts>(\n  (opts) => new BLAKE2b(opts)\n);\n\n// =================\n// Blake2S\n// =================\n\n// prettier-ignore\nexport type Num16 = {\n  v0: number; v1: number; v2: number; v3: number;\n  v4: number; v5: number; v6: number; v7: number;\n  v8: number; v9: number; v10: number; v11: number;\n  v12: number; v13: number; v14: number; v15: number;\n};\n\n// prettier-ignore\nexport function compress(s: Uint8Array, offset: number, msg: Uint32Array, rounds: number,\n  v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number,\n  v8: number, v9: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number,\n): Num16 {\n  let j = 0;\n  for (let i = 0; i < rounds; i++) {\n    ({ a: v0, b: v4, c: v8, d: v12 } = G1s(v0, v4, v8, v12, msg[offset + s[j++]]));\n    ({ a: v0, b: v4, c: v8, d: v12 } = G2s(v0, v4, v8, v12, msg[offset + s[j++]]));\n    ({ a: v1, b: v5, c: v9, d: v13 } = G1s(v1, v5, v9, v13, msg[offset + s[j++]]));\n    ({ a: v1, b: v5, c: v9, d: v13 } = G2s(v1, v5, v9, v13, msg[offset + s[j++]]));\n    ({ a: v2, b: v6, c: v10, d: v14 } = G1s(v2, v6, v10, v14, msg[offset + s[j++]]));\n    ({ a: v2, b: v6, c: v10, d: v14 } = G2s(v2, v6, v10, v14, msg[offset + s[j++]]));\n    ({ a: v3, b: v7, c: v11, d: v15 } = G1s(v3, v7, v11, v15, msg[offset + s[j++]]));\n    ({ a: v3, b: v7, c: v11, d: v15 } = G2s(v3, v7, v11, v15, msg[offset + s[j++]]));\n\n    ({ a: v0, b: v5, c: v10, d: v15 } = G1s(v0, v5, v10, v15, msg[offset + s[j++]]));\n    ({ a: v0, b: v5, c: v10, d: v15 } = G2s(v0, v5, v10, v15, msg[offset + s[j++]]));\n    ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset + s[j++]]));\n    ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset + s[j++]]));\n    ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset + s[j++]]));\n    ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset + s[j++]]));\n    ({ a: v3, b: v4, c: v9, d: v14 } = G1s(v3, v4, v9, v14, msg[offset + s[j++]]));\n    ({ a: v3, b: v4, c: v9, d: v14 } = G2s(v3, v4, v9, v14, msg[offset + s[j++]]));\n  }\n  return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };\n}\n\nconst B2S_IV = SHA256_IV;\nexport class BLAKE2s extends BLAKE2<BLAKE2s> {\n  // Internal state, same as SHA-256\n  private v0 = B2S_IV[0] | 0;\n  private v1 = B2S_IV[1] | 0;\n  private v2 = B2S_IV[2] | 0;\n  private v3 = B2S_IV[3] | 0;\n  private v4 = B2S_IV[4] | 0;\n  private v5 = B2S_IV[5] | 0;\n  private v6 = B2S_IV[6] | 0;\n  private v7 = B2S_IV[7] | 0;\n\n  constructor(opts: Blake2Opts = {}) {\n    const olen = opts.dkLen === undefined ? 32 : opts.dkLen;\n    super(64, olen);\n    checkBlake2Opts(olen, opts, 32, 8, 8);\n    let { key, personalization, salt } = opts;\n    let keyLength = 0;\n    if (key !== undefined) {\n      key = toBytes(key);\n      keyLength = key.length;\n    }\n    this.v0 ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n    if (salt !== undefined) {\n      salt = toBytes(salt);\n      const slt = u32(salt as Uint8Array);\n      this.v4 ^= swap8IfBE(slt[0]);\n      this.v5 ^= swap8IfBE(slt[1]);\n    }\n    if (personalization !== undefined) {\n      personalization = toBytes(personalization);\n      const pers = u32(personalization as Uint8Array);\n      this.v6 ^= swap8IfBE(pers[0]);\n      this.v7 ^= swap8IfBE(pers[1]);\n    }\n    if (key !== undefined) {\n      // Pad to blockLen and update\n      abytes(key);\n      const tmp = new Uint8Array(this.blockLen);\n      tmp.set(key);\n      this.update(tmp);\n    }\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;\n    return [v0, v1, v2, v3, v4, v5, v6, v7];\n  }\n  // prettier-ignore\n  protected set(\n    v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number\n  ): void {\n    this.v0 = v0 | 0;\n    this.v1 = v1 | 0;\n    this.v2 = v2 | 0;\n    this.v3 = v3 | 0;\n    this.v4 = v4 | 0;\n    this.v5 = v5 | 0;\n    this.v6 = v6 | 0;\n    this.v7 = v7 | 0;\n  }\n  protected compress(msg: Uint32Array, offset: number, isLast: boolean): void {\n    const { h, l } = u64.fromBig(BigInt(this.length));\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        BSIGMA, offset, msg, 10,\n        this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7,\n        B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l ^ B2S_IV[4], h ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]\n      );\n    this.v0 ^= v0 ^ v8;\n    this.v1 ^= v1 ^ v9;\n    this.v2 ^= v2 ^ v10;\n    this.v3 ^= v3 ^ v11;\n    this.v4 ^= v4 ^ v12;\n    this.v5 ^= v5 ^ v13;\n    this.v6 ^= v6 ^ v14;\n    this.v7 ^= v7 ^ v15;\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer32);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * Blake2s hash function. Focuses on 8-bit to 32-bit platforms. 1.5x faster than blake2b in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2s: CHashO = /* @__PURE__ */ createOptHasher<BLAKE2s, Blake2Opts>(\n  (opts) => new BLAKE2s(opts)\n);\n", "/**\n * Blake3 fast hash is Blake2 with reduced security (round count). Can also be used as MAC & KDF.\n *\n * It is advertised as \"the fastest cryptographic hash\". However, it isn't true in JS.\n * Why is this so slow? While it should be 6x faster than blake2b, perf diff is only 20%:\n *\n * * There is only 30% reduction in number of rounds from blake2s\n * * Speed-up comes from tree structure, which is parallelized using SIMD & threading.\n *   These features are not present in JS, so we only get overhead from trees.\n * * Parallelization only happens on 1024-byte chunks: there is no benefit for small inputs.\n * * It is still possible to make it faster using: a) loop unrolling b) web workers c) wasm\n * @module\n */\nimport { SHA256_IV } from './_md.ts';\nimport { fromBig } from './_u64.ts';\nimport { BLAKE2, compress } from './blake2.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createXOFer, swap32IfBE, toBytes, u32, u8,\n  type CHashXO, type HashXOF, type Input\n} from './utils.ts';\n\n// Flag bitset\nconst B3_Flags = {\n  CHUNK_START: 0b1,\n  CHUNK_END: 0b10,\n  PARENT: 0b100,\n  ROOT: 0b1000,\n  KEYED_HASH: 0b10000,\n  DERIVE_KEY_CONTEXT: 0b100000,\n  DERIVE_KEY_MATERIAL: 0b1000000,\n} as const;\n\nconst B3_IV = SHA256_IV.slice();\n\nconst B3_SIGMA: Uint8Array = /* @__PURE__ */ (() => {\n  const Id = Array.from({ length: 16 }, (_, i) => i);\n  const permute = (arr: number[]) =>\n    [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr[i]);\n  const res: number[] = [];\n  for (let i = 0, v = Id; i < 7; i++, v = permute(v)) res.push(...v);\n  return Uint8Array.from(res);\n})();\n\n/**\n * Ensure to use EITHER `key` OR `context`, not both.\n *\n * * `key`: 32-byte MAC key.\n * * `context`: string for KDF. Should be hardcoded, globally unique, and application - specific.\n *   A good default format for the context string is \"[application] [commit timestamp] [purpose]\".\n */\nexport type Blake3Opts = { dkLen?: number; key?: Input; context?: Input };\n\n/** Blake3 hash. Can be used as MAC and KDF. */\nexport class BLAKE3 extends BLAKE2<BLAKE3> implements HashXOF<BLAKE3> {\n  private chunkPos = 0; // Position of current block in chunk\n  private chunksDone = 0; // How many chunks we already have\n  private flags = 0 | 0;\n  private IV: Uint32Array;\n  private state: Uint32Array;\n  private stack: Uint32Array[] = [];\n  // Output\n  private posOut = 0;\n  private bufferOut32 = new Uint32Array(16);\n  private bufferOut: Uint8Array;\n  private chunkOut = 0; // index of output chunk\n  private enableXOF = true;\n\n  constructor(opts: Blake3Opts = {}, flags = 0) {\n    super(64, opts.dkLen === undefined ? 32 : opts.dkLen);\n    const { key, context } = opts;\n    const hasContext = context !== undefined;\n    if (key !== undefined) {\n      if (hasContext) throw new Error('Only \"key\" or \"context\" can be specified at same time');\n      const k = toBytes(key).slice();\n      abytes(k, 32);\n      this.IV = u32(k);\n      swap32IfBE(this.IV);\n      this.flags = flags | B3_Flags.KEYED_HASH;\n    } else if (hasContext) {\n      const ctx = toBytes(context);\n      const contextKey = new BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT)\n        .update(ctx)\n        .digest();\n      this.IV = u32(contextKey);\n      swap32IfBE(this.IV);\n      this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;\n    } else {\n      this.IV = B3_IV.slice();\n      this.flags = flags;\n    }\n    this.state = this.IV.slice();\n    this.bufferOut = u8(this.bufferOut32);\n  }\n  // Unused\n  protected get(): [] {\n    return [];\n  }\n  protected set(): void {}\n  private b2Compress(counter: number, flags: number, buf: Uint32Array, bufPos: number = 0) {\n    const { state: s, pos } = this;\n    const { h, l } = fromBig(BigInt(counter), true);\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        B3_SIGMA, bufPos, buf, 7,\n        s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],\n        B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h, l, pos, flags\n      );\n    s[0] = v0 ^ v8;\n    s[1] = v1 ^ v9;\n    s[2] = v2 ^ v10;\n    s[3] = v3 ^ v11;\n    s[4] = v4 ^ v12;\n    s[5] = v5 ^ v13;\n    s[6] = v6 ^ v14;\n    s[7] = v7 ^ v15;\n  }\n  protected compress(buf: Uint32Array, bufPos: number = 0, isLast: boolean = false): void {\n    // Compress last block\n    let flags = this.flags;\n    if (!this.chunkPos) flags |= B3_Flags.CHUNK_START;\n    if (this.chunkPos === 15 || isLast) flags |= B3_Flags.CHUNK_END;\n    if (!isLast) this.pos = this.blockLen;\n    this.b2Compress(this.chunksDone, flags, buf, bufPos);\n    this.chunkPos += 1;\n    // If current block is last in chunk (16 blocks), then compress chunks\n    if (this.chunkPos === 16 || isLast) {\n      let chunk = this.state;\n      this.state = this.IV.slice();\n      // If not the last one, compress only when there are trailing zeros in chunk counter\n      // chunks used as binary tree where current stack is path. Zero means current leaf is finished and can be compressed.\n      // 1 (001) - leaf not finished (just push current chunk to stack)\n      // 2 (010) - leaf finished at depth=1 (merge with last elm on stack and push back)\n      // 3 (011) - last leaf not finished\n      // 4 (100) - leafs finished at depth=1 and depth=2\n      for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {\n        if (!(last = this.stack.pop())) break;\n        this.buffer32.set(last, 0);\n        this.buffer32.set(chunk, 8);\n        this.pos = this.blockLen;\n        this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);\n        chunk = this.state;\n        this.state = this.IV.slice();\n      }\n      this.chunksDone++;\n      this.chunkPos = 0;\n      this.stack.push(chunk);\n    }\n    this.pos = 0;\n  }\n  _cloneInto(to?: BLAKE3): BLAKE3 {\n    to = super._cloneInto(to) as BLAKE3;\n    const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;\n    to.state.set(state.slice());\n    to.stack = stack.map((i) => Uint32Array.from(i));\n    to.IV.set(IV);\n    to.flags = flags;\n    to.chunkPos = chunkPos;\n    to.chunksDone = chunksDone;\n    to.posOut = posOut;\n    to.chunkOut = chunkOut;\n    to.enableXOF = this.enableXOF;\n    to.bufferOut32.set(this.bufferOut32);\n    return to;\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.state, this.buffer32, this.IV, this.bufferOut32);\n    clean(...this.stack);\n  }\n  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)\n  private b2CompressOut() {\n    const { state: s, pos, flags, buffer32, bufferOut32: out32 } = this;\n    const { h, l } = fromBig(BigInt(this.chunkOut++));\n    swap32IfBE(buffer32);\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        B3_SIGMA, 0, buffer32, 7,\n        s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],\n        B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l, h, pos, flags\n      );\n    out32[0] = v0 ^ v8;\n    out32[1] = v1 ^ v9;\n    out32[2] = v2 ^ v10;\n    out32[3] = v3 ^ v11;\n    out32[4] = v4 ^ v12;\n    out32[5] = v5 ^ v13;\n    out32[6] = v6 ^ v14;\n    out32[7] = v7 ^ v15;\n    out32[8] = s[0] ^ v8;\n    out32[9] = s[1] ^ v9;\n    out32[10] = s[2] ^ v10;\n    out32[11] = s[3] ^ v11;\n    out32[12] = s[4] ^ v12;\n    out32[13] = s[5] ^ v13;\n    out32[14] = s[6] ^ v14;\n    out32[15] = s[7] ^ v15;\n    swap32IfBE(buffer32);\n    swap32IfBE(out32);\n    this.posOut = 0;\n  }\n  protected finish(): void {\n    if (this.finished) return;\n    this.finished = true;\n    // Padding\n    clean(this.buffer.subarray(this.pos));\n    // Process last chunk\n    let flags = this.flags | B3_Flags.ROOT;\n    if (this.stack.length) {\n      flags |= B3_Flags.PARENT;\n      swap32IfBE(this.buffer32);\n      this.compress(this.buffer32, 0, true);\n      swap32IfBE(this.buffer32);\n      this.chunksDone = 0;\n      this.pos = this.blockLen;\n    } else {\n      flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;\n    }\n    this.flags = flags;\n    this.b2CompressOut();\n  }\n  private writeInto(out: Uint8Array) {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const { blockLen, bufferOut } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.b2CompressOut();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    if (!this.enableXOF) throw new Error('XOF is not possible after digest call');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.enableXOF = false;\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest(): Uint8Array {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n}\n\n/**\n * BLAKE3 hash function. Can be used as MAC and KDF.\n * @param msg - message that would be hashed\n * @param opts - `dkLen` for output length, `key` for MAC mode, `context` for KDF mode\n * @example\n * const data = new Uint8Array(32);\n * const hash = blake3(data);\n * const mac = blake3(data, { key: new Uint8Array(32) });\n * const kdf = blake3(data, { context: 'application name' });\n */\nexport const blake3: CHashXO = /* @__PURE__ */ createXOFer<BLAKE3, Blake3Opts>(\n  (opts) => new BLAKE3(opts)\n);\n", "import * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as Cursor from './internal/cursor.js'\nimport type { Compute, Mutable, OneOf, UnionCompute } from './internal/types.js'\nimport * as Kzg from './Kzg.js'\n\n/** Blob limit per transaction. */\nconst blobsPerTransaction = 6\n\n/** The number of bytes in a BLS scalar field element. */\nexport const bytesPerFieldElement = 32\n\n/** The number of field elements in a blob. */\nexport const fieldElementsPerBlob = 4096\n\n/** The number of bytes in a blob. */\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob\n\n/** Blob bytes limit per transaction. */\nexport const maxBytesPerTransaction =\n  bytesPerBlob * blobsPerTransaction -\n  // terminator byte (0x80).\n  1 -\n  // zero byte (0x00) appended to each field element.\n  1 * fieldElementsPerBlob * blobsPerTransaction\n\n/** Root type for a Blob. */\nexport type Blob<type extends Hex.Hex | Bytes.Bytes = Hex.Hex | Bytes.Bytes> =\n  type\n\n/** A list of {@link ox#Blobs.Blob}. */\nexport type Blobs<type extends Hex.Hex | Bytes.Bytes = Hex.Hex | Bytes.Bytes> =\n  readonly Blob<type>[]\n\n/** Type for a Blob Sidecar that contains a blob, as well as its KZG commitment and proof. */\nexport type BlobSidecar<\n  type extends Hex.Hex | Bytes.Bytes = Hex.Hex | Bytes.Bytes,\n> = Compute<{\n  /** The blob associated with the transaction. */\n  blob: type\n  /** The KZG commitment corresponding to this blob. */\n  commitment: type\n  /** The KZG proof corresponding to this blob and commitment. */\n  proof: type\n}>\n\n/**\n * Transform a list of Commitments to Blob Versioned Hashes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments) // [!code focus]\n * // @log: ['0x...', '0x...']\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hashes with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hashes with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param commitments - A list of commitments.\n * @param options - Options.\n * @returns A list of Blob Versioned Hashes.\n */\nexport function commitmentsToVersionedHashes<\n  const commitments extends readonly Bytes.Bytes[] | readonly Hex.Hex[],\n  as extends 'Hex' | 'Bytes' =\n    | (commitments extends readonly Hex.Hex[] ? 'Hex' : never)\n    | (commitments extends readonly Bytes.Bytes[] ? 'Bytes' : never),\n>(\n  commitments: commitments | readonly Bytes.Bytes[] | readonly Hex.Hex[],\n  options: commitmentsToVersionedHashes.Options<as> = {},\n): commitmentsToVersionedHashes.ReturnType<as> {\n  const { version } = options\n\n  const as =\n    options.as ?? (typeof commitments[0] === 'string' ? 'Hex' : 'Bytes')\n\n  const hashes: Uint8Array[] | Hex.Hex[] = []\n  for (const commitment of commitments) {\n    hashes.push(\n      commitmentToVersionedHash(commitment, {\n        as,\n        version,\n      }) as never,\n    )\n  }\n  return hashes as never\n}\n\nexport declare namespace commitmentsToVersionedHashes {\n  type Options<as extends 'Hex' | 'Bytes' | undefined = undefined> = {\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /** Version to tag onto the hashes. */\n    version?: number | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Transform a Commitment to its Blob Versioned Hash.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHash = Blobs.commitmentToVersionedHash(commitment) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hash with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentToVersionedHash(commitment, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hash with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentToVersionedHash(commitment, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param commitment - The commitment.\n * @param options - Options.\n * @returns The Blob Versioned Hash.\n */\nexport function commitmentToVersionedHash<\n  const commitment extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (commitment extends Hex.Hex ? 'Hex' : never)\n    | (commitment extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  commitment: commitment | Hex.Hex | Bytes.Bytes,\n  options: commitmentToVersionedHash.Options<as> = {},\n): commitmentToVersionedHash.ReturnType<as> {\n  const { version = 1 } = options\n  const as = options.as ?? (typeof commitment === 'string' ? 'Hex' : 'Bytes')\n\n  const versionedHash = Hash.sha256(commitment, { as: 'Bytes' })\n  versionedHash.set([version], 0)\n  return (\n    as === 'Bytes' ? versionedHash : Hex.fromBytes(versionedHash)\n  ) as commitmentToVersionedHash.ReturnType<as>\n}\n\nexport declare namespace commitmentToVersionedHash {\n  type Options<as extends 'Hex' | 'Bytes' | undefined = undefined> = {\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /** Version to tag onto the hash. */\n    version?: number | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Transforms arbitrary data to {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * ```\n *\n * @example\n * ### Creating Blobs from a String\n *\n * An example of creating Blobs from a string using  {@link ox#Hex.(from:function)}:\n *\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from(Hex.fromString('Hello world!'))\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Blobs with the `as` option.\n *\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef', { as: 'Bytes' })\n * //    ^?\n *\n *\n * ```\n *\n * @param data - The data to convert to {@link ox#Blobs.Blobs}.\n * @param options - Options.\n * @returns The {@link ox#Blobs.Blobs}.\n */\nexport function from<\n  const data extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (data extends Hex.Hex ? 'Hex' : never)\n    | (data extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  data: data | Hex.Hex | Bytes.Bytes,\n  options: from.Options<as> = {},\n): from.ReturnType<as> {\n  const as = options.as ?? (typeof data === 'string' ? 'Hex' : 'Bytes')\n  const data_ = (\n    typeof data === 'string' ? Bytes.fromHex(data) : data\n  ) as Bytes.Bytes\n\n  const size_ = Bytes.size(data_)\n  if (!size_) throw new EmptyBlobError()\n  if (size_ > maxBytesPerTransaction)\n    throw new BlobSizeTooLargeError({\n      maxSize: maxBytesPerTransaction,\n      size: size_,\n    })\n\n  const blobs = []\n\n  let active = true\n  let position = 0\n  while (active) {\n    const blob = Cursor.create(new Uint8Array(bytesPerBlob))\n\n    let size = 0\n    while (size < fieldElementsPerBlob) {\n      const bytes = data_.slice(position, position + (bytesPerFieldElement - 1))\n\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00)\n\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes)\n\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80)\n        active = false\n        break\n      }\n\n      size++\n      position += 31\n    }\n\n    blobs.push(blob)\n  }\n\n  return (\n    as === 'Bytes'\n      ? blobs.map((x) => x.bytes)\n      : blobs.map((x) => Hex.fromBytes(x.bytes))\n  ) as never\n}\n\nexport declare namespace from {\n  type Options<as extends 'Hex' | 'Bytes' | undefined = undefined> = {\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n\n  type ErrorType =\n    | BlobSizeTooLargeError\n    | EmptyBlobError\n    | Bytes.fromHex.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Cursor.create.ErrorType\n    | Bytes.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Transforms a list of {@link ox#Blobs.BlobSidecars} to their Blob Versioned Hashes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hashes with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hashes with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param sidecars - The {@link ox#Blobs.BlobSidecars} to transform to Blob Versioned Hashes.\n * @param options - Options.\n * @returns The versioned hashes.\n */\nexport function sidecarsToVersionedHashes<\n  const sidecars extends BlobSidecars,\n  as extends 'Hex' | 'Bytes' =\n    | (sidecars extends BlobSidecars<Hex.Hex> ? 'Hex' : never)\n    | (sidecars extends BlobSidecars<Bytes.Bytes> ? 'Bytes' : never),\n>(\n  sidecars: sidecars | BlobSidecars,\n  options: sidecarsToVersionedHashes.Options<as> = {},\n): sidecarsToVersionedHashes.ReturnType<as> {\n  const { version } = options\n\n  const as =\n    options.as ?? (typeof sidecars[0]!.blob === 'string' ? 'Hex' : 'Bytes')\n\n  const hashes: Uint8Array[] | Hex.Hex[] = []\n  for (const { commitment } of sidecars) {\n    hashes.push(\n      commitmentToVersionedHash(commitment, {\n        as,\n        version,\n      }) as any,\n    )\n  }\n  return hashes as any\n}\n\nexport declare namespace sidecarsToVersionedHashes {\n  type Options<as extends 'Hex' | 'Bytes' | undefined = undefined> = {\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /** Version to tag onto the hashes. */\n    version?: number | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n\n  type ErrorType = commitmentToVersionedHash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.to(blobs) // [!code focus]\n * // @log: '0xdeadbeef'\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type with second argument.\n *\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.to(blobs, 'Bytes')\n * // @log: Uint8Array [ 13, 174, 190, 239 ]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform.\n * @param to - The type to transform to.\n * @returns The originating data.\n */\nexport function to<\n  const blobs extends Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n  to extends 'Hex' | 'Bytes' =\n    | (blobs extends Blobs<Hex.Hex> ? 'Hex' : never)\n    | (blobs extends Blobs<Bytes.Bytes> ? 'Bytes' : never),\n>(\n  blobs: blobs | Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n  to?: to | 'Hex' | 'Bytes' | undefined,\n): to.ReturnType<to> {\n  const to_ = to ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes')\n  const blobs_ = (\n    typeof blobs[0] === 'string'\n      ? blobs.map((x) => Bytes.fromHex(x as Hex.Hex))\n      : blobs\n  ) as Bytes.Bytes[]\n\n  const length = blobs_.reduce((length, blob) => length + blob.length, 0)\n  const data = Cursor.create(new Uint8Array(length))\n  let active = true\n\n  for (const blob of blobs_) {\n    const cursor = Cursor.create(blob)\n    while (active && cursor.position < blob.length) {\n      // First byte will be a zero 0x00 byte – we can skip.\n      cursor.incrementPosition(1)\n\n      let consume = 31\n      if (blob.length - cursor.position < 31)\n        consume = blob.length - cursor.position\n\n      for (const _ in Array.from({ length: consume })) {\n        const byte = cursor.readByte()\n        const isTerminator =\n          byte === 0x80 && !cursor.inspectBytes(cursor.remaining).includes(0x80)\n        if (isTerminator) {\n          active = false\n          break\n        }\n        data.pushByte(byte)\n      }\n    }\n  }\n\n  const trimmedData = data.bytes.slice(0, data.position)\n  return (to_ === 'Hex' ? Hex.fromBytes(trimmedData) : trimmedData) as never\n}\n\nexport declare namespace to {\n  type ReturnType<to extends 'Hex' | 'Bytes' = 'Hex'> =\n    | (to extends 'Bytes' ? Bytes.Bytes : never)\n    | (to extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Cursor.create.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.toHex(blobs) // [!code focus]\n * // @log: '0xdeadbeef'\n * ```\n */\nexport function toHex(\n  blobs: Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n): toHex.ReturnType {\n  return to(blobs, 'Hex')\n}\n\nexport declare namespace toHex {\n  type ReturnType = to.ReturnType<'Hex'>\n  type ErrorType = to.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.toBytes(blobs) // [!code focus]\n * // @log: Uint8Array [ 13, 174, 190, 239 ]\n * ```\n */\nexport function toBytes(\n  blobs: Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n): toBytes.ReturnType {\n  return to(blobs, 'Bytes')\n}\n\n/**\n * Compute commitments from a list of {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, {\n *   as: 'Bytes', // [!code focus]\n *   kzg,\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform to commitments.\n * @param options - Options.\n * @returns The commitments.\n */\nexport function toCommitments<\n  const blobs extends Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  as extends 'Hex' | 'Bytes' =\n    | (blobs extends Blobs<Hex.Hex> ? 'Hex' : never)\n    | (blobs extends Blobs<Bytes.Bytes> ? 'Bytes' : never),\n>(\n  blobs: blobs | Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  options: toCommitments.Options<as>,\n): toCommitments.ReturnType<as> {\n  const { kzg } = options\n\n  const as = options.as ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes')\n  const blobs_ = (\n    typeof blobs[0] === 'string'\n      ? blobs.map((x) => Bytes.fromHex(x as any))\n      : blobs\n  ) as Bytes.Bytes[]\n\n  const commitments: Bytes.Bytes[] = []\n  for (const blob of blobs_)\n    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)))\n\n  return (\n    as === 'Bytes' ? commitments : commitments.map((x) => Hex.fromBytes(x))\n  ) as never\n}\n\nexport declare namespace toCommitments {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /** KZG implementation. */\n    kzg: Pick<Kzg.Kzg, 'blobToKzgCommitment'>\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> = Compute<\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n  >\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\nexport declare namespace toBytes {\n  type ReturnType = to.ReturnType<'Bytes'>\n  type ErrorType = to.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Compute the proofs for a list of {@link ox#Blobs.Blobs} and their commitments.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const proofs = Blobs.toProofs(blobs, { commitments, kzg }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to compute proofs for.\n * @param options - Options.\n * @returns The Blob proofs.\n */\nexport function toProofs<\n  const blobs extends readonly Bytes.Bytes[] | readonly Hex.Hex[],\n  const commitments extends readonly Bytes.Bytes[] | readonly Hex.Hex[],\n  as extends 'Hex' | 'Bytes' =\n    | (blobs extends readonly Hex.Hex[] ? 'Hex' : never)\n    | (blobs extends readonly Bytes.Bytes[] ? 'Bytes' : never),\n>(\n  blobs: blobs | Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  options: toProofs.Options<blobs, commitments, as>,\n): toProofs.ReturnType<as> {\n  const { kzg } = options\n\n  const as = options.as ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes')\n\n  const blobs_ = (\n    typeof blobs[0] === 'string'\n      ? blobs.map((x) => Bytes.fromHex(x as any))\n      : blobs\n  ) as Bytes.Bytes[]\n  const commitments = (\n    typeof options.commitments[0] === 'string'\n      ? options.commitments.map((x) => Bytes.fromHex(x as any))\n      : options.commitments\n  ) as Bytes.Bytes[]\n\n  const proofs: Bytes.Bytes[] = []\n  for (let i = 0; i < blobs_.length; i++) {\n    const blob = blobs_[i]!\n    const commitment = commitments[i]!\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)))\n  }\n\n  return (\n    as === 'Bytes' ? proofs : proofs.map((x) => Hex.fromBytes(x))\n  ) as never\n}\n\nexport declare namespace toProofs {\n  type Options<\n    blobs extends Blobs<Bytes.Bytes> | Blobs<Hex.Hex> =\n      | Blobs<Bytes.Bytes>\n      | Blobs<Hex.Hex>,\n    commitments extends readonly Bytes.Bytes[] | readonly Hex.Hex[] =\n      | readonly Bytes.Bytes[]\n      | readonly Hex.Hex[],\n    as extends 'Hex' | 'Bytes' =\n      | (blobs extends Blobs<Hex.Hex> ? 'Hex' : never)\n      | (blobs extends Blobs<Bytes.Bytes> ? 'Bytes' : never),\n  > = {\n    /** Commitments for the blobs. */\n    commitments: (commitments | readonly Bytes.Bytes[] | readonly Hex.Hex[]) &\n      (commitments extends blobs\n        ? {}\n        : `commitments must be the same type as blobs`)\n    /** KZG implementation. */\n    kzg: Pick<Kzg.Kzg, 'computeBlobKzgProof'>\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Transforms {@link ox#Blobs.Blobs} into a {@link ox#Blobs.BlobSidecars} array.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @example\n * You can also provide your own commitments and proofs if you do not want `toSidecars`\n * to compute them.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const proofs = Blobs.toProofs(blobs, { commitments, kzg })\n *\n * const sidecars = Blobs.toSidecars(blobs, { commitments, kzg, proofs }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform into {@link ox#Blobs.BlobSidecars}.\n * @param options - Options.\n * @returns The {@link ox#Blobs.BlobSidecars}.\n */\nexport function toSidecars<\n  const blobs extends Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n>(\n  blobs: blobs,\n  options: toSidecars.Options<blobs>,\n): toSidecars.ReturnType<blobs> {\n  const { kzg } = options\n\n  const commitments = options.commitments ?? toCommitments(blobs, { kzg: kzg! })\n  const proofs =\n    options.proofs ??\n    toProofs(blobs, { commitments: commitments as any, kzg: kzg! })\n\n  const sidecars: Mutable<BlobSidecars> = []\n  for (let i = 0; i < blobs.length; i++)\n    sidecars.push({\n      blob: blobs[i]!,\n      commitment: commitments[i]!,\n      proof: proofs[i]!,\n    })\n\n  return sidecars as never\n}\n\nexport declare namespace toSidecars {\n  type Options<\n    blobs extends Blobs<Hex.Hex> | Blobs<Bytes.Bytes> =\n      | Blobs<Hex.Hex>\n      | Blobs<Bytes.Bytes>,\n  > = {\n    kzg?: Kzg.Kzg | undefined\n  } & OneOf<\n    | {}\n    | {\n        /** Commitment for each blob. */\n        commitments: blobs | readonly Hex.Hex[] | readonly Bytes.Bytes[]\n        /** Proof for each blob. */\n        proofs: blobs | readonly Hex.Hex[] | readonly Bytes.Bytes[]\n      }\n  >\n\n  type ReturnType<blobs extends Blobs<Hex.Hex> | Blobs<Bytes.Bytes>> =\n    UnionCompute<\n      | (blobs extends Blobs<Hex.Hex> ? BlobSidecars<Hex.Hex> : never)\n      | (blobs extends Blobs<Bytes.Bytes> ? BlobSidecars<Bytes.Bytes> : never)\n    >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Compute Blob Versioned Hashes from a list of {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const versionedHashes = Blobs.toVersionedHashes(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform into Blob Versioned Hashes.\n * @param options - Options.\n * @returns The Blob Versioned Hashes.\n */\nexport function toVersionedHashes<\n  const blobs extends Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  as extends 'Hex' | 'Bytes' =\n    | (blobs extends Blobs<Hex.Hex> ? 'Hex' : never)\n    | (blobs extends Blobs<Bytes.Bytes> ? 'Bytes' : never),\n>(\n  blobs: blobs | Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  options: toVersionedHashes.Options<as>,\n): toVersionedHashes.ReturnType<as> {\n  const commitments = toCommitments(blobs, options)\n  return commitmentsToVersionedHashes(commitments, options)\n}\n\nexport declare namespace toVersionedHashes {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /** KZG implementation. */\n    kzg: Pick<Kzg.Kzg, 'blobToKzgCommitment'>\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> = Compute<\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n  >\n\n  type ErrorType =\n    | toCommitments.ErrorType\n    | commitmentsToVersionedHashes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** A list of {@link ox#Blobs.BlobSidecar}. */\nexport type BlobSidecars<\n  type extends Hex.Hex | Bytes.Bytes = Hex.Hex | Bytes.Bytes,\n> = readonly Compute<BlobSidecar<type>>[]\n\n/** Thrown when the blob size is too large. */\nexport class BlobSizeTooLargeError extends Errors.BaseError {\n  override readonly name = 'Blobs.BlobSizeTooLargeError'\n  constructor({ maxSize, size }: { maxSize: number; size: number }) {\n    super('Blob size is too large.', {\n      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],\n    })\n  }\n}\n\n/** Thrown when the blob is empty. */\nexport class EmptyBlobError extends Errors.BaseError {\n  override readonly name = 'Blobs.EmptyBlobError'\n  constructor() {\n    super('Blob data must not be empty.')\n  }\n}\n\n/** Thrown when the blob versioned hashes are empty. */\nexport class EmptyBlobVersionedHashesError extends Errors.BaseError {\n  override readonly name = 'Blobs.EmptyBlobVersionedHashesError'\n  constructor() {\n    super('Blob versioned hashes must not be empty.')\n  }\n}\n\n/** Thrown when the blob versioned hash size is invalid. */\nexport class InvalidVersionedHashSizeError extends Errors.BaseError {\n  override readonly name = 'Blobs.InvalidVersionedHashSizeError'\n  constructor({\n    hash,\n    size,\n  }: {\n    hash: Hex.Hex\n    size: number\n  }) {\n    super(`Versioned hash \"${hash}\" size is invalid.`, {\n      metaMessages: ['Expected: 32', `Received: ${size}`],\n    })\n  }\n}\n\n/** Thrown when the blob versioned hash version is invalid. */\nexport class InvalidVersionedHashVersionError extends Errors.BaseError {\n  override readonly name = 'Blobs.InvalidVersionedHashVersionError'\n  constructor({\n    hash,\n    version,\n  }: {\n    hash: Hex.Hex\n    version: number\n  }) {\n    super(`Versioned hash \"${hash}\" version is invalid.`, {\n      metaMessages: [\n        `Expected: ${Kzg.versionedHashVersion}`,\n        `Received: ${version}`,\n      ],\n    })\n  }\n}\n", "import type * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\n\n/** @see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters */\nexport const versionedHashVersion = 1\n\n/** Root type for a KZG interface. */\nexport type Kzg = {\n  /**\n   * Convert a blob to a KZG commitment.\n   */\n  blobToKzgCommitment(blob: Bytes.Bytes): Bytes.Bytes\n  /**\n   * Given a blob, return the KZG proof that is used to verify it against the\n   * commitment.\n   */\n  computeBlobKzgProof(blob: Bytes.Bytes, commitment: Bytes.Bytes): Bytes.Bytes\n}\n\n/**\n * Defines a KZG interface.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import * as cKzg from 'c-kzg'\n * import { Kzg } from 'ox'\n * import { Paths } from 'ox/trusted-setups'\n *\n * cKzg.loadTrustedSetup(Paths.mainnet)\n *\n * const kzg = Kzg.from(cKzg)\n * ```\n *\n * @param value - The KZG object to convert.\n * @returns The KZG interface object.\n */\nexport function from(value: Kzg): Kzg {\n  const { blobToKzgCommitment, computeBlobKzgProof } = value\n  return {\n    blobToKzgCommitment,\n    computeBlobKzgProof,\n  }\n}\n\nexport declare namespace from {\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import type * as Address from './Address.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, OneOf } from './internal/types.js'\nimport * as Transaction from './Transaction.js'\nimport * as Withdrawal from './Withdrawal.js'\n\n/** A Block as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/block.yaml). */\nexport type Block<\n  includeTransactions extends boolean = false,\n  blockTag extends Tag = 'latest',\n  bigintType = bigint,\n  numberType = number,\n  transaction = Transaction.Transaction<\n    blockTag extends 'pending' ? true : false,\n    bigintType,\n    numberType\n  >,\n> = Compute<{\n  /** Base fee per gas */\n  baseFeePerGas?: bigintType | undefined\n  /** Total used blob gas by all transactions in this block */\n  blobGasUsed?: bigintType | undefined\n  /** Difficulty for this block */\n  difficulty?: bigintType | undefined\n  /** Excess blob gas */\n  excessBlobGas?: bigintType | undefined\n  /** \"Extra data\" field of this block */\n  extraData?: Hex.Hex | undefined\n  /** Maximum gas allowed in this block */\n  gasLimit: bigintType\n  /** Total used gas by all transactions in this block */\n  gasUsed: bigintType\n  /** Block hash or `null` if pending */\n  hash: blockTag extends 'pending' ? null : Hex.Hex\n  /** Logs bloom filter or `null` if pending */\n  logsBloom: blockTag extends 'pending' ? null : Hex.Hex\n  /** Address that received this block’s mining rewards */\n  miner: Address.Address\n  /** Unique identifier for the block. */\n  mixHash: Hex.Hex\n  /** Proof-of-work hash or `null` if pending */\n  nonce: blockTag extends 'pending' ? null : Hex.Hex\n  /** Block number or `null` if pending */\n  number: blockTag extends 'pending' ? null : bigintType\n  parentBeaconBlockRoot?: Hex.Hex | undefined\n  /** Parent block hash */\n  parentHash: Hex.Hex\n  /** Root of the this block’s receipts trie */\n  receiptsRoot: Hex.Hex\n  sealFields?: readonly Hex.Hex[] | undefined\n  /** SHA3 of the uncles data in this block */\n  sha3Uncles: Hex.Hex\n  /** Size of this block in bytes */\n  size: bigintType\n  /** Root of this block’s final state trie */\n  stateRoot: Hex.Hex\n  /** Unix timestamp of when this block was collated */\n  timestamp: bigintType\n  /** Total difficulty of the chain until this block */\n  totalDifficulty?: bigintType | undefined\n  /** List of transaction objects or hashes */\n  transactions: includeTransactions extends true\n    ? readonly transaction[]\n    : readonly Hex.Hex[]\n  /** Root of this block’s transaction trie */\n  transactionsRoot: Hex.Hex\n  /** List of uncle hashes */\n  uncles: readonly Hex.Hex[]\n  /** List of withdrawal objects */\n  withdrawals?:\n    | readonly Withdrawal.Withdrawal<bigintType, numberType>[]\n    | undefined\n  /** Root of the this block’s withdrawals trie */\n  withdrawalsRoot?: Hex.Hex | undefined\n}>\n\n/** A Block hash. */\nexport type Hash = Hex.Hex\n\n/** A Block identifier. */\nexport type Identifier<bigintType = bigint> = {\n  /** Whether or not to throw an error if the block is not in the canonical chain as described below. Only allowed in conjunction with the blockHash tag. Defaults to false. */\n  requireCanonical?: boolean | undefined\n} & OneOf<\n  | {\n      /** The block in the canonical chain with this number */\n      blockNumber: Number<bigintType>\n    }\n  | {\n      /** The block uniquely identified by this hash. The `blockNumber` and `blockHash` properties are mutually exclusive; exactly one of them must be set. */\n      blockHash: Hash\n    }\n>\n\n/** A Block number. */\nexport type Number<bigintType = bigint> = bigintType\n\n/** An RPC Block as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/block.yaml). */\nexport type Rpc<\n  includeTransactions extends boolean = boolean,\n  blockTag extends Tag = 'latest',\n  transaction = Transaction.Rpc<blockTag extends 'pending' ? true : false>,\n> = Block<includeTransactions, blockTag, Hex.Hex, Hex.Hex, transaction>\n\n/**\n * A Block Tag as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/block.yaml).\n *\n * - `earliest`: The lowest numbered block the client has available;\n * - `finalized`: The most recent crypto-economically secure block, cannot be re-orged outside of manual intervention driven by community coordination;\n * - `safe`: The most recent block that is safe from re-orgs under honest majority and certain synchronicity assumptions;\n * - `latest`: The most recent block in the canonical chain observed by the client, this block may be re-orged out of the canonical chain even under healthy/normal conditions;\n * - `pending`: A sample next block built by the client on top of `latest` and containing the set of transactions usually taken from local mempool.\n */\nexport type Tag = 'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'\n\n/**\n * Converts a {@link ox#Block.Block} to an {@link ox#Block.Rpc}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Block } from 'ox'\n *\n * const block = Block.toRpc({\n *   // ...\n *   hash: '0xebc3644804e4040c0a74c5a5bbbc6b46a71a5d4010fe0c92ebb2fdf4a43ea5dd',\n *   number: 19868020n,\n *   size: 520n\n *   timestamp: 1662222222n,\n *   // ...\n * })\n * // @log: {\n * // @log:   // ...\n * // @log:   hash: '0xebc3644804e4040c0a74c5a5bbbc6b46a71a5d4010fe0c92ebb2fdf4a43ea5dd',\n * // @log:   number: '0xec6fc6',\n * // @log:   size: '0x208',\n * // @log:   timestamp: '0x63198f6f',\n * // @log:   // ...\n * // @log: }\n * ```\n *\n * @param block - The Block to convert.\n * @returns An RPC Block.\n */\nexport function toRpc<\n  includeTransactions extends boolean = false,\n  blockTag extends Tag = 'latest',\n>(\n  block: Block<includeTransactions, blockTag>,\n  _options: toRpc.Options<includeTransactions, blockTag> = {},\n): Rpc<boolean, blockTag> {\n  const transactions = block.transactions.map((transaction) => {\n    if (typeof transaction === 'string') return transaction\n    return Transaction.toRpc(transaction as any) as any\n  })\n  return {\n    baseFeePerGas:\n      typeof block.baseFeePerGas === 'bigint'\n        ? Hex.fromNumber(block.baseFeePerGas)\n        : undefined,\n    blobGasUsed:\n      typeof block.blobGasUsed === 'bigint'\n        ? Hex.fromNumber(block.blobGasUsed)\n        : undefined,\n    excessBlobGas:\n      typeof block.excessBlobGas === 'bigint'\n        ? Hex.fromNumber(block.excessBlobGas)\n        : undefined,\n    extraData: block.extraData,\n    difficulty:\n      typeof block.difficulty === 'bigint'\n        ? Hex.fromNumber(block.difficulty)\n        : undefined,\n    gasLimit: Hex.fromNumber(block.gasLimit),\n    gasUsed: Hex.fromNumber(block.gasUsed),\n    hash: block.hash,\n    logsBloom: block.logsBloom,\n    miner: block.miner,\n    mixHash: block.mixHash,\n    nonce: block.nonce,\n    number: (typeof block.number === 'bigint'\n      ? Hex.fromNumber(block.number)\n      : null) as never,\n    parentBeaconBlockRoot: block.parentBeaconBlockRoot,\n    parentHash: block.parentHash,\n    receiptsRoot: block.receiptsRoot,\n    sealFields: block.sealFields,\n    sha3Uncles: block.sha3Uncles,\n    size: Hex.fromNumber(block.size),\n    stateRoot: block.stateRoot,\n    timestamp: Hex.fromNumber(block.timestamp),\n    totalDifficulty:\n      typeof block.totalDifficulty === 'bigint'\n        ? Hex.fromNumber(block.totalDifficulty)\n        : undefined,\n    transactions,\n    transactionsRoot: block.transactionsRoot,\n    uncles: block.uncles,\n    withdrawals: block.withdrawals?.map(Withdrawal.toRpc),\n    withdrawalsRoot: block.withdrawalsRoot,\n  }\n}\n\nexport declare namespace toRpc {\n  type Options<\n    includeTransactions extends boolean = false,\n    blockTag extends Tag = 'latest',\n  > = {\n    blockTag?: blockTag | Tag | undefined\n    includeTransactions?: includeTransactions | boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Block.Rpc} to an {@link ox#Block.Block}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Block } from 'ox'\n *\n * const block = Block.fromRpc({\n *   // ...\n *   hash: '0xebc3644804e4040c0a74c5a5bbbc6b46a71a5d4010fe0c92ebb2fdf4a43ea5dd',\n *   number: '0xec6fc6',\n *   size: '0x208',\n *   timestamp: '0x63198f6f',\n *   // ...\n * })\n * // @log: {\n * // @log:   // ...\n * // @log:   hash: '0xebc3644804e4040c0a74c5a5bbbc6b46a71a5d4010fe0c92ebb2fdf4a43ea5dd',\n * // @log:   number: 19868020n,\n * // @log:   size: 520n,\n * // @log:   timestamp: 1662222222n,\n * // @log:   // ...\n * // @log: }\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `Block.fromRpc` to fetch a block from the network and convert it to an {@link ox#Block.Block}.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Block } from 'ox'\n *\n * const block = await window.ethereum!\n *   .request({\n *     method: 'eth_getBlockByNumber',\n *     params: ['latest', false],\n *   })\n *   .then(Block.fromRpc) // [!code hl]\n * // @log: {\n * // @log:   // ...\n * // @log:   hash: '0xebc3644804e4040c0a74c5a5bbbc6b46a71a5d4010fe0c92ebb2fdf4a43ea5dd',\n * // @log:   number: 19868020n,\n * // @log:   size: 520n,\n * // @log:   timestamp: 1662222222n,\n * // @log:   // ...\n * // @log: }\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param block - The RPC block to convert.\n * @returns An instantiated {@link ox#Block.Block}.\n */\nexport function fromRpc<\n  const block extends Rpc | null,\n  includeTransactions extends boolean = false,\n  blockTag extends Tag = 'latest',\n>(\n  block: block | Rpc | null,\n  _options: fromRpc.Options<includeTransactions, blockTag> = {},\n): block extends Rpc ? Block<includeTransactions, blockTag> : null {\n  if (!block) return null as never\n\n  const transactions = block.transactions.map((transaction) => {\n    if (typeof transaction === 'string') return transaction\n    return Transaction.fromRpc(transaction) as any\n  })\n  return {\n    ...block,\n    baseFeePerGas: block.baseFeePerGas\n      ? BigInt(block.baseFeePerGas)\n      : undefined,\n    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,\n    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,\n    excessBlobGas: block.excessBlobGas\n      ? BigInt(block.excessBlobGas)\n      : undefined,\n    gasLimit: BigInt(block.gasLimit ?? 0n),\n    gasUsed: BigInt(block.gasUsed ?? 0n),\n    number: block.number ? BigInt(block.number) : null,\n    size: BigInt(block.size ?? 0n),\n    stateRoot: block.stateRoot,\n    timestamp: BigInt(block.timestamp ?? 0n),\n    totalDifficulty: BigInt(block.totalDifficulty ?? 0n),\n    transactions,\n    withdrawals: block.withdrawals?.map(Withdrawal.fromRpc),\n  } as Block as never\n}\n\nexport declare namespace fromRpc {\n  type Options<\n    includeTransactions extends boolean = false,\n    blockTag extends Tag = 'latest',\n  > = {\n    blockTag?: blockTag | Tag | undefined\n    includeTransactions?: includeTransactions | boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\n\n/**\n * Checks if an input is matched in the bloom filter.\n *\n * @example\n * ```ts twoslash\n * import { Bloom } from 'ox'\n *\n * Bloom.contains(\n *   '0x00000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002020000000000000000000000000000000000000000000008000000001000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',\n *   '0xef2d6d194084c2de36e0dabfce45d046b37d1106',\n * )\n * // @log: true\n * ```\n *\n * @param bloom - Bloom filter value.\n * @param input - Input to check.\n * @returns Whether the input is matched in the bloom filter.\n */\nexport function contains(\n  bloom: Hex.Hex,\n  input: Hex.Hex | Bytes.Bytes,\n): boolean {\n  const filter = Bytes.fromHex(bloom)\n  const hash = Hash.keccak256(input, { as: 'Bytes' })\n\n  for (const i of [0, 2, 4]) {\n    const bit = (hash[i + 1]! + (hash[i]! << 8)) & 0x7ff\n    if ((filter[256 - 1 - Math.floor(bit / 8)]! & (1 << (bit % 8))) === 0)\n      return false\n  }\n\n  return true\n}\n\nexport declare namespace contains {\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | Hash.keccak256.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if a string is a valid bloom filter value.\n *\n * @example\n * ```ts twoslash\n * import { Bloom } from 'ox'\n *\n * Bloom.validate('0x')\n * // @log: false\n *\n * Bloom.validate('0x00000000000000000000008000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000044000200000000000000000002000000000000000000000040000000000000000000000000000020000000000000000000800000000000800000000000800000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000808002000000000400000000000000000000000060000000000000000000000000000000000000000000000100000000000002000000')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid bloom filter.\n */\nexport function validate(value: string): value is Hex.Hex {\n  return Hex.validate(value) && Hex.size(value) === 256\n}\n\nexport declare namespace validate {\n  type ErrorType =\n    | Hex.validate.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n", "import type { ProjPointType } from '@noble/curves/abstract/weierstrass'\nimport { bls12_381 as bls } from '@noble/curves/bls12-381'\n\nimport type * as BlsPoint from './BlsPoint.js'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { OneOf } from './internal/types.js'\n\nexport type Size = 'short-key:long-sig' | 'long-key:short-sig'\n\n/** Re-export of noble/curves BLS12-381 utilities. */\nexport const noble = bls\n\n/**\n * Aggregates a set of BLS points that are either on the G1 or G2 curves (ie. public keys or signatures).\n *\n * @example\n * ### Aggregating Signatures\n *\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const payload = Hex.random(32)\n *\n * const signatures = [\n *   Bls.sign({ payload, privateKey: '0x...' }),\n *   Bls.sign({ payload, privateKey: '0x...' }),\n * ]\n * const signature = Bls.aggregate(signatures)\n * ```\n *\n * @example\n * ### Aggregating Public Keys\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const publicKeys = [\n *   Bls.getPublicKey({ privateKey: '0x...' }),\n *   Bls.getPublicKey({ privateKey: '0x...' }),\n * ]\n * const publicKey = Bls.aggregate(publicKeys)\n * ```\n *\n * @param points - The points to aggregate.\n * @returns The aggregated point.\n */\nexport function aggregate<const points extends readonly BlsPoint.BlsPoint[]>(\n  points: points,\n): points extends readonly BlsPoint.G1[] ? BlsPoint.G1 : BlsPoint.G2\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function aggregate(\n  points: readonly BlsPoint.BlsPoint[],\n): BlsPoint.BlsPoint {\n  const group = typeof points[0]?.x === 'bigint' ? bls.G1 : bls.G2\n  const point = points.reduce(\n    (acc, point) =>\n      acc.add(new (group as any).ProjectivePoint(point.x, point.y, point.z)),\n    group.ProjectivePoint.ZERO,\n  )\n  return {\n    x: point.px,\n    y: point.py,\n    z: point.pz,\n  }\n}\n\nexport declare namespace aggregate {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Creates a new BLS12-381 key pair consisting of a private key and its corresponding public key.\n *\n * - G1 Point (Default):\n *   - short (48 bytes)\n *   - computes longer G2 Signatures (96 bytes)\n * - G2 Point:\n *   - long (96 bytes)\n *   - computes short G1 Signatures (48 bytes)\n *\n * @example\n * ### Short G1 Public Keys (Default)\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const { publicKey } = Bls.createKeyPair()\n * //      ^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Long G2 Public Keys\n *\n * A G2 Public Key can be derived as a G2 point (96 bytes) using `size: 'long-key:short-sig'`.\n *\n * This will allow you to compute G1 Signatures (48 bytes) with {@link ox#Bls.(sign:function)}.\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const { publicKey } = Bls.createKeyPair({\n *   size: 'long-key:short-sig',\n * })\n *\n * publicKey\n * // ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * ### Serializing\n *\n * Public Keys can be serialized to hex or bytes using {@link ox#BlsPoint.(toHex:function)} or {@link ox#BlsPoint.(toBytes:function)}:\n *\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const { publicKey } = Bls.createKeyPair()\n *\n * const publicKeyHex = BlsPoint.toHex(publicKey)\n * //    ^?\n *\n *\n * const publicKeyBytes = BlsPoint.toBytes(publicKey)\n * //    ^?\n *\n * ```\n *\n * They can also be deserialized from hex or bytes using {@link ox#BlsPoint.(fromHex:function)} or {@link ox#BlsPoint.(fromBytes:function)}:\n *\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const publicKeyHex = '0x...'\n *\n * const publicKey = BlsPoint.fromHex(publicKeyHex, 'G1')\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nexport function createKeyPair<\n  as extends 'Hex' | 'Bytes' = 'Hex',\n  size extends Size = 'short-key:long-sig',\n>(\n  options: createKeyPair.Options<as, size> = {},\n): createKeyPair.ReturnType<as, size> {\n  const { as = 'Hex', size = 'short-key:long-sig' } = options\n  const privateKey = randomPrivateKey({ as })\n  const publicKey = getPublicKey({ privateKey, size })\n\n  return {\n    privateKey: privateKey as never,\n    publicKey: publicKey as never,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options<\n    as extends 'Hex' | 'Bytes' = 'Hex',\n    size extends Size = 'short-key:long-sig',\n  > = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Size of the public key to compute.\n     *\n     * - `'short-key:long-sig'`: 48 bytes; computes long signatures (96 bytes)\n     * - `'long-key:short-sig'`: 96 bytes; computes short signatures (48 bytes)\n     *\n     * @default 'short-key:long-sig'\n     */\n    size?: size | Size | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes', size extends Size> = {\n    privateKey:\n      | (as extends 'Bytes' ? Bytes.Bytes : never)\n      | (as extends 'Hex' ? Hex.Hex : never)\n    publicKey: size extends 'short-key:long-sig' ? BlsPoint.G1 : BlsPoint.G2\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | getPublicKey.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the BLS12-381 public key from a provided private key.\n *\n * Public Keys can be derived as a point on one of the BLS12-381 groups:\n *\n * - G1 Point (Default):\n *   - short (48 bytes)\n *   - computes longer G2 Signatures (96 bytes)\n * - G2 Point:\n *   - long (96 bytes)\n *   - computes short G1 Signatures (48 bytes)\n *\n * @example\n * ### Short G1 Public Keys (Default)\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const publicKey = Bls.getPublicKey({ privateKey: '0x...' })\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Long G2 Public Keys\n *\n * A G2 Public Key can be derived as a G2 point (96 bytes) using `size: 'long-key:short-sig'`.\n *\n * This will allow you to compute G1 Signatures (48 bytes) with {@link ox#Bls.(sign:function)}.\n *\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const publicKey = Bls.getPublicKey({\n *   privateKey: '0x...',\n *   size: 'long-key:short-sig',\n * })\n *\n * publicKey\n * // ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * ### Serializing\n *\n * Public Keys can be serialized to hex or bytes using {@link ox#BlsPoint.(toHex:function)} or {@link ox#BlsPoint.(toBytes:function)}:\n *\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const publicKey = Bls.getPublicKey({ privateKey: '0x...' })\n *\n * const publicKeyHex = BlsPoint.toHex(publicKey)\n * //    ^?\n *\n *\n * const publicKeyBytes = BlsPoint.toBytes(publicKey)\n * //    ^?\n *\n * ```\n *\n * They can also be deserialized from hex or bytes using {@link ox#BlsPoint.(fromHex:function)} or {@link ox#BlsPoint.(fromBytes:function)}:\n *\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const publicKeyHex = '0x...'\n *\n * const publicKey = BlsPoint.fromHex(publicKeyHex, 'G1')\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey<size extends Size = 'short-key:long-sig'>(\n  options: getPublicKey.Options<size>,\n): size extends 'short-key:long-sig' ? BlsPoint.G1 : BlsPoint.G2\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getPublicKey(options: getPublicKey.Options): BlsPoint.BlsPoint {\n  const { privateKey, size = 'short-key:long-sig' } = options\n  const group = size === 'short-key:long-sig' ? bls.G1 : bls.G2\n  const { px, py, pz } = group.ProjectivePoint.fromPrivateKey(\n    Hex.from(privateKey).slice(2),\n  )\n  return { x: px, y: py, z: pz }\n}\n\nexport declare namespace getPublicKey {\n  type Options<size extends Size = 'short-key:long-sig'> = {\n    /**\n     * Private key to compute the public key from.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n    /**\n     * Size of the public key to compute.\n     *\n     * - `'short-key:long-sig'`: 48 bytes; computes long signatures (96 bytes)\n     * - `'long-key:short-sig'`: 96 bytes; computes short signatures (48 bytes)\n     *\n     * @default 'short-key:long-sig'\n     */\n    size?: size | Size | undefined\n  }\n\n  type ErrorType = Hex.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random BLS12-381 private key.\n *\n * @example\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: randomPrivateKey.Options<as> = {},\n): randomPrivateKey.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const bytes = bls.utils.randomPrivateKey()\n  if (as === 'Hex') return Hex.fromBytes(bytes) as never\n  return bytes as never\n}\n\nexport declare namespace randomPrivateKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Signs the payload with the provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const signature = Bls.sign({ // [!code focus]\n *   payload: Hex.random(32), // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Serializing\n *\n * Signatures can be serialized to hex or bytes using {@link ox#BlsPoint.(toHex:function)} or {@link ox#BlsPoint.(toBytes:function)}:\n *\n * ```ts twoslash\n * import { Bls, BlsPoint, Hex } from 'ox'\n *\n * const signature = Bls.sign({ payload: Hex.random(32), privateKey: '0x...' })\n *\n * const signatureHex = BlsPoint.toHex(signature)\n * //    ^?\n *\n *\n *\n * const signatureBytes = BlsPoint.toBytes(signature)\n * //    ^?\n *\n *\n * ```\n *\n * They can also be deserialized from hex or bytes using {@link ox#BlsPoint.(fromHex:function)} or {@link ox#BlsPoint.(fromBytes:function)}:\n *\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const signatureHex = '0x...'\n *\n * const signature = BlsPoint.fromHex(signatureHex, 'G2')\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @param options - The signing options.\n * @returns BLS Point.\n */\nexport function sign<size extends Size = 'short-key:long-sig'>(\n  options: sign.Options<size>,\n): size extends 'short-key:long-sig' ? BlsPoint.G2 : BlsPoint.G1\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function sign(options: sign.Options): BlsPoint.BlsPoint {\n  const { payload, privateKey, suite, size = 'short-key:long-sig' } = options\n\n  const payloadGroup = size === 'short-key:long-sig' ? bls.G2 : bls.G1\n  const payloadPoint = payloadGroup.hashToCurve(\n    Bytes.from(payload),\n    suite ? { DST: Bytes.fromString(suite) } : undefined,\n  )\n\n  const privateKeyGroup = size === 'short-key:long-sig' ? bls.G1 : bls.G2\n  const signature = payloadPoint.multiply(\n    privateKeyGroup.normPrivateKeyToScalar(privateKey.slice(2)),\n  ) as ProjPointType<any>\n\n  return {\n    x: signature.px,\n    y: signature.py,\n    z: signature.pz,\n  }\n}\n\nexport declare namespace sign {\n  type Options<size extends Size = 'short-key:long-sig'> = {\n    /**\n     * Payload to sign.\n     */\n    payload: Hex.Hex | Bytes.Bytes\n    /**\n     * BLS private key.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n    /**\n     * Ciphersuite to use for signing. Defaults to \"Basic\".\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-05#section-4\n     * @default 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_'\n     */\n    suite?: string | undefined\n    /**\n     * Size of the signature to compute.\n     *\n     * - `'long-key:short-sig'`: 48 bytes\n     * - `'short-key:long-sig'`: 96 bytes\n     *\n     * @default 'short-key:long-sig'\n     */\n    size?: size | Size | undefined\n  }\n\n  type ErrorType = Bytes.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided public key(s).\n *\n * @example\n *\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const payload = Hex.random(32)\n * const privateKey = Bls.randomPrivateKey()\n *\n * const publicKey = Bls.getPublicKey({ privateKey })\n * const signature = Bls.sign({ payload, privateKey })\n *\n * const verified = Bls.verify({ // [!code focus]\n *   payload, // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify Aggregated Signatures\n *\n * We can also pass a public key and signature that was aggregated with {@link ox#Bls.(aggregate:function)} to `Bls.verify`.\n *\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const payload = Hex.random(32)\n * const privateKeys = Array.from({ length: 100 }, () => Bls.randomPrivateKey())\n *\n * const publicKeys = privateKeys.map((privateKey) =>\n *   Bls.getPublicKey({ privateKey }),\n * )\n * const signatures = privateKeys.map((privateKey) =>\n *   Bls.sign({ payload, privateKey }),\n * )\n *\n * const publicKey = Bls.aggregate(publicKeys) // [!code focus]\n * const signature = Bls.aggregate(signatures) // [!code focus]\n *\n * const valid = Bls.verify({ payload, publicKey, signature }) // [!code focus]\n * ```\n *\n * @param options - Verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport function verify(options: verify.Options): boolean {\n  const { payload, suite } = options\n\n  const publicKey = options.publicKey as unknown as BlsPoint.BlsPoint<any>\n  const signature = options.signature as unknown as BlsPoint.BlsPoint<any>\n\n  const isShortSig = typeof signature.x === 'bigint'\n\n  const group = isShortSig ? bls.G1 : bls.G2\n  const payloadPoint = group.hashToCurve(\n    Bytes.from(payload),\n    suite ? { DST: Bytes.fromString(suite) } : undefined,\n  ) as ProjPointType<any>\n\n  const shortSigPairing = () =>\n    bls.pairingBatch([\n      {\n        g1: payloadPoint,\n        g2: new bls.G2.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z),\n      },\n      {\n        g1: new bls.G1.ProjectivePoint(signature.x, signature.y, signature.z),\n        g2: bls.G2.ProjectivePoint.BASE.negate(),\n      },\n    ])\n\n  const longSigPairing = () =>\n    bls.pairingBatch([\n      {\n        g1: new bls.G1.ProjectivePoint(\n          publicKey.x,\n          publicKey.y,\n          publicKey.z,\n        ).negate(),\n        g2: payloadPoint,\n      },\n      {\n        g1: bls.G1.ProjectivePoint.BASE,\n        g2: new bls.G2.ProjectivePoint(signature.x, signature.y, signature.z),\n      },\n    ])\n\n  return bls.fields.Fp12.eql(\n    isShortSig ? shortSigPairing() : longSigPairing(),\n    bls.fields.Fp12.ONE,\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /**\n     * Payload that was signed.\n     */\n    payload: Hex.Hex | Bytes.Bytes\n    /**\n     * Ciphersuite to use for verification. Defaults to \"Basic\".\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-05#section-4\n     * @default 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_'\n     */\n    suite?: string | undefined\n  } & OneOf<\n    | {\n        publicKey: BlsPoint.G1\n        signature: BlsPoint.G2\n      }\n    | {\n        publicKey: BlsPoint.G2\n        signature: BlsPoint.G1\n      }\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import { bls12_381 as bls } from '@noble/curves/bls12-381'\n\nimport type * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Branded, Compute } from './internal/types.js'\n\n/** Type for a field element in the base field of the BLS12-381 curve. */\nexport type Fp = bigint\n/** Type for a field element in the extension field of the BLS12-381 curve. */\nexport type Fp2 = Compute<{ c0: bigint; c1: bigint }>\n\n/** Root type for a BLS point on the G1 or G2 curve. */\nexport type BlsPoint<type = Fp | Fp2> = Compute<{\n  x: type\n  y: type\n  z: type\n}>\n\n/** Type for a BLS point on the G1 curve. */\nexport type G1 = BlsPoint<Fp>\n/** Branded type for a bytes representation of a G1 point. */\nexport type G1Bytes = Branded<Bytes.Bytes, 'G1'>\n/** Branded type for a hex representation of a G1 point. */\nexport type G1Hex = Branded<Hex.Hex, 'G1'>\n\n/** Type for a BLS point on the G2 curve. */\nexport type G2 = BlsPoint<Fp2>\n/** Branded type for a bytes representation of a G2 point. */\nexport type G2Bytes = Branded<Bytes.Bytes, 'G2'>\n/** Branded type for a hex representation of a G2 point. */\nexport type G2Hex = Branded<Hex.Hex, 'G2'>\n\n/**\n * Converts a BLS point to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ### Public Key to Bytes\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const publicKey = Bls.getPublicKey({ privateKey: '0x...' })\n * const publicKeyBytes = BlsPoint.toBytes(publicKey)\n * // @log: Uint8Array [172, 175, 255, ...]\n * ```\n *\n * @example\n * ### Signature to Bytes\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const signature = Bls.sign({ payload: '0x...', privateKey: '0x...' })\n * const signatureBytes = BlsPoint.toBytes(signature)\n * // @log: Uint8Array [172, 175, 255, ...]\n * ```\n *\n * @param point - The BLS point to convert.\n * @returns The bytes representation of the BLS point.\n */\nexport function toBytes<point extends G1 | G2>(\n  point: point,\n): point extends G1 ? G1Bytes : G2Bytes {\n  const group = typeof point.z === 'bigint' ? bls.G1 : bls.G2\n  return new (group as any).ProjectivePoint(\n    point.x,\n    point.y,\n    point.z,\n  ).toRawBytes()\n}\n\nexport declare namespace toBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a BLS point to {@link ox#Hex.Hex}.\n *\n * @example\n * ### Public Key to Hex\n *\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const publicKey = Bls.getPublicKey({ privateKey: '0x...' })\n * const publicKeyHex = BlsPoint.toHex(publicKey)\n * // @log: '0xacafff52270773ad1728df2807c0f1b0b271fa6b37dfb8b2f75448573c76c81bcd6790328a60e40ef5a13343b32d9e66'\n * ```\n *\n * @example\n * ### Signature to Hex\n *\n * ```ts twoslash\n * import { Bls, BlsPoint } from 'ox'\n *\n * const signature = Bls.sign({ payload: '0x...', privateKey: '0x...' })\n * const signatureHex = BlsPoint.toHex(signature)\n * // @log: '0xb4698f7611999fba87033b9cf72312c76c683bbc48175e2d4cb275907d6a267ab9840a66e3051e5ed36fd13aa712f9a9024f9fa9b67f716dfb74ae4efb7d9f1b7b43b4679abed6644cf476c12e79f309351ea8452487cd93f66e29e04ebe427c'\n * ```\n *\n * @param point - The BLS point to convert.\n * @returns The hex representation of the BLS point.\n */\nexport function toHex<point extends G1 | G2>(\n  point: point,\n): point extends G1 ? G1Hex : G2Hex\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function toHex(point: G1 | G2): Hex.Hex {\n  return Hex.fromBytes(toBytes(point))\n}\n\nexport declare namespace toHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts {@link ox#Bytes.Bytes} to a BLS point.\n *\n * @example\n * ### Bytes to Public Key\n *\n * ```ts twoslash\n * // @noErrors\n * import { BlsPoint } from 'ox'\n *\n * const publicKey = BlsPoint.fromBytes(Bytes.from([172, 175, 255, ...]), 'G1')\n * // @log: {\n * // @log:   x: 172...n,\n * // @log:   y: 175...n,\n * // @log:   z: 1n,\n * // @log: }\n * ```\n *\n * @example\n * ### Bytes to Signature\n *\n * ```ts twoslash\n * // @noErrors\n * import { BlsPoint } from 'ox'\n *\n * const signature = BlsPoint.fromBytes(Bytes.from([172, 175, 255, ...]), 'G2')\n * // @log: {\n * // @log:   x: 511...n,\n * // @log:   y: 234...n,\n * // @log:   z: 1n,\n * // @log: }\n * ```\n *\n * @param bytes - The bytes to convert.\n * @returns The BLS point.\n */\nexport function fromBytes<group extends 'G1' | 'G2'>(\n  bytes: Bytes.Bytes,\n  group: group,\n): group extends 'G1' ? G1 : G2\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function fromBytes(bytes: Bytes.Bytes): BlsPoint<any> {\n  const group = bytes.length === 48 ? bls.G1 : bls.G2\n  const point = group.ProjectivePoint.fromHex(bytes)\n  return {\n    x: point.px,\n    y: point.py,\n    z: point.pz,\n  }\n}\n\nexport declare namespace fromBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts {@link ox#Hex.Hex} to a BLS point.\n *\n * @example\n * ### Hex to Public Key\n *\n * ```ts twoslash\n * // @noErrors\n * import { BlsPoint } from 'ox'\n *\n * const publicKey = BlsPoint.fromHex('0xacafff52270773ad1728df2807c0f1b0b271fa6b37dfb8b2f75448573c76c81bcd6790328a60e40ef5a13343b32d9e66', 'G1')\n * // @log: {\n * // @log:   x: 172...n,\n * // @log:   y: 175...n,\n * // @log:   z: 1n,\n * // @log: }\n * ```\n *\n * @example\n * ### Hex to Signature\n *\n * ```ts twoslash\n * // @noErrors\n * import { BlsPoint } from 'ox'\n *\n * const signature = BlsPoint.fromHex(\n *   '0xb4698f7611999fba87033b9cf72312c76c683bbc48175e2d4cb275907d6a267ab9840a66e3051e5ed36fd13aa712f9a9024f9fa9b67f716dfb74ae4efb7d9f1b7b43b4679abed6644cf476c12e79f309351ea8452487cd93f66e29e04ebe427c',\n *   'G2',\n * )\n * // @log: {\n * // @log:   x: 511...n,\n * // @log:   y: 234...n,\n * // @log:   z: 1n,\n * // @log: }\n * ```\n *\n * @param bytes - The bytes to convert.\n * @returns The BLS point.\n */\nexport function fromHex<group extends 'G1' | 'G2'>(\n  hex: Hex.Hex,\n  group: group,\n): group extends 'G1' ? G1 : G2\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function fromHex(hex: Hex.Hex, group: 'G1' | 'G2'): BlsPoint<any> {\n  return fromBytes(Hex.toBytes(hex), group)\n}\n\nexport declare namespace fromHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as Address from './Address.js'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type { OneOf } from './internal/types.js'\nimport * as Rlp from './Rlp.js'\n\n/**\n * Computes Contract Address generated by the [CREATE](https://ethereum.stackexchange.com/questions/68943/create-opcode-what-does-it-really-do/68945#68945) or [CREATE2](https://eips.ethereum.org/EIPS/eip-1014) opcode.\n *\n * @example\n * ### CREATE\n *\n * Computes via the [CREATE](https://ethereum.stackexchange.com/questions/68943/create-opcode-what-does-it-really-do/68945#68945) opcode. Shorthand for {@link ox#ContractAddress.(fromCreate:function)}.\n *\n * ```ts twoslash\n * import { ContractAddress } from 'ox'\n * ContractAddress.from({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   nonce: 0n,\n * })\n * // @log: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'\n * ```\n *\n * @example\n * ### CREATE2\n *\n * Computes via the [CREATE2](https://eips.ethereum.org/EIPS/eip-1014) opcode. Shorthand for {@link ox#ContractAddress.(fromCreate2:function)}.\n *\n * ```ts twoslash\n * import { ContractAddress, Hex } from 'ox'\n * ContractAddress.from({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   bytecode: '0x6394198df16000526103ff60206004601c335afa6040516060f3',\n *   salt: Hex.fromString('hello world'),\n * })\n * // @log: '0x59fbB593ABe27Cb193b6ee5C5DC7bbde312290aB'\n * ```\n *\n * @param options - Options.\n * @returns Contract Address.\n */\nexport function from(options: from.Options): Address.Address {\n  if (options.salt) return fromCreate2(options)\n  return fromCreate(options)\n}\n\nexport declare namespace from {\n  export type Options = OneOf<fromCreate.Options | fromCreate2.Options>\n\n  type ErrorType =\n    | fromCreate.ErrorType\n    | fromCreate2.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes contract address via [CREATE](https://ethereum.stackexchange.com/questions/68943/create-opcode-what-does-it-really-do/68945#68945) opcode.\n *\n * @example\n * ```ts twoslash\n * import { ContractAddress } from 'ox'\n *\n * ContractAddress.fromCreate({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   nonce: 0n,\n * })\n * // @log: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'\n * ```\n *\n * @param options - Options for retrieving address.\n * @returns Contract Address.\n */\nexport function fromCreate(options: fromCreate.Options): Address.Address {\n  const from = Bytes.fromHex(Address.from(options.from))\n\n  let nonce = Bytes.fromNumber(options.nonce)\n  if (nonce[0] === 0) nonce = new Uint8Array([])\n\n  return Address.from(\n    `0x${Hash.keccak256(Rlp.fromBytes([from, nonce], { as: 'Hex' })).slice(26)}` as Address.Address,\n  )\n}\n\nexport declare namespace fromCreate {\n  type Options = {\n    /** The address the contract was deployed from. */\n    from: Address.Address\n    /** The nonce of the transaction which deployed the contract. */\n    nonce: bigint\n  }\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | Address.from.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Bytes.fromNumber.ErrorType\n    | Rlp.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes contract address via [CREATE2](https://eips.ethereum.org/EIPS/eip-1014) opcode.\n *\n * @example\n * ```ts twoslash\n * import { ContractAddress, Hex } from 'ox'\n *\n * ContractAddress.fromCreate2({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   bytecode: '0x6394198df16000526103ff60206004601c335afa6040516060f3',\n *   salt: Hex.fromString('hello world'),\n * })\n * // @log: '0x59fbB593ABe27Cb193b6ee5C5DC7bbde312290aB'\n * ```\n *\n * @param options - Options for retrieving address.\n * @returns Contract Address.\n */\nexport function fromCreate2(options: fromCreate2.Options): Address.Address {\n  const from = Bytes.fromHex(Address.from(options.from))\n  const salt = Bytes.padLeft(\n    Bytes.validate(options.salt) ? options.salt : Bytes.fromHex(options.salt),\n    32,\n  )\n\n  const bytecodeHash = (() => {\n    if ('bytecodeHash' in options) {\n      if (Bytes.validate(options.bytecodeHash)) return options.bytecodeHash\n      return Bytes.fromHex(options.bytecodeHash)\n    }\n    return Hash.keccak256(options.bytecode, { as: 'Bytes' })\n  })()\n\n  return Address.from(\n    Hex.slice(\n      Hash.keccak256(\n        Bytes.concat(Bytes.fromHex('0xff'), from, salt, bytecodeHash),\n        { as: 'Hex' },\n      ),\n      12,\n    ),\n  )\n}\n\nexport declare namespace fromCreate2 {\n  type Options =\n    | {\n        bytecode: Bytes.Bytes | Hex.Hex\n        from: Address.Address\n        salt: Bytes.Bytes | Hex.Hex\n      }\n    | {\n        bytecodeHash: Bytes.Bytes | Hex.Hex\n        from: Address.Address\n        salt: Bytes.Bytes | Hex.Hex\n      }\n\n  type ErrorType =\n    | Address.from.ErrorType\n    | Bytes.concat.ErrorType\n    | Bytes.validate.ErrorType\n    | Bytes.padLeft.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.slice.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n", "import { ed25519 } from '@noble/curves/ed25519'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\n/** Re-export of noble/curves Ed25519 utilities. */\nexport const noble = ed25519\n\n/**\n * Creates a new Ed25519 key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { Ed25519 } from 'ox'\n *\n * const { privateKey, publicKey } = Ed25519.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nexport function createKeyPair<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: createKeyPair.Options<as> = {},\n): createKeyPair.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const privateKey = randomPrivateKey({ as })\n  const publicKey = getPublicKey({ privateKey, as })\n\n  return {\n    privateKey: privateKey as never,\n    publicKey: publicKey as never,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private and public keys.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> = {\n    privateKey:\n      | (as extends 'Bytes' ? Bytes.Bytes : never)\n      | (as extends 'Hex' ? Hex.Hex : never)\n    publicKey:\n      | (as extends 'Bytes' ? Bytes.Bytes : never)\n      | (as extends 'Hex' ? Hex.Hex : never)\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | randomPrivateKey.ErrorType\n    | getPublicKey.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the Ed25519 public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Ed25519 } from 'ox'\n *\n * const publicKey = Ed25519.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getPublicKey.Options<as>,\n): getPublicKey.ReturnType<as> {\n  const { as = 'Hex', privateKey } = options\n  const privateKeyBytes = Bytes.from(privateKey)\n  const publicKeyBytes = ed25519.getPublicKey(privateKeyBytes)\n  if (as === 'Hex') return Hex.fromBytes(publicKeyBytes) as never\n  return publicKeyBytes as never\n}\n\nexport declare namespace getPublicKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned public key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to compute the public key from.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random Ed25519 private key.\n *\n * @example\n * ```ts twoslash\n * import { Ed25519 } from 'ox'\n *\n * const privateKey = Ed25519.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: randomPrivateKey.Options<as> = {},\n): randomPrivateKey.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const bytes = ed25519.utils.randomPrivateKey()\n  if (as === 'Hex') return Hex.fromBytes(bytes) as never\n  return bytes as never\n}\n\nexport declare namespace randomPrivateKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Signs the payload with the provided private key and returns an Ed25519 signature.\n *\n * @example\n * ```ts twoslash\n * import { Ed25519 } from 'ox'\n *\n * const signature = Ed25519.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The Ed25519 signature.\n */\nexport function sign<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: sign.Options<as>,\n): sign.ReturnType<as> {\n  const { as = 'Hex', payload, privateKey } = options\n  const payloadBytes = Bytes.from(payload)\n  const privateKeyBytes = Bytes.from(privateKey)\n  const signatureBytes = ed25519.sign(payloadBytes, privateKeyBytes)\n  if (as === 'Hex') return Hex.fromBytes(signatureBytes) as never\n  return signatureBytes as never\n}\n\nexport declare namespace sign {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned signature.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Payload to sign.\n     */\n    payload: Hex.Hex | Bytes.Bytes\n    /**\n     * Ed25519 private key.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n * ```ts twoslash\n * import { Ed25519 } from 'ox'\n *\n * const { privateKey, publicKey } = Ed25519.createKeyPair()\n * const signature = Ed25519.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = Ed25519.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport function verify(options: verify.Options): boolean {\n  const { payload, publicKey, signature } = options\n  const payloadBytes = Bytes.from(payload)\n  const publicKeyBytes = Bytes.from(publicKey)\n  const signatureBytes = Bytes.from(signature)\n  return ed25519.verify(signatureBytes, payloadBytes, publicKeyBytes)\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Public key that signed the payload. */\n    publicKey: Hex.Hex | Bytes.Bytes\n    /** Signature of the payload. */\n    signature: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Bytes.from.ErrorType | Errors.GlobalErrorType\n}\n", "/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// prettier-ignore\nimport {\n  pippenger, validateBasic, wNAF,\n  type AffinePoint, type BasicCurve, type Group, type GroupConstructor\n} from './curve.ts';\nimport { Field, FpInvertBatch, mod } from './modular.ts';\n// prettier-ignore\nimport {\n  abool, aInRange, bytesToHex, bytesToNumberLE, concatBytes,\n  ensureBytes, memoized, numberToBytesLE, validateObject,\n  type FHash, type Hex\n} from './utils.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\n/** Edwards curves must declare params a & d. */\nexport type CurveType = BasicCurve<bigint> & {\n  a: bigint; // curve param a\n  d: bigint; // curve param d\n  hash: FHash; // Hashing\n  randomBytes: (bytesLength?: number) => Uint8Array; // CSPRNG\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array; // clears bits to get valid field elemtn\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array; // Used for hashing\n  uvRatio?: (u: bigint, v: bigint) => { isValid: boolean; value: bigint }; // Ratio √(u/v)\n  prehash?: FHash; // RFC 8032 pre-hashing of messages to sign() / verify()\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>; // for hash-to-curve standard\n};\n\nexport type CurveTypeWithLength = Readonly<CurveType & { nByteLength: number; nBitLength: number }>;\n\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\n\nfunction validateOpts(curve: CurveType): CurveTypeWithLength {\n  const opts = validateBasic(curve);\n  validateObject(\n    curve,\n    {\n      hash: 'function',\n      a: 'bigint',\n      d: 'bigint',\n      randomBytes: 'function',\n    },\n    {\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      uvRatio: 'function',\n      mapToCurve: 'function',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...opts } as const);\n}\n\n/** Instance of Extended Point with coordinates in X, Y, Z, T. */\nexport interface ExtPointType extends Group<ExtPointType> {\n  readonly ex: bigint;\n  readonly ey: bigint;\n  readonly ez: bigint;\n  readonly et: bigint;\n  get x(): bigint;\n  get y(): bigint;\n  assertValidity(): void;\n  multiply(scalar: bigint): ExtPointType;\n  multiplyUnsafe(scalar: bigint): ExtPointType;\n  isSmallOrder(): boolean;\n  isTorsionFree(): boolean;\n  clearCofactor(): ExtPointType;\n  toAffine(iz?: bigint): AffinePoint<bigint>;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n  _setWindowSize(windowSize: number): void;\n}\n/** Static methods of Extended Point with coordinates in X, Y, Z, T. */\nexport interface ExtPointConstructor extends GroupConstructor<ExtPointType> {\n  new (x: bigint, y: bigint, z: bigint, t: bigint): ExtPointType;\n  fromAffine(p: AffinePoint<bigint>): ExtPointType;\n  fromHex(hex: Hex): ExtPointType;\n  fromPrivateKey(privateKey: Hex): ExtPointType;\n  msm(points: ExtPointType[], scalars: bigint[]): ExtPointType;\n}\n\n/**\n * Edwards Curve interface.\n * Main methods: `getPublicKey(priv)`, `sign(msg, priv)`, `verify(sig, msg, pub)`.\n */\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  sign: (message: Hex, privateKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  ExtendedPoint: ExtPointConstructor;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: ExtPointType;\n      pointBytes: Uint8Array;\n    };\n    precompute: (windowSize?: number, point?: ExtPointType) => ExtPointType;\n  };\n};\n\n/**\n * Creates Twisted Edwards curve with EdDSA signatures.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h\n * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })\n */\nexport function twistedEdwards(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const {\n    Fp,\n    n: CURVE_ORDER,\n    prehash: prehash,\n    hash: cHash,\n    randomBytes,\n    nByteLength,\n    h: cofactor,\n  } = CURVE;\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n  const modP = Fp.create; // Function overrides\n  const Fn = Field(CURVE.n, CURVE.nBitLength);\n\n  function isEdValidXY(x: bigint, y: bigint): boolean {\n    const x2 = Fp.sqr(x);\n    const y2 = Fp.sqr(y);\n    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n    return Fp.eql(left, right);\n  }\n\n  // Validate whether the passed curve params are valid.\n  // equation ax² + y² = 1 + dx²y² should work for generator point.\n  if (!isEdValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\n\n  // sqrt(u/v)\n  const uvRatio =\n    CURVE.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes); // NOOP\n  const domain =\n    CURVE.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      abool('phflag', phflag);\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n  // 0 <= n < MASK\n  // Coordinates larger than Fp.ORDER are allowed for zip215\n  function aCoordinate(title: string, n: bigint, banZero = false) {\n    const min = banZero ? _1n : _0n;\n    aInRange('coordinate ' + title, n, min, MASK);\n  }\n\n  function aextpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p: Point, iz?: bigint): AffinePoint<bigint> => {\n    const { ex: x, ey: y, ez: z } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : (Fp.inv(z) as bigint); // 8 was chosen arbitrarily\n    const ax = modP(x * iz);\n    const ay = modP(y * iz);\n    const zz = modP(z * iz);\n    if (is0) return { x: _0n, y: _1n };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return { x: ax, y: ay };\n  });\n  const assertValidMemo = memoized((p: Point) => {\n    const { a, d } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n    const { ex: X, ey: Y, ez: Z, et: T } = p;\n    const X2 = modP(X * X); // X²\n    const Y2 = modP(Y * Y); // Y²\n    const Z2 = modP(Z * Z); // Z²\n    const Z4 = modP(Z2 * Z2); // Z⁴\n    const aX2 = modP(X2 * a); // aX²\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n\n  // Extended Point works in extended coordinates: (X, Y, Z, T) ∋ (x=X/Z, y=Y/Z, T=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements ExtPointType {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    readonly ex: bigint;\n    readonly ey: bigint;\n    readonly ez: bigint;\n    readonly et: bigint;\n\n    constructor(ex: bigint, ey: bigint, ez: bigint, et: bigint) {\n      aCoordinate('x', ex);\n      aCoordinate('y', ey);\n      aCoordinate('z', ez, true);\n      aCoordinate('t', et);\n      this.ex = ex;\n      this.ey = ey;\n      this.ez = ez;\n      this.et = et;\n      Object.freeze(this);\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      aCoordinate('x', x);\n      aCoordinate('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = FpInvertBatch(\n        Fp,\n        points.map((p) => p.ez)\n      );\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n    // Multiscalar Multiplication\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      wnaf.setWindowSize(this, windowSize);\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      aextpoint(other);\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      aextpoint(other);\n      const { a, d } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, n, Point.normalizeZ);\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      const n = scalar;\n      aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n      const { p, f } = this.wNAF(n);\n      return Point.normalizeZ([p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar: bigint, acc = Point.ZERO): Point {\n      const n = scalar;\n      aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n      if (n === _0n) return I;\n      if (this.is0() || n === _1n) return this;\n      return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(iz?: bigint): AffinePoint<bigint> {\n      return toAffineMemo(this, iz);\n    }\n\n    clearCofactor(): Point {\n      const { h: cofactor } = CURVE;\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex: Hex, zip215 = false): Point {\n      const { d, a } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      abool('zip215', zip215);\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = bytesToNumberLE(normed);\n\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange('pointHex.y', y, _0n, max);\n\n      // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n      // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y² - 1\n      const v = modP(d * y2 - a); // v = d y² + 1.\n      let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n    static fromPrivateKey(privKey: Hex): Point {\n      const { scalar } = getPrivateScalar(privKey);\n      return G.multiply(scalar); // reduced one call of `toRawBytes`\n    }\n    toRawBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      const bytes = numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    toHex(): string {\n      return bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n    }\n  }\n  const { BASE: G, ZERO: I } = Point;\n  const wnaf = wNAF(Point, nByteLength * 8);\n\n  function modN(a: bigint) {\n    return mod(a, CURVE_ORDER);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    return modN(bytesToNumberLE(hash));\n  }\n\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key: Hex) {\n    const len = Fp.BYTES;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return { head, prefix, scalar };\n  }\n\n  // Convenience method that creates public key from scalar. RFC8032 5.1.5\n  function getExtendedPublicKey(key: Hex) {\n    const { head, prefix, scalar } = getPrivateScalar(key);\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toRawBytes(); // Uint8Array representation\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey: Hex): Uint8Array {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Hex = Uint8Array.of(), ...msgs: Uint8Array[]) {\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg: Hex, privKey: Hex, options: { context?: Hex } = {}): Uint8Array {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toRawBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n    const res = concatBytes(R, numberToBytesLE(s, Fp.BYTES));\n    return ensureBytes('result', res, Fp.BYTES * 2); // 64-byte signature\n  }\n\n  const verifyOpts: { context?: Hex; zip215?: boolean } = VERIFY_DEFAULT;\n\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(sig: Hex, msg: Hex, publicKey: Hex, options = verifyOpts): boolean {\n    const { context, zip215 } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    publicKey = ensureBytes('publicKey', publicKey, len);\n    if (zip215 !== undefined) abool('zip215', zip215);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const s = bytesToNumberLE(sig.slice(len, 2 * len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n\n    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n  }\n\n  G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n\n  const utils = {\n    getExtendedPublicKey,\n    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */\n    randomPrivateKey: (): Uint8Array => randomBytes(Fp.BYTES),\n\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(windowSize = 8, point: ExtPointType = Point.BASE): ExtPointType {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3));\n      return point;\n    },\n  };\n\n  return {\n    CURVE,\n    getPublicKey,\n    sign,\n    verify,\n    ExtendedPoint: Point,\n    utils,\n  };\n}\n", "/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod } from './modular.ts';\nimport {\n  aInRange,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesLE,\n  validateObject,\n} from './utils.ts';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\ntype Hex = string | Uint8Array;\n\nexport type CurveType = {\n  P: bigint; // finite field prime\n  type: 'x25519' | 'x448';\n  adjustScalarBytes: (bytes: Uint8Array) => Uint8Array;\n  powPminus2: (x: bigint) => bigint;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n};\n\nexport type CurveFn = {\n  scalarMult: (scalar: Hex, u: Hex) => Uint8Array;\n  scalarMultBase: (scalar: Hex) => Uint8Array;\n  getSharedSecret: (privateKeyA: Hex, publicKeyB: Hex) => Uint8Array;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  utils: { randomPrivateKey: () => Uint8Array };\n  GuBytes: Uint8Array;\n};\n\nfunction validateOpts(curve: CurveType) {\n  validateObject(curve, {\n    adjustScalarBytes: 'function',\n    powPminus2: 'function',\n  });\n  return Object.freeze({ ...curve } as const);\n}\n\nexport function montgomery(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef);\n  const { P, type, adjustScalarBytes, powPminus2 } = CURVE;\n  const is25519 = type === 'x25519';\n  if (!is25519 && type !== 'x448') throw new Error('invalid type');\n\n  const montgomeryBits = is25519 ? 255 : 448;\n  const fieldLen = is25519 ? 32 : 56;\n  const Gu = is25519 ? BigInt(9) : BigInt(5);\n  // RFC 7748 #5:\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n  // (156326 - 2) / 4 = 39081 for curve448/X448\n  // const a = is25519 ? 156326n : 486662n;\n  const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n  // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n  // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n  // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n  const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n  const maxAdded = is25519\n    ? BigInt(8) * _2n ** BigInt(251) - _1n\n    : BigInt(4) * _2n ** BigInt(445) - _1n;\n  const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n  const modP = (n: bigint) => mod(n, P);\n  const GuBytes = encodeU(Gu);\n  function encodeU(u: bigint): Uint8Array {\n    return numberToBytesLE(modP(u), fieldLen);\n  }\n  function decodeU(u: Hex): bigint {\n    const _u = ensureBytes('u coordinate', u, fieldLen);\n    // RFC: When receiving such an array, implementations of X25519\n    // (but not X448) MUST mask the most significant bit in the final byte.\n    if (is25519) _u[31] &= 127; // 0b0111_1111\n    // RFC: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.  The non-canonical\n    // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n    // - 1 through 2^448 - 1 for X448.\n    return modP(bytesToNumberLE(_u));\n  }\n  function decodeScalar(scalar: Hex): bigint {\n    return bytesToNumberLE(adjustScalarBytes(ensureBytes('scalar', scalar, fieldLen)));\n  }\n  function scalarMult(scalar: Hex, u: Hex): Uint8Array {\n    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n    // Some public keys are useless, of low-order. Curve author doesn't think\n    // it needs to be validated, but we do it nonetheless.\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('invalid private or public key received');\n    return encodeU(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  function scalarMultBase(scalar: Hex): Uint8Array {\n    return scalarMult(scalar, GuBytes);\n  }\n\n  // cswap from RFC7748 \"example code\"\n  function cswap(swap: bigint, x_2: bigint, x_3: bigint): { x_2: bigint; x_3: bigint } {\n    // dummy = mask(swap) AND (x_2 XOR x_3)\n    // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n    // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n    x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n    return { x_2, x_3 };\n  }\n\n  /**\n   * Montgomery x-only multiplication ladder.\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(u: bigint, scalar: bigint): bigint {\n    aInRange('u', u, _0n, P);\n    aInRange('scalar', scalar, minScalar, maxScalar);\n    const k = scalar;\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = (k >> t) & _1n;\n      swap ^= k_t;\n      ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n      swap = k_t;\n\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n    const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n    return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n  }\n\n  return {\n    scalarMult,\n    scalarMultBase,\n    getSharedSecret: (privateKey: Hex, publicKey: Hex) => scalarMult(privateKey, publicKey),\n    getPublicKey: (privateKey: Hex): Uint8Array => scalarMultBase(privateKey),\n    utils: { randomPrivateKey: () => CURVE.randomBytes!(fieldLen) },\n    GuBytes: GuBytes.slice(),\n  };\n}\n", "/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha2';\nimport { concatBytes, randomBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { type AffinePoint, type Group, pippenger } from './abstract/curve.ts';\nimport { type CurveFn, type ExtPointType, twistedEdwards } from './abstract/edwards.ts';\nimport {\n  createHasher,\n  expand_message_xmd,\n  type Hasher,\n  type htfBasicOpts,\n  type HTFMethod,\n} from './abstract/hash-to-curve.ts';\nimport { Field, FpInvertBatch, FpSqrtEven, isNegativeLE, mod, pow2 } from './abstract/modular.ts';\nimport { montgomery, type CurveFn as XCurveFn } from './abstract/montgomery.ts';\nimport {\n  bytesToHex,\n  bytesToNumberLE,\n  ensureBytes,\n  equalBytes,\n  type Hex,\n  numberToBytesLE,\n} from './abstract/utils.ts';\n\n// 2n**255n - 19n\nconst ED25519_P = BigInt(\n  '57896044618658097711785492504343953926634992332820282019728792003956564819949'\n);\n// √(-1) aka √(a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\n  '19681161376707505956807079304988542015446066515923890162744021073123829784752'\n);\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n\nfunction ed25519_pow_2_252_3(x: bigint) {\n  // prettier-ignore\n  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n  const P = ED25519_P;\n  const x2 = (x * x) % P;\n  const b2 = (x2 * x) % P; // x^3, 11\n  const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n  const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n  const b10 = (pow2(b5, _5n, P) * b5) % P;\n  const b20 = (pow2(b10, _10n, P) * b10) % P;\n  const b40 = (pow2(b20, _20n, P) * b20) % P;\n  const b80 = (pow2(b40, _40n, P) * b40) % P;\n  const b160 = (pow2(b80, _80n, P) * b80) % P;\n  const b240 = (pow2(b160, _80n, P) * b80) % P;\n  const b250 = (pow2(b240, _10n, P) * b10) % P;\n  const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n  // ^ To pow to (p+3)/8, multiply it by x.\n  return { pow_p_5_8, b2 };\n}\n\nfunction adjustScalarBytes(bytes: Uint8Array): Uint8Array {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n\n// sqrt(u/v)\nfunction uvRatio(u: bigint, v: bigint): { isValid: boolean; value: bigint } {\n  const P = ED25519_P;\n  const v3 = mod(v * v * v, P); // v³\n  const v7 = mod(v3 * v3 * v, P); // v⁷\n  // (p+3)/8 and (p-5)/8\n  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8\n  const vx2 = mod(v * x * x, P); // vx²\n  const root1 = x; // First root candidate\n  const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n  const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n  const useRoot2 = vx2 === mod(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n  if (isNegativeLE(x, P)) x = mod(-x, P);\n  return { isValid: useRoot1 || useRoot2, value: x };\n}\n\n/** Weird / bogus points, useful for debugging. */\nexport const ED25519_TORSION_SUBGROUP: string[] = [\n  '0100000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n  '0000000000000000000000000000000000000000000000000000000000000080',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n  'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n\nconst Fp = /* @__PURE__ */ (() => Field(ED25519_P, undefined, true))();\n\nconst ed25519Defaults = /* @__PURE__ */ (() =>\n  ({\n    // Removing Fp.create() will still work, and is 10% faster on sign\n    a: Fp.create(BigInt(-1)),\n    // d is -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    // Finite field 2n**255n - 19n\n    Fp,\n    // Subgroup order 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n    h: _8n,\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n    hash: sha512,\n    randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/√v\n    uvRatio,\n  }) as const)();\n\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * import { ed25519 } from '@noble/curves/ed25519';\n * const priv = ed25519.utils.randomPrivateKey();\n * const pub = ed25519.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = ed25519.sign(msg, priv);\n * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n */\nexport const ed25519: CurveFn = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();\n\nfunction ed25519_domain(data: Uint8Array, ctx: Uint8Array, phflag: boolean) {\n  if (ctx.length > 255) throw new Error('Context is too big');\n  return concatBytes(\n    utf8ToBytes('SigEd25519 no Ed25519 collisions'),\n    new Uint8Array([phflag ? 1 : 0, ctx.length]),\n    ctx,\n    data\n  );\n}\n\nexport const ed25519ctx: CurveFn = /* @__PURE__ */ (() =>\n  twistedEdwards({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n  }))();\nexport const ed25519ph: CurveFn = /* @__PURE__ */ (() =>\n  twistedEdwards(\n    Object.assign({}, ed25519Defaults, {\n      domain: ed25519_domain,\n      prehash: sha512,\n    })\n  ))();\n\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * import { x25519 } from '@noble/curves/ed25519';\n * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n * x25519.getPublicKey(x25519.utils.randomPrivateKey());\n */\nexport const x25519: XCurveFn = /* @__PURE__ */ (() =>\n  montgomery({\n    P: ED25519_P,\n    type: 'x25519',\n    powPminus2: (x: bigint): bigint => {\n      const P = ED25519_P;\n      // x^(p-2) aka x^(2^255-21)\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes,\n  }))();\n\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nexport function edwardsToMontgomeryPub(edwardsPub: Hex): Uint8Array {\n  const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n  const _1n = BigInt(1);\n  return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nexport const edwardsToMontgomery: typeof edwardsToMontgomeryPub = edwardsToMontgomeryPub; // deprecated\n\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nexport function edwardsToMontgomeryPriv(edwardsPriv: Uint8Array): Uint8Array {\n  const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n  return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\n\nconst ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u: bigint) {\n  const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n  const ELL2_J = BigInt(486662);\n\n  let tv1 = Fp.sqr(u);          //  1.  tv1 = u^2\n  tv1 = Fp.mul(tv1, _2n);       //  2.  tv1 = 2 * tv1\n  let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n  let x1n = Fp.neg(ELL2_J);     //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n  let tv2 = Fp.sqr(xd);         //  5.  tv2 = xd^2\n  let gxd = Fp.mul(tv2, xd);    //  6.  gxd = tv2 * xd        # gxd = xd^3\n  let gx1 = Fp.mul(tv1, ELL2_J);//  7.  gx1 = J * tv1         # x1n + J * xd\n  gx1 = Fp.mul(gx1, x1n);       //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n  gx1 = Fp.add(gx1, tv2);       //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n  gx1 = Fp.mul(gx1, x1n);       //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n  let tv3 = Fp.sqr(gxd);        //  11. tv3 = gxd^2\n  tv2 = Fp.sqr(tv3);            //  12. tv2 = tv3^2           # gxd^4\n  tv3 = Fp.mul(tv3, gxd);       //  13. tv3 = tv3 * gxd       # gxd^3\n  tv3 = Fp.mul(tv3, gx1);       //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n  tv2 = Fp.mul(tv2, tv3);       //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n  let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n  y11 = Fp.mul(y11, tv3);       //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n  let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n  tv2 = Fp.sqr(y11);            //  19. tv2 = y11^2\n  tv2 = Fp.mul(tv2, gxd);       //  20. tv2 = tv2 * gxd\n  let e1 = Fp.eql(tv2, gx1);    //  21.  e1 = tv2 == gx1\n  let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n  let x2n = Fp.mul(x1n, tv1);   //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n  let y21 = Fp.mul(y11, u);     //  24. y21 = y11 * u\n  y21 = Fp.mul(y21, ELL2_C2);   //  25. y21 = y21 * c2\n  let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n  let gx2 = Fp.mul(gx1, tv1);   //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n  tv2 = Fp.sqr(y21);            //  28. tv2 = y21^2\n  tv2 = Fp.mul(tv2, gxd);       //  29. tv2 = tv2 * gxd\n  let e2 = Fp.eql(tv2, gx2);    //  30.  e2 = tv2 == gx2\n  let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n  tv2 = Fp.sqr(y1);             //  32. tv2 = y1^2\n  tv2 = Fp.mul(tv2, gxd);       //  33. tv2 = tv2 * gxd\n  let e3 = Fp.eql(tv2, gx1);    //  34.  e3 = tv2 == gx1\n  let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n  let y = Fp.cmov(y2, y1, e3);  //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n  let e4 = Fp.isOdd(y);         //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n  y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\n\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u: bigint) {\n  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n  // map_to_curve_elligator2_curve25519(u)\n  let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n  xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n  let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n  let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n  let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n  let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n  let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n  xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n  xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n  yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n  yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true); // batch division\n  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)\n}\n\nexport const ed25519_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(\n    ed25519.ExtendedPoint,\n    (scalars: bigint[]) => map_to_curve_elligator2_edwards25519(scalars[0]),\n    {\n      DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n      encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  ))();\nexport const hashToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => ed25519_hasher.hashToCurve)();\nexport const encodeToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() =>\n  ed25519_hasher.encodeToCurve)();\n\nfunction aristp(other: unknown) {\n  if (!(other instanceof RistPoint)) throw new Error('RistrettoPoint expected');\n}\n\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// √(ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\n  '25063068953384623474111414158702152701244531502492656460079210482610430750235'\n);\n// 1 / √(a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\n  '54469307008909316920995813868745141605393597292927456921205312896311721017578'\n);\n// 1-d²\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\n  '1159843021668779879193775521855586647937357759715417654439879720876111806838'\n);\n// (d-1)²\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\n  '40440834346308536858101042469323190826248399146238708352240133220865137265952'\n);\n// Calculates 1/√(number)\nconst invertSqrt = (number: bigint) => uvRatio(_1n, number);\n\nconst MAX_255B = /* @__PURE__ */ BigInt(\n  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n);\nconst bytes255ToNumberLE = (bytes: Uint8Array) =>\n  ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n\ntype ExtendedPoint = ExtPointType;\n\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */\nfunction calcElligatorRistrettoMap(r0: bigint): ExtendedPoint {\n  const { d } = ed25519.CURVE;\n  const P = ed25519.CURVE.Fp.ORDER;\n  const mod = ed25519.CURVE.Fp.create;\n  const r = mod(SQRT_M1 * r0 * r0); // 1\n  const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n  let c = BigInt(-1); // 3\n  const D = mod((c - d * r) * mod(r + d)); // 4\n  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n  let s_ = mod(s * r0); // 6\n  if (!isNegativeLE(s_, P)) s_ = mod(-s_);\n  if (!Ns_D_is_sq) s = s_; // 7\n  if (!Ns_D_is_sq) c = r; // 8\n  const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n  const s2 = s * s;\n  const W0 = mod((s + s) * D); // 10\n  const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n  const W2 = mod(_1n - s2); // 12\n  const W3 = mod(_1n + s2); // 13\n  return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nclass RistPoint implements Group<RistPoint> {\n  static BASE: RistPoint;\n  static ZERO: RistPoint;\n  private readonly ep: ExtendedPoint;\n  // Private property to discourage combining ExtendedPoint + RistrettoPoint\n  // Always use Ristretto encoding/decoding instead.\n  constructor(ep: ExtendedPoint) {\n    this.ep = ep;\n  }\n\n  static fromAffine(ap: AffinePoint<bigint>): RistPoint {\n    return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n  }\n\n  /**\n   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n   * The hash-to-group operation applies Elligator twice and adds the results.\n   * **Note:** this is one-way map, there is no conversion from point to hash.\n   * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n   * the [website](https://ristretto.group/formulas/elligator.html).\n   * @param hex 64-byte output of a hash function\n   */\n  static hashToCurve(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHash', hex, 64);\n    const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new RistPoint(R1.add(R2));\n  }\n\n  /**\n   * Converts ristretto-encoded string to ristretto point.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n   */\n  static fromHex(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHex', hex, 32);\n    const { a, d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n    const s = bytes255ToNumberLE(hex);\n    // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n    // 3. Check that s is non-negative, or else abort\n    if (!equalBytes(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P)) throw new Error(emsg);\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2); // 4 (a is -1)\n    const u2 = mod(_1n - a * s2); // 5\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2); // 6\n    const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n    const Dx = mod(I * u2); // 8\n    const Dy = mod(I * Dx * v); // 9\n    let x = mod((s + s) * Dx); // 10\n    if (isNegativeLE(x, P)) x = mod(-x); // 10\n    const y = mod(u1 * Dy); // 11\n    const t = mod(x * y); // 12\n    if (!isValid || isNegativeLE(t, P) || y === _0n) throw new Error(emsg);\n    return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n  }\n\n  static msm(points: RistPoint[], scalars: bigint[]): RistPoint {\n    const Fn = Field(ed25519.CURVE.n, ed25519.CURVE.nBitLength);\n    return pippenger(RistPoint, Fn, points, scalars);\n  }\n\n  /**\n   * Encodes ristretto point to Uint8Array.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n   */\n  toRawBytes(): Uint8Array {\n    let { ex: x, ey: y, ez: z, et: t } = this.ep;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const u1 = mod(mod(z + y) * mod(z - y)); // 1\n    const u2 = mod(x * y); // 2\n    // Square root always exists\n    const u2sq = mod(u2 * u2);\n    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n    const D1 = mod(invsqrt * u1); // 4\n    const D2 = mod(invsqrt * u2); // 5\n    const zInv = mod(D1 * D2 * t); // 6\n    let D: bigint; // 7\n    if (isNegativeLE(t * zInv, P)) {\n      let _x = mod(y * SQRT_M1);\n      let _y = mod(x * SQRT_M1);\n      x = _x;\n      y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2; // 8\n    }\n    if (isNegativeLE(x * zInv, P)) y = mod(-y); // 9\n    let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n    if (isNegativeLE(s, P)) s = mod(-s);\n    return numberToBytesLE(s, 32); // 11\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toRawBytes());\n  }\n\n  toString(): string {\n    return this.toHex();\n  }\n\n  /**\n   * Compares two Ristretto points.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n   */\n  equals(other: RistPoint): boolean {\n    aristp(other);\n    const { ex: X1, ey: Y1 } = this.ep;\n    const { ex: X2, ey: Y2 } = other.ep;\n    const mod = ed25519.CURVE.Fp.create;\n    // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n    const one = mod(X1 * Y2) === mod(Y1 * X2);\n    const two = mod(Y1 * Y2) === mod(X1 * X2);\n    return one || two;\n  }\n\n  add(other: RistPoint): RistPoint {\n    aristp(other);\n    return new RistPoint(this.ep.add(other.ep));\n  }\n\n  subtract(other: RistPoint): RistPoint {\n    aristp(other);\n    return new RistPoint(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiplyUnsafe(scalar));\n  }\n\n  double(): RistPoint {\n    return new RistPoint(this.ep.double());\n  }\n\n  negate(): RistPoint {\n    return new RistPoint(this.ep.negate());\n  }\n}\n\n/**\n * Wrapper over Edwards Point for ristretto255 from\n * [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nexport const RistrettoPoint: typeof RistPoint = /* @__PURE__ */ (() => {\n  if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n  if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n  return RistPoint;\n})();\n\n/**\n * hash-to-curve for ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B).\n */\nexport const hashToRistretto255 = (msg: Uint8Array, options: htfBasicOpts): RistPoint => {\n  const d = options.DST;\n  const DST = typeof d === 'string' ? utf8ToBytes(d) : d;\n  const uniform_bytes = expand_message_xmd(msg, DST, 64, sha512);\n  const P = RistPoint.hashToCurve(uniform_bytes);\n  return P;\n};\n/** @deprecated */\nexport const hash_to_ristretto255: (msg: Uint8Array, options: htfBasicOpts) => RistPoint =\n  hashToRistretto255; // legacy\n", "export {};\n//# sourceMappingURL=Fee.js.map", "import type * as Address from './Address.js'\nimport type * as Block from './Block.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\n\n/** A Filter as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/filter.yaml). */\nexport type Filter<bigintType = bigint> = Compute<{\n  /** Address to filter for logs. */\n  address?: Address.Address | readonly Address.Address[] | null | undefined\n  /** Block number or tag to filter logs from. */\n  fromBlock?: Block.Number<bigintType> | Block.Tag | undefined\n  /** Block number or tag to filter logs to. */\n  toBlock?: Block.Number<bigintType> | Block.Tag | undefined\n  /** Topics to filter for logs. */\n  topics?: Topics | undefined\n}>\n\n/** RPC representation of a {@link ox#Filter.Filter}. */\nexport type Rpc = Filter<Hex.Hex>\n\n/** Set of Filter topics. */\nexport type Topics = readonly Topic[]\n\n/**\n * A filter topic.\n *\n * - `null`: Matches any topic.\n * - `Hex`: Matches if the topic is equal.\n * - `Hex[]`: Matches if the topic is in the array.\n */\nexport type Topic = Hex.Hex | readonly Hex.Hex[] | null\n\n/**\n * Converts a {@link ox#Filter.Rpc} to an {@link ox#Filter.Filter}.\n *\n * @example\n * ```ts twoslash\n * import { Filter } from 'ox'\n *\n * const filter = Filter.fromRpc({\n *   address: '0xd3cda913deb6f67967b99d671a681250403edf27',\n *   fromBlock: 'latest',\n *   toBlock: '0x010f2c',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     null,\n *     '0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1',\n *   ],\n * })\n * // @log: {\n * // @log:   address: '0xd3cda913deb6f67967b99d671a681250403edf27',\n * // @log:   fromBlock: 'latest',\n * // @log:   toBlock: 69420n,\n * // @log:   topics: [\n * // @log:     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n * // @log:     null,\n * // @log:     '0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1',\n * // @log:   ],\n * // @log: }\n * ```\n *\n * @param filter - The RPC filter to convert.\n * @returns An instantiated {@link ox#Filter.Filter}.\n */\nexport function fromRpc(filter: Rpc): Filter {\n  const { fromBlock, toBlock } = filter\n  return {\n    ...filter,\n    ...(fromBlock && {\n      fromBlock: Hex.validate(fromBlock, { strict: false })\n        ? BigInt(fromBlock)\n        : fromBlock,\n    }),\n    ...(toBlock && {\n      toBlock: Hex.validate(toBlock, { strict: false })\n        ? BigInt(toBlock)\n        : toBlock,\n    }),\n  } as Filter\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Filter.Filter} to a {@link ox#Filter.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { AbiEvent, Filter } from 'ox'\n *\n * const transfer = AbiEvent.from('event Transfer(address indexed, address indexed, uint256)')\n * const { topics } = AbiEvent.encode(transfer)\n *\n * const filter = Filter.toRpc({\n *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *   topics,\n * })\n * // @log: {\n * // @log:   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * // @log:   topics: [\n * // @log:     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n * // @log:   ],\n * // @log: }\n * ```\n *\n * @param filter - The filter to convert.\n * @returns An RPC filter.\n */\nexport function toRpc(filter: Filter): Rpc {\n  const { address, topics, fromBlock, toBlock } = filter\n  return {\n    ...(address && { address }),\n    ...(topics && { topics }),\n    ...(typeof fromBlock !== 'undefined'\n      ? {\n          fromBlock:\n            typeof fromBlock === 'bigint'\n              ? Hex.fromNumber(fromBlock)\n              : fromBlock,\n        }\n      : {}),\n    ...(typeof toBlock !== 'undefined'\n      ? {\n          toBlock:\n            typeof toBlock === 'bigint' ? Hex.fromNumber(toBlock) : toBlock,\n        }\n      : {}),\n  }\n}\n\nexport declare namespace toRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import { HDKey, type Versions } from '@scure/bip32'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport type * as Hex from './Hex.js'\nimport * as internal from './internal/hdKey.js'\nimport type * as PublicKey from './PublicKey.js'\n\n/** Root type for a Hierarchical Deterministic (HD) Key. */\nexport type HdKey = {\n  derive: (path: string) => HdKey\n  depth: number\n  index: number\n  identifier: Hex.Hex\n  privateKey: Hex.Hex\n  privateExtendedKey: string\n  publicKey: PublicKey.PublicKey<false>\n  publicExtendedKey: string\n  versions: Versions\n}\n\n/**\n * Creates a HD Key from an extended private key.\n *\n * @example\n * ```ts twoslash\n * import { HdKey } from 'ox'\n *\n * const hdKey = HdKey.fromExtendedKey('...')\n *\n * console.log(hdKey.privateKey)\n * // @log: '0x...'\n * ```\n *\n * @param extendedKey - The extended private key.\n * @returns The HD Key.\n */\nexport function fromExtendedKey(extendedKey: string): HdKey {\n  const key = HDKey.fromExtendedKey(extendedKey)\n  return internal.fromScure(key)\n}\n\nexport declare namespace fromExtendedKey {\n  type ErrorType = internal.fromScure.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Creates a HD Key from a JSON object containing an extended private key (`xpriv`).\n *\n * @example\n * ```ts twoslash\n * import { HdKey } from 'ox'\n *\n * const hdKey = HdKey.fromJson({ xpriv: '...' })\n *\n * console.log(hdKey.privateKey)\n * // @log: '0x...'\n * ```\n *\n * @param json - The JSON object containing an extended private key (`xpriv`).\n * @returns The HD Key.\n */\nexport function fromJson(json: { xpriv: string }): HdKey {\n  return internal.fromScure(HDKey.fromJSON(json))\n}\n\nexport declare namespace fromJson {\n  type ErrorType = internal.fromScure.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Creates a HD Key from a master seed.\n *\n * @example\n * ```ts twoslash\n * import { HdKey, Mnemonic } from 'ox'\n *\n * const seed = Mnemonic.toSeed('test test test test test test test test test test test junk')\n * const hdKey = HdKey.fromSeed(seed)\n * ```\n *\n * @example\n * ### Path Derivation\n *\n * You can derive a HD Key at a specific path using `derive`.\n *\n * ```ts twoslash\n * import { HdKey, Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.toSeed('test test test test test test test test test test test junk')\n * const hdKey = HdKey.fromSeed(mnemonic).derive(HdKey.path())\n *\n * console.log(hdKey.privateKey)\n * // @log: '0x...'\n * ```\n *\n * @param seed - The master seed to create the HD Key from.\n * @param options - Creation options.\n * @returns The HD Key.\n */\nexport function fromSeed(\n  seed: Hex.Hex | Bytes.Bytes,\n  options: fromSeed.Options = {},\n): HdKey {\n  const { versions } = options\n  const key = HDKey.fromMasterSeed(Bytes.from(seed), versions)\n  return internal.fromScure(key)\n}\n\nexport declare namespace fromSeed {\n  type Options = {\n    /** The versions to use for the HD Key. */\n    versions?: Versions | undefined\n  }\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | internal.fromScure.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Creates an Ethereum-based BIP-44 HD path.\n *\n * @example\n * ```ts twoslash\n * import { HdKey } from 'ox'\n *\n * const path = HdKey.path({ account: 1, index: 2 })\n * // @log: \"m/44'/60'/1'/0/2\"\n * ```\n *\n * @param options - Path options.\n * @returns The path.\n */\nexport function path(options: path.Options = {}): string {\n  const { account = 0, change = 0, index = 0 } = options\n  return `m/44'/60'/${account}'/${change}/${index}`\n}\n\nexport declare namespace path {\n  type Options = {\n    /**\n     * The account.\n     * @default 0\n     */\n    account?: number | undefined\n    /**\n     * The change.\n     * @default 0\n     */\n    change?: number | undefined\n    /**\n     * The address index.\n     * @default 0\n     */\n    index?: number | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import type { HDKey } from '@scure/bip32'\nimport type * as Errors from '../Errors.js'\nimport type * as HdKey from '../HdKey.js'\nimport * as Hex from '../Hex.js'\nimport * as Secp256k1 from '../Secp256k1.js'\n\n/** @internal */\nexport function fromScure(key: HDKey): HdKey.HdKey {\n  return {\n    derive: (path) => fromScure(key.derive(path)),\n    depth: key.depth,\n    identifier: Hex.fromBytes(key.identifier!),\n    index: key.index,\n    privateKey: Hex.fromBytes(key.privateKey!),\n    privateExtendedKey: key.privateExtendedKey,\n    publicKey: Secp256k1.getPublicKey({ privateKey: key.privateKey! }),\n    publicExtendedKey: key.publicExtendedKey,\n    versions: key.versions,\n  }\n}\n\n/** @internal */\nexport declare namespace fromScure {\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import { ctr } from '@noble/ciphers/aes'\nimport {\n  pbkdf2 as pbkdf2_noble,\n  pbkdf2Async as pbkdf2Async_noble,\n} from '@noble/hashes/pbkdf2'\nimport {\n  scrypt as scrypt_noble,\n  scryptAsync as scryptAsync_noble,\n} from '@noble/hashes/scrypt'\nimport { sha256 } from '@noble/hashes/sha2'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport type * as Hex from './Hex.js'\nimport type { OneOf } from './internal/types.js'\n\n/** Base Derivation Options. */\ntype BaseDeriveOpts<\n  kdf extends string = string,\n  kdfparams extends Record<string, unknown> = Record<string, unknown>,\n> = {\n  iv: Bytes.Bytes\n  kdfparams: kdfparams\n  kdf: kdf\n}\n\n/** Keystore. */\nexport type Keystore = {\n  crypto: {\n    cipher: 'aes-128-ctr'\n    ciphertext: string\n    cipherparams: {\n      iv: string\n    }\n    mac: string\n  } & Pick<DeriveOpts, 'kdf' | 'kdfparams'>\n  id: string\n  version: 3\n}\n\n/** Key. */\nexport type Key = (() => Hex.Hex) | Hex.Hex\n\n/** Derivation Options. */\nexport type DeriveOpts = Pbkdf2DeriveOpts | ScryptDeriveOpts\n\n/** PBKDF2 Derivation Options. */\nexport type Pbkdf2DeriveOpts = BaseDeriveOpts<\n  'pbkdf2',\n  {\n    c: number\n    dklen: number\n    prf: 'hmac-sha256'\n    salt: string\n  }\n>\n\n/** Scrypt Derivation Options. */\nexport type ScryptDeriveOpts = BaseDeriveOpts<\n  'scrypt',\n  {\n    dklen: number\n    n: number\n    p: number\n    r: number\n    salt: string\n  }\n>\n\n/**\n * Decrypts a [JSON keystore](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage/)\n * into a private key.\n *\n * Supports the following key derivation functions (KDFs):\n * - {@link ox#Keystore.(pbkdf2:function)}\n * - {@link ox#Keystore.(scrypt:function)}\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Keystore, Secp256k1 } from 'ox'\n *\n * // JSON keystore.\n * const keystore = { crypto: { ... }, id: '...', version: 3 }\n *\n * // Derive the key using your password.\n * const key = Keystore.toKey(keystore, { password: 'hunter2' })\n *\n * // Decrypt the private key.\n * const privateKey = Keystore.decrypt(keystore, key)\n * // @log: \"0x...\"\n * ```\n *\n * @param keystore - JSON keystore.\n * @param key - Key to use for decryption.\n * @param options - Decryption options.\n * @returns Decrypted private key.\n */\nexport function decrypt<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  keystore: Keystore,\n  key: Key,\n  options: decrypt.Options<as> = {},\n): decrypt.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const key_ = Bytes.from(typeof key === 'function' ? key() : key)\n\n  const encKey = Bytes.slice(key_, 0, 16)\n  const macKey = Bytes.slice(key_, 16, 32)\n\n  const ciphertext = Bytes.from(`0x${keystore.crypto.ciphertext}`)\n  const mac = Hash.keccak256(Bytes.concat(macKey, ciphertext))\n\n  if (!Bytes.isEqual(mac, Bytes.from(`0x${keystore.crypto.mac}`)))\n    throw new Error('corrupt keystore')\n\n  const data = ctr(\n    encKey,\n    Bytes.from(`0x${keystore.crypto.cipherparams.iv}`),\n  ).decrypt(ciphertext)\n\n  if (as === 'Hex') return Bytes.toHex(data) as never\n  return data as never\n}\n\nexport declare namespace decrypt {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** Output format. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Hex' ? Hex.Hex : never)\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n}\n\n/**\n * Encrypts a private key as a [JSON keystore](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage/)\n * using a derived key.\n *\n * Supports the following key derivation functions (KDFs):\n * - {@link ox#Keystore.(pbkdf2:function)}\n * - {@link ox#Keystore.(scrypt:function)}\n *\n * @example\n * ```ts twoslash\n * import { Keystore, Secp256k1 } from 'ox'\n *\n * // Generate a random private key.\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * // Derive key from password.\n * const [key, opts] = Keystore.pbkdf2({ password: 'testpassword' })\n *\n * // Encrypt the private key.\n * const encrypted = Keystore.encrypt(privateKey, key, opts)\n * // @log: {\n * // @log:   \"crypto\": {\n * // @log:     \"cipher\": \"aes-128-ctr\",\n * // @log:     \"ciphertext\": \"...\",\n * // @log:     \"cipherparams\": {\n * // @log:       \"iv\": \"...\",\n * // @log:     },\n * // @log:     \"kdf\": \"pbkdf2\",\n * // @log:     \"kdfparams\": {\n * // @log:       \"salt\": \"...\",\n * // @log:       \"dklen\": 32,\n * // @log:       \"prf\": \"hmac-sha256\",\n * // @log:       \"c\": 262144,\n * // @log:     },\n * // @log:     \"mac\": \"...\",\n * // @log:   },\n * // @log:   \"id\": \"...\",\n * // @log:   \"version\": 3,\n * // @log: }\n * ```\n *\n * @param privateKey - Private key to encrypt.\n * @param key - Key to use for encryption.\n * @param options - Encryption options.\n * @returns Encrypted keystore.\n */\nexport function encrypt(\n  privateKey: Bytes.Bytes | Hex.Hex,\n  key: Key,\n  options: encrypt.Options,\n): Keystore {\n  const { id = crypto.randomUUID(), kdf, kdfparams, iv } = options\n\n  const key_ = Bytes.from(typeof key === 'function' ? key() : key)\n  const value_ = Bytes.from(privateKey)\n\n  const encKey = Bytes.slice(key_, 0, 16)\n  const macKey = Bytes.slice(key_, 16, 32)\n\n  const ciphertext = ctr(encKey, iv).encrypt(value_)\n  const mac = Hash.keccak256(Bytes.concat(macKey, ciphertext))\n\n  return {\n    crypto: {\n      cipher: 'aes-128-ctr',\n      ciphertext: Bytes.toHex(ciphertext).slice(2),\n      cipherparams: { iv: Bytes.toHex(iv).slice(2) },\n      kdf,\n      kdfparams,\n      mac: Bytes.toHex(mac).slice(2),\n    } as Keystore['crypto'],\n    id,\n    version: 3,\n  }\n}\n\nexport declare namespace encrypt {\n  type Options = DeriveOpts & {\n    /** UUID. */\n    id?: string | undefined\n  }\n}\n\n/**\n * Derives a key from a password using [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2).\n *\n * @example\n * ```ts twoslash\n * import { Keystore } from 'ox'\n *\n * const [key, opts] = Keystore.pbkdf2({ password: 'testpassword' })\n * ```\n *\n * @param options - PBKDF2 options.\n * @returns PBKDF2 key.\n */\nexport function pbkdf2(options: pbkdf2.Options) {\n  const { iv, iterations = 262_144, password } = options\n\n  const salt = options.salt ? Bytes.from(options.salt) : Bytes.random(32)\n  const key = Bytes.toHex(\n    pbkdf2_noble(sha256, password, salt, { c: iterations, dkLen: 32 }),\n  )\n\n  return defineKey(() => key, {\n    iv,\n    kdfparams: {\n      c: iterations,\n      dklen: 32,\n      prf: 'hmac-sha256',\n      salt: Bytes.toHex(salt).slice(2),\n    },\n    kdf: 'pbkdf2',\n  }) satisfies [Key, Pbkdf2DeriveOpts]\n}\n\nexport declare namespace pbkdf2 {\n  type Options = {\n    /** The counter to use for the AES-CTR encryption. */\n    iv?: Bytes.Bytes | Hex.Hex | undefined\n    /** The number of iterations to use. @default 262_144 */\n    iterations?: number | undefined\n    /** Password to derive key from. */\n    password: string\n    /** Salt to use for key derivation. @default `Bytes.random(32)` */\n    salt?: Bytes.Bytes | Hex.Hex | undefined\n  }\n}\n\n/**\n * Derives a key from a password using [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2).\n *\n * @example\n * ```ts twoslash\n * import { Keystore } from 'ox'\n *\n * const [key, opts] = await Keystore.pbkdf2Async({ password: 'testpassword' })\n * ```\n *\n * @param options - PBKDF2 options.\n * @returns PBKDF2 key.\n */\nexport async function pbkdf2Async(options: pbkdf2.Options) {\n  const { iv, iterations = 262_144, password } = options\n\n  const salt = options.salt ? Bytes.from(options.salt) : Bytes.random(32)\n  const key = Bytes.toHex(\n    await pbkdf2Async_noble(sha256, password, salt, {\n      c: iterations,\n      dkLen: 32,\n    }),\n  )\n\n  return defineKey(() => key, {\n    iv,\n    kdfparams: {\n      c: iterations,\n      dklen: 32,\n      prf: 'hmac-sha256',\n      salt: Bytes.toHex(salt).slice(2),\n    },\n    kdf: 'pbkdf2',\n  }) satisfies [Key, Pbkdf2DeriveOpts]\n}\n\nexport declare namespace pbkdf2Async {\n  type Options = pbkdf2.Options\n}\n\n/**\n * Derives a key from a password using [scrypt](https://en.wikipedia.org/wiki/Scrypt).\n *\n * @example\n * ```ts twoslash\n * import { Keystore } from 'ox'\n *\n * const [key, opts] = Keystore.scrypt({ password: 'testpassword' })\n * ```\n *\n * @param options - Scrypt options.\n * @returns Scrypt key.\n */\nexport function scrypt(options: scrypt.Options) {\n  const { iv, n = 262_144, password, p = 8, r = 1 } = options\n\n  const salt = options.salt ? Bytes.from(options.salt) : Bytes.random(32)\n  const key = Bytes.toHex(\n    scrypt_noble(password, salt, { N: n, dkLen: 32, r, p }),\n  )\n\n  return defineKey(() => key, {\n    iv,\n    kdfparams: {\n      dklen: 32,\n      n,\n      p,\n      r,\n      salt: Bytes.toHex(salt).slice(2),\n    },\n    kdf: 'scrypt',\n  }) satisfies [Key, ScryptDeriveOpts]\n}\n\nexport declare namespace scrypt {\n  type Options = {\n    /** The counter to use for the AES-CTR encryption. */\n    iv?: Bytes.Bytes | Hex.Hex | undefined\n    /** Cost factor. @default 262_144 */\n    n?: number | undefined\n    /** Parallelization factor. @default 8 */\n    p?: number | undefined\n    /** Block size. @default 1 */\n    r?: number | undefined\n    /** Password to derive key from. */\n    password: string\n    /** Salt to use for key derivation. @default `Bytes.random(32)` */\n    salt?: Bytes.Bytes | Hex.Hex | undefined\n  }\n}\n\n/**\n * Derives a key from a password using [scrypt](https://en.wikipedia.org/wiki/Scrypt).\n *\n * @example\n * ```ts twoslash\n * import { Keystore } from 'ox'\n *\n * const [key, opts] = await Keystore.scryptAsync({ password: 'testpassword' })\n * ```\n *\n * @param options - Scrypt options.\n * @returns Scrypt key.\n */\nexport async function scryptAsync(options: scrypt.Options) {\n  const { iv, n = 262_144, password } = options\n\n  const p = 8\n  const r = 1\n\n  const salt = options.salt ? Bytes.from(options.salt) : Bytes.random(32)\n  const key = Bytes.toHex(\n    await scryptAsync_noble(password, salt, { N: n, dkLen: 32, r, p }),\n  )\n\n  return defineKey(() => key, {\n    iv,\n    kdfparams: {\n      dklen: 32,\n      n,\n      p,\n      r,\n      salt: Bytes.toHex(salt).slice(2),\n    },\n    kdf: 'scrypt',\n  }) satisfies [Key, ScryptDeriveOpts]\n}\n\nexport declare namespace scryptAsync {\n  type Options = scrypt.Options\n}\n\n/**\n * Extracts a Key from a JSON Keystore to use for decryption.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Keystore } from 'ox'\n *\n * // JSON keystore.\n * const keystore = { crypto: { ... }, id: '...', version: 3 }\n *\n * const key = Keystore.toKey(keystore, { password: 'hunter2' }) // [!code focus]\n *\n * const decrypted = Keystore.decrypt(keystore, key)\n * ```\n *\n * @param keystore - JSON Keystore\n * @param options - Options\n * @returns Key\n */\nexport function toKey(keystore: Keystore, options: toKey.Options): Key {\n  const { crypto } = keystore\n  const { password } = options\n  const { cipherparams, kdf, kdfparams } = crypto\n  const { iv } = cipherparams\n  const { c, n, p, r, salt } = kdfparams as OneOf<\n    Pbkdf2DeriveOpts['kdfparams'] | ScryptDeriveOpts['kdfparams']\n  >\n\n  const [key] = (() => {\n    switch (kdf) {\n      case 'scrypt':\n        return scrypt({\n          iv: Bytes.from(`0x${iv}`),\n          n,\n          p,\n          r,\n          salt: Bytes.from(`0x${salt}`),\n          password,\n        })\n      case 'pbkdf2':\n        return pbkdf2({\n          iv: Bytes.from(`0x${iv}`),\n          iterations: c,\n          password,\n          salt: Bytes.from(`0x${salt}`),\n        })\n      default:\n        throw new Error('unsupported kdf')\n    }\n  })()\n\n  return key\n}\n\nexport declare namespace toKey {\n  type Options = {\n    /** Password to derive key from. */\n    password: string\n  }\n}\n\n/**\n * Extracts a Key asynchronously from a JSON Keystore to use for decryption.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Keystore } from 'ox'\n *\n * // JSON keystore.\n * const keystore = { crypto: { ... }, id: '...', version: 3 }\n *\n * const key = await Keystore.toKeyAsync(keystore, { password: 'hunter2' }) // [!code focus]\n *\n * const decrypted = Keystore.decrypt(keystore, key)\n * ```\n *\n * @param keystore - JSON Keystore\n * @param options - Options\n * @returns Key\n */\nexport async function toKeyAsync(\n  keystore: Keystore,\n  options: toKeyAsync.Options,\n): Promise<Key> {\n  const { crypto } = keystore\n  const { password } = options\n  const { cipherparams, kdf, kdfparams } = crypto\n  const { iv } = cipherparams\n  const { c, n, p, r, salt } = kdfparams as OneOf<\n    Pbkdf2DeriveOpts['kdfparams'] | ScryptDeriveOpts['kdfparams']\n  >\n\n  const [key] = await (async () => {\n    switch (kdf) {\n      case 'scrypt':\n        return await scryptAsync({\n          iv: Bytes.from(`0x${iv}`),\n          n,\n          p,\n          r,\n          salt: Bytes.from(`0x${salt}`),\n          password,\n        })\n      case 'pbkdf2':\n        return await pbkdf2({\n          iv: Bytes.from(`0x${iv}`),\n          iterations: c,\n          password,\n          salt: Bytes.from(`0x${salt}`),\n        })\n      default:\n        throw new Error('unsupported kdf')\n    }\n  })()\n\n  return key\n}\n\nexport declare namespace toKeyAsync {\n  type Options = {\n    /** Password to derive key from. */\n    password: string\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////\n\n/** @internal */\n// biome-ignore lint/correctness/noUnusedVariables: _\nfunction defineKey<\n  const key extends Key,\n  const options extends defineKey.Options,\n>(key: key, options: options): [key, options & { iv: Bytes.Bytes }] {\n  const iv = options.iv ? Bytes.from(options.iv) : Bytes.random(16)\n  return [key, { ...options, iv }] as never\n}\n\n/** @internal */\ndeclare namespace defineKey {\n  type Options<\n    kdf extends string = string,\n    kdfparams extends Record<string, unknown> = Record<string, unknown>,\n  > = Omit<BaseDeriveOpts<kdf, kdfparams>, 'iv'> & {\n    iv?: Bytes.Bytes | Hex.Hex | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is boolean. */\nexport function abool(b: boolean): void {\n  if (typeof b !== 'boolean') throw new Error(`boolean expected, not ${b}`);\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/**\n * Asserts something is hash\n * TODO: remove\n * @deprecated\n */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport type IHash = {\n  (data: string | Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// Used in micro\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian\n}\n\n// Used in ff1\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\n\n// Used in micro, ff1\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n\n// TODO: remove\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async (): Promise<void> => {};\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n// TODO: remove\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: string | Uint8Array): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  else if (isBytes(data)) data = copyBytes(data);\n  else throw new Error('Uint8Array expected, got ' + typeof data);\n  return data;\n}\n\n/**\n * Checks if two U8A use same underlying buffer and overlaps.\n * This is invalid and can corrupt data.\n */\nexport function overlapBytes(a: Uint8Array, b: Uint8Array): boolean {\n  return (\n    a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy\n    a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end\n    b.byteOffset < a.byteOffset + a.byteLength // b starts before a end\n  );\n}\n\n/**\n * If input and output overlap and input starts before output, we will overwrite end of input before\n * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)\n */\nexport function complexOverlapBytes(input: Uint8Array, output: Uint8Array): void {\n  // This is very cursed. It works somehow, but I'm completely unsure,\n  // reasoning about overlapping aligned windows is very hard.\n  if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)\n    throw new Error('complex overlap of input and output is not supported');\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Used in ARX only\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts: T2\n): T1 & T2 {\n  if (opts == null || typeof opts !== 'object') throw new Error('options must be defined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Compares 2 uint8array-s in kinda constant time. */\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// TODO: remove\n/** For runtime check if class implements interface. */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: string | Uint8Array): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n}\n\n// This will allow to re-use with composable things like packed & base encoders\n// Also, we probably can make tags composable\n\n/** Sync cipher: takes byte array and returns byte array. */\nexport type Cipher = {\n  encrypt(plaintext: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array): Uint8Array;\n};\n\n/** Async cipher e.g. from built-in WebCrypto. */\nexport type AsyncCipher = {\n  encrypt(plaintext: Uint8Array): Promise<Uint8Array>;\n  decrypt(ciphertext: Uint8Array): Promise<Uint8Array>;\n};\n\n/** Cipher with `output` argument which can optimize by doing 1 less allocation. */\nexport type CipherWithOutput = Cipher & {\n  encrypt(plaintext: Uint8Array, output?: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array, output?: Uint8Array): Uint8Array;\n};\n\n/**\n * Params are outside of return type, so it is accessible before calling constructor.\n * If function support multiple nonceLength's, we return the best one.\n */\nexport type CipherParams = {\n  blockSize: number;\n  nonceLength?: number;\n  tagLength?: number;\n  varSizeNonce?: boolean;\n};\n/** ARX cipher, like salsa or chacha. */\nexport type ARXCipher = ((\n  key: Uint8Array,\n  nonce: Uint8Array,\n  AAD?: Uint8Array\n) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n};\nexport type CipherCons<T extends any[]> = (key: Uint8Array, ...args: T) => Cipher;\n/**\n * Wraps a cipher: validates args, ensures encrypt() can only be called once.\n * @__NO_SIDE_EFFECTS__\n */\nexport const wrapCipher = <C extends CipherCons<any>, P extends CipherParams>(\n  params: P,\n  constructor: C\n): C & P => {\n  function wrappedCipher(key: Uint8Array, ...args: any[]): CipherWithOutput {\n    // Validate key\n    abytes(key);\n\n    // Big-Endian hardware is rare. Just in case someone still decides to run ciphers:\n    if (!isLE) throw new Error('Non little-endian hardware is not yet supported');\n\n    // Validate nonce if nonceLength is present\n    if (params.nonceLength !== undefined) {\n      const nonce = args[0];\n      if (!nonce) throw new Error('nonce / iv required');\n      if (params.varSizeNonce) abytes(nonce);\n      else abytes(nonce, params.nonceLength);\n    }\n\n    // Validate AAD if tagLength present\n    const tagl = params.tagLength;\n    if (tagl && args[1] !== undefined) {\n      abytes(args[1]);\n    }\n\n    const cipher = constructor(key, ...args);\n    const checkOutput = (fnLength: number, output?: Uint8Array) => {\n      if (output !== undefined) {\n        if (fnLength !== 2) throw new Error('cipher output not supported');\n        abytes(output);\n      }\n    };\n    // Create wrapped cipher with validation and single-use encryption\n    let called = false;\n    const wrCipher = {\n      encrypt(data: Uint8Array, output?: Uint8Array) {\n        if (called) throw new Error('cannot encrypt() twice with same key + nonce');\n        called = true;\n        abytes(data);\n        checkOutput(cipher.encrypt.length, output);\n        return (cipher as CipherWithOutput).encrypt(data, output);\n      },\n      decrypt(data: Uint8Array, output?: Uint8Array) {\n        abytes(data);\n        if (tagl && data.length < tagl)\n          throw new Error('invalid ciphertext length: smaller than tagLength=' + tagl);\n        checkOutput(cipher.decrypt.length, output);\n        return (cipher as CipherWithOutput).decrypt(data, output);\n      },\n    };\n\n    return wrCipher;\n  }\n\n  Object.assign(wrappedCipher, params);\n  return wrappedCipher as C & P;\n};\n\n/** Represents salsa / chacha stream. */\nexport type XorStream = (\n  key: Uint8Array,\n  nonce: Uint8Array,\n  data: Uint8Array,\n  output?: Uint8Array,\n  counter?: number\n) => Uint8Array;\n\n/**\n * By default, returns u8a of length.\n * When out is available, it checks it for validity and uses it.\n */\nexport function getOutput(\n  expectedLength: number,\n  out?: Uint8Array,\n  onlyAligned = true\n): Uint8Array {\n  if (out === undefined) return new Uint8Array(expectedLength);\n  if (out.length !== expectedLength)\n    throw new Error('invalid output length, expected ' + expectedLength + ', got: ' + out.length);\n  if (onlyAligned && !isAligned32(out)) throw new Error('invalid output, must be aligned');\n  return out;\n}\n\n/** Polyfill for Safari 14. */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\nexport function u64Lengths(dataLength: number, aadLength: number, isLE: boolean): Uint8Array {\n  abool(isLE);\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  setBigUint64(view, 0, BigInt(aadLength), isLE);\n  setBigUint64(view, 8, BigInt(dataLength), isLE);\n  return num;\n}\n\n// Is byte array aligned to 4 byte offset (u32)?\nexport function isAligned32(bytes: Uint8Array): boolean {\n  return bytes.byteOffset % 4 === 0;\n}\n\n// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\nexport function copyBytes(bytes: Uint8Array): Uint8Array {\n  return Uint8Array.from(bytes);\n}\n", "/**\n * GHash from AES-GCM and its little-endian \"mirror image\" Polyval from AES-SIV.\n *\n * Implemented in terms of GHash with conversion function for keys\n * GCM GHASH from\n * [NIST SP800-38d](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf),\n * SIV from\n * [RFC 8452](https://datatracker.ietf.org/doc/html/rfc8452).\n *\n * GHASH   modulo: x^128 + x^7   + x^2   + x     + 1\n * POLYVAL modulo: x^128 + x^127 + x^126 + x^121 + 1\n *\n * @module\n */\n// prettier-ignore\nimport {\n  abytes, aexists, aoutput,\n  clean, copyBytes, createView, Hash, type Input, toBytes, u32,\n} from './utils.ts';\n\nconst BLOCK_SIZE = 16;\n// TODO: rewrite\n// temporary padding buffer\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\nconst ZEROS32 = u32(ZEROS16);\nconst POLY = 0xe1; // v = 2*v % POLY\n\n// v = 2*v % POLY\n// NOTE: because x + x = 0 (add/sub is same), mul2(x) != x+x\n// We can multiply any number using montgomery ladder and this function (works as double, add is simple xor)\nconst mul2 = (s0: number, s1: number, s2: number, s3: number) => {\n  const hiBit = s3 & 1;\n  return {\n    s3: (s2 << 31) | (s3 >>> 1),\n    s2: (s1 << 31) | (s2 >>> 1),\n    s1: (s0 << 31) | (s1 >>> 1),\n    s0: (s0 >>> 1) ^ ((POLY << 24) & -(hiBit & 1)), // reduce % poly\n  };\n};\n\nconst swapLE = (n: number) =>\n  (((n >>> 0) & 0xff) << 24) |\n  (((n >>> 8) & 0xff) << 16) |\n  (((n >>> 16) & 0xff) << 8) |\n  ((n >>> 24) & 0xff) |\n  0;\n\n/**\n * `mulX_POLYVAL(ByteReverse(H))` from spec\n * @param k mutated in place\n */\nexport function _toGHASHKey(k: Uint8Array): Uint8Array {\n  k.reverse();\n  const hiBit = k[15] & 1;\n  // k >>= 1\n  let carry = 0;\n  for (let i = 0; i < k.length; i++) {\n    const t = k[i];\n    k[i] = (t >>> 1) | carry;\n    carry = (t & 1) << 7;\n  }\n  k[0] ^= -hiBit & 0xe1; // if (hiBit) n ^= 0xe1000000000000000000000000000000;\n  return k;\n}\n\ntype Value = { s0: number; s1: number; s2: number; s3: number };\n\nconst estimateWindow = (bytes: number) => {\n  if (bytes > 64 * 1024) return 8;\n  if (bytes > 1024) return 4;\n  return 2;\n};\n\nclass GHASH implements Hash<GHASH> {\n  readonly blockLen = BLOCK_SIZE;\n  readonly outputLen = BLOCK_SIZE;\n  protected s0 = 0;\n  protected s1 = 0;\n  protected s2 = 0;\n  protected s3 = 0;\n  protected finished = false;\n  protected t: Value[];\n  private W: number;\n  private windowSize: number;\n  // We select bits per window adaptively based on expectedLength\n  constructor(key: Input, expectedLength?: number) {\n    key = toBytes(key);\n    abytes(key, 16);\n    const kView = createView(key);\n    let k0 = kView.getUint32(0, false);\n    let k1 = kView.getUint32(4, false);\n    let k2 = kView.getUint32(8, false);\n    let k3 = kView.getUint32(12, false);\n    // generate table of doubled keys (half of montgomery ladder)\n    const doubles: Value[] = [];\n    for (let i = 0; i < 128; i++) {\n      doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });\n      ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));\n    }\n    const W = estimateWindow(expectedLength || 1024);\n    if (![1, 2, 4, 8].includes(W))\n      throw new Error('ghash: invalid window size, expected 2, 4 or 8');\n    this.W = W;\n    const bits = 128; // always 128 bits;\n    const windows = bits / W;\n    const windowSize = (this.windowSize = 2 ** W);\n    const items: Value[] = [];\n    // Create precompute table for window of W bits\n    for (let w = 0; w < windows; w++) {\n      // truth table: 00, 01, 10, 11\n      for (let byte = 0; byte < windowSize; byte++) {\n        // prettier-ignore\n        let s0 = 0, s1 = 0, s2 = 0, s3 = 0;\n        for (let j = 0; j < W; j++) {\n          const bit = (byte >>> (W - j - 1)) & 1;\n          if (!bit) continue;\n          const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];\n          (s0 ^= d0), (s1 ^= d1), (s2 ^= d2), (s3 ^= d3);\n        }\n        items.push({ s0, s1, s2, s3 });\n      }\n    }\n    this.t = items;\n  }\n  protected _updateBlock(s0: number, s1: number, s2: number, s3: number) {\n    (s0 ^= this.s0), (s1 ^= this.s1), (s2 ^= this.s2), (s3 ^= this.s3);\n    const { W, t, windowSize } = this;\n    // prettier-ignore\n    let o0 = 0, o1 = 0, o2 = 0, o3 = 0;\n    const mask = (1 << W) - 1; // 2**W will kill performance.\n    let w = 0;\n    for (const num of [s0, s1, s2, s3]) {\n      for (let bytePos = 0; bytePos < 4; bytePos++) {\n        const byte = (num >>> (8 * bytePos)) & 0xff;\n        for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {\n          const bit = (byte >>> (W * bitPos)) & mask;\n          const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];\n          (o0 ^= e0), (o1 ^= e1), (o2 ^= e2), (o3 ^= e3);\n          w += 1;\n        }\n      }\n    }\n    this.s0 = o0;\n    this.s1 = o1;\n    this.s2 = o2;\n    this.s3 = o3;\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const b32 = u32(data);\n    const blocks = Math.floor(data.length / BLOCK_SIZE);\n    const left = data.length % BLOCK_SIZE;\n    for (let i = 0; i < blocks; i++) {\n      this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);\n    }\n    if (left) {\n      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n      this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);\n      clean(ZEROS32); // clean tmp buffer\n    }\n    return this;\n  }\n  destroy() {\n    const { t } = this;\n    // clean precompute table\n    for (const elm of t) {\n      (elm.s0 = 0), (elm.s1 = 0), (elm.s2 = 0), (elm.s3 = 0);\n    }\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    const { s0, s1, s2, s3 } = this;\n    const o32 = u32(out);\n    o32[0] = s0;\n    o32[1] = s1;\n    o32[2] = s2;\n    o32[3] = s3;\n    return out;\n  }\n  digest(): Uint8Array {\n    const res = new Uint8Array(BLOCK_SIZE);\n    this.digestInto(res);\n    this.destroy();\n    return res;\n  }\n}\n\nclass Polyval extends GHASH {\n  constructor(key: Input, expectedLength?: number) {\n    key = toBytes(key);\n    abytes(key);\n    const ghKey = _toGHASHKey(copyBytes(key));\n    super(ghKey, expectedLength);\n    clean(ghKey);\n  }\n  update(data: Input): this {\n    data = toBytes(data);\n    aexists(this);\n    const b32 = u32(data);\n    const left = data.length % BLOCK_SIZE;\n    const blocks = Math.floor(data.length / BLOCK_SIZE);\n    for (let i = 0; i < blocks; i++) {\n      this._updateBlock(\n        swapLE(b32[i * 4 + 3]),\n        swapLE(b32[i * 4 + 2]),\n        swapLE(b32[i * 4 + 1]),\n        swapLE(b32[i * 4 + 0])\n      );\n    }\n    if (left) {\n      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n      this._updateBlock(\n        swapLE(ZEROS32[3]),\n        swapLE(ZEROS32[2]),\n        swapLE(ZEROS32[1]),\n        swapLE(ZEROS32[0])\n      );\n      clean(ZEROS32);\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // tmp ugly hack\n    const { s0, s1, s2, s3 } = this;\n    const o32 = u32(out);\n    o32[0] = s0;\n    o32[1] = s1;\n    o32[2] = s2;\n    o32[3] = s3;\n    return out.reverse();\n  }\n}\n\nexport type CHashPV = ReturnType<typeof wrapConstructorWithKey>;\nfunction wrapConstructorWithKey<H extends Hash<H>>(\n  hashCons: (key: Input, expectedLength?: number) => Hash<H>\n): {\n  (msg: Input, key: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(key: Input, expectedLength?: number): Hash<H>;\n} {\n  const hashC = (msg: Input, key: Input): Uint8Array =>\n    hashCons(key, msg.length).update(toBytes(msg)).digest();\n  const tmp = hashCons(new Uint8Array(16), 0);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (key: Input, expectedLength?: number) => hashCons(key, expectedLength);\n  return hashC;\n}\n\n/** GHash MAC for AES-GCM. */\nexport const ghash: CHashPV = wrapConstructorWithKey(\n  (key, expectedLength) => new GHASH(key, expectedLength)\n);\n\n/** Polyval MAC for AES-SIV. */\nexport const polyval: CHashPV = wrapConstructorWithKey(\n  (key, expectedLength) => new Polyval(key, expectedLength)\n);\n", "/**\n * [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n * a.k.a. Advanced Encryption Standard\n * is a variant of Rijndael block cipher, standardized by NIST in 2001.\n * We provide the fastest available pure JS implementation.\n *\n * Data is split into 128-bit blocks. Encrypted in 10/12/14 rounds (128/192/256 bits). In every round:\n * 1. **S-box**, table substitution\n * 2. **Shift rows**, cyclic shift left of all rows of data array\n * 3. **Mix columns**, multiplying every column by fixed polynomial\n * 4. **Add round key**, round_key xor i-th column of array\n *\n * Check out [FIPS-197](https://csrc.nist.gov/files/pubs/fips/197/final/docs/fips-197.pdf)\n * and [original proposal](https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf)\n * @module\n */\nimport { ghash, polyval } from './_polyval.ts';\n// prettier-ignore\nimport {\n  abytes, clean, complexOverlapBytes, concatBytes,\n  copyBytes, createView, equalBytes, getOutput, isAligned32, overlapBytes,\n  setBigUint64, u32, u64Lengths, u8, wrapCipher,\n  type Cipher, type CipherWithOutput,\n} from './utils.ts';\n\nconst BLOCK_SIZE = 16;\nconst BLOCK_SIZE32 = 4;\nconst EMPTY_BLOCK = /* @__PURE__ */ new Uint8Array(BLOCK_SIZE);\nconst POLY = 0x11b; // 1 + x + x**3 + x**4 + x**8\n\n// TODO: remove multiplication, binary ops only\nfunction mul2(n: number) {\n  return (n << 1) ^ (POLY & -(n >> 7));\n}\n\nfunction mul(a: number, b: number) {\n  let res = 0;\n  for (; b > 0; b >>= 1) {\n    // Montgomery ladder\n    res ^= a & -(b & 1); // if (b&1) res ^=a (but const-time).\n    a = mul2(a); // a = 2*a\n  }\n  return res;\n}\n\n// AES S-box is generated using finite field inversion,\n// an affine transform, and xor of a constant 0x63.\nconst sbox = /* @__PURE__ */ (() => {\n  const t = new Uint8Array(256);\n  for (let i = 0, x = 1; i < 256; i++, x ^= mul2(x)) t[i] = x;\n  const box = new Uint8Array(256);\n  box[0] = 0x63; // first elm\n  for (let i = 0; i < 255; i++) {\n    let x = t[255 - i];\n    x |= x << 8;\n    box[t[i]] = (x ^ (x >> 4) ^ (x >> 5) ^ (x >> 6) ^ (x >> 7) ^ 0x63) & 0xff;\n  }\n  clean(t);\n  return box;\n})();\n\n// Inverted S-box\nconst invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));\n\n// Rotate u32 by 8\nconst rotr32_8 = (n: number) => (n << 24) | (n >>> 8);\nconst rotl32_8 = (n: number) => (n << 8) | (n >>> 24);\n// The byte swap operation for uint32 (LE<->BE)\nconst byteSwap = (word: number) =>\n  ((word << 24) & 0xff000000) |\n  ((word << 8) & 0xff0000) |\n  ((word >>> 8) & 0xff00) |\n  ((word >>> 24) & 0xff);\n\n// T-table is optimization suggested in 5.2 of original proposal (missed from FIPS-197). Changes:\n// - LE instead of BE\n// - bigger tables: T0 and T1 are merged into T01 table and T2 & T3 into T23;\n//   so index is u16, instead of u8. This speeds up things, unexpectedly\nfunction genTtable(sbox: Uint8Array, fn: (n: number) => number) {\n  if (sbox.length !== 256) throw new Error('Wrong sbox length');\n  const T0 = new Uint32Array(256).map((_, j) => fn(sbox[j]));\n  const T1 = T0.map(rotl32_8);\n  const T2 = T1.map(rotl32_8);\n  const T3 = T2.map(rotl32_8);\n  const T01 = new Uint32Array(256 * 256);\n  const T23 = new Uint32Array(256 * 256);\n  const sbox2 = new Uint16Array(256 * 256);\n  for (let i = 0; i < 256; i++) {\n    for (let j = 0; j < 256; j++) {\n      const idx = i * 256 + j;\n      T01[idx] = T0[i] ^ T1[j];\n      T23[idx] = T2[i] ^ T3[j];\n      sbox2[idx] = (sbox[i] << 8) | sbox[j];\n    }\n  }\n  return { sbox, sbox2, T0, T1, T2, T3, T01, T23 };\n}\n\nconst tableEncoding = /* @__PURE__ */ genTtable(\n  sbox,\n  (s: number) => (mul(s, 3) << 24) | (s << 16) | (s << 8) | mul(s, 2)\n);\nconst tableDecoding = /* @__PURE__ */ genTtable(\n  invSbox,\n  (s) => (mul(s, 11) << 24) | (mul(s, 13) << 16) | (mul(s, 9) << 8) | mul(s, 14)\n);\n\nconst xPowers = /* @__PURE__ */ (() => {\n  const p = new Uint8Array(16);\n  for (let i = 0, x = 1; i < 16; i++, x = mul2(x)) p[i] = x;\n  return p;\n})();\n\n/** Key expansion used in CTR. */\nfunction expandKeyLE(key: Uint8Array): Uint32Array {\n  abytes(key);\n  const len = key.length;\n  if (![16, 24, 32].includes(len))\n    throw new Error('aes: invalid key size, should be 16, 24 or 32, got ' + len);\n  const { sbox2 } = tableEncoding;\n  const toClean = [];\n  if (!isAligned32(key)) toClean.push((key = copyBytes(key)));\n  const k32 = u32(key);\n  const Nk = k32.length;\n  const subByte = (n: number) => applySbox(sbox2, n, n, n, n);\n  const xk = new Uint32Array(len + 28); // expanded key\n  xk.set(k32);\n  // 4.3.1 Key expansion\n  for (let i = Nk; i < xk.length; i++) {\n    let t = xk[i - 1];\n    if (i % Nk === 0) t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];\n    else if (Nk > 6 && i % Nk === 4) t = subByte(t);\n    xk[i] = xk[i - Nk] ^ t;\n  }\n  clean(...toClean);\n  return xk;\n}\n\nfunction expandKeyDecLE(key: Uint8Array): Uint32Array {\n  const encKey = expandKeyLE(key);\n  const xk = encKey.slice();\n  const Nk = encKey.length;\n  const { sbox2 } = tableEncoding;\n  const { T0, T1, T2, T3 } = tableDecoding;\n  // Inverse key by chunks of 4 (rounds)\n  for (let i = 0; i < Nk; i += 4) {\n    for (let j = 0; j < 4; j++) xk[i + j] = encKey[Nk - i - 4 + j];\n  }\n  clean(encKey);\n  // apply InvMixColumn except first & last round\n  for (let i = 4; i < Nk - 4; i++) {\n    const x = xk[i];\n    const w = applySbox(sbox2, x, x, x, x);\n    xk[i] = T0[w & 0xff] ^ T1[(w >>> 8) & 0xff] ^ T2[(w >>> 16) & 0xff] ^ T3[w >>> 24];\n  }\n  return xk;\n}\n\n// Apply tables\nfunction apply0123(\n  T01: Uint32Array,\n  T23: Uint32Array,\n  s0: number,\n  s1: number,\n  s2: number,\n  s3: number\n) {\n  return (\n    T01[((s0 << 8) & 0xff00) | ((s1 >>> 8) & 0xff)] ^\n    T23[((s2 >>> 8) & 0xff00) | ((s3 >>> 24) & 0xff)]\n  );\n}\n\nfunction applySbox(sbox2: Uint16Array, s0: number, s1: number, s2: number, s3: number) {\n  return (\n    sbox2[(s0 & 0xff) | (s1 & 0xff00)] |\n    (sbox2[((s2 >>> 16) & 0xff) | ((s3 >>> 16) & 0xff00)] << 16)\n  );\n}\n\nfunction encrypt(\n  xk: Uint32Array,\n  s0: number,\n  s1: number,\n  s2: number,\n  s3: number\n): { s0: number; s1: number; s2: number; s3: number } {\n  const { sbox2, T01, T23 } = tableEncoding;\n  let k = 0;\n  (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n  const rounds = xk.length / 4 - 2;\n  for (let i = 0; i < rounds; i++) {\n    const t0 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);\n    const t1 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);\n    const t2 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);\n    const t3 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);\n    (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n  }\n  // last round (without mixcolumns, so using SBOX2 table)\n  const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);\n  const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);\n  const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);\n  const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);\n  return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\n\n// Can't be merged with encrypt: arg positions for apply0123 / applySbox are different\nfunction decrypt(\n  xk: Uint32Array,\n  s0: number,\n  s1: number,\n  s2: number,\n  s3: number\n): {\n  s0: number;\n  s1: number;\n  s2: number;\n  s3: number;\n} {\n  const { sbox2, T01, T23 } = tableDecoding;\n  let k = 0;\n  (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n  const rounds = xk.length / 4 - 2;\n  for (let i = 0; i < rounds; i++) {\n    const t0 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);\n    const t1 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);\n    const t2 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);\n    const t3 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);\n    (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n  }\n  // Last round\n  const t0: number = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);\n  const t1: number = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);\n  const t2: number = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);\n  const t3: number = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);\n  return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\n\n// TODO: investigate merging with ctr32\nfunction ctrCounter(\n  xk: Uint32Array,\n  nonce: Uint8Array,\n  src: Uint8Array,\n  dst?: Uint8Array\n): Uint8Array {\n  abytes(nonce, BLOCK_SIZE);\n  abytes(src);\n  const srcLen = src.length;\n  dst = getOutput(srcLen, dst);\n  complexOverlapBytes(src, dst);\n  const ctr = nonce;\n  const c32 = u32(ctr);\n  // Fill block (empty, ctr=0)\n  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n  const src32 = u32(src);\n  const dst32 = u32(dst);\n  // process blocks\n  for (let i = 0; i + 4 <= src32.length; i += 4) {\n    dst32[i + 0] = src32[i + 0] ^ s0;\n    dst32[i + 1] = src32[i + 1] ^ s1;\n    dst32[i + 2] = src32[i + 2] ^ s2;\n    dst32[i + 3] = src32[i + 3] ^ s3;\n    // Full 128 bit counter with wrap around\n    let carry = 1;\n    for (let i = ctr.length - 1; i >= 0; i--) {\n      carry = (carry + (ctr[i] & 0xff)) | 0;\n      ctr[i] = carry & 0xff;\n      carry >>>= 8;\n    }\n    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n  }\n  // leftovers (less than block)\n  // It's possible to handle > u32 fast, but is it worth it?\n  const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n  if (start < srcLen) {\n    const b32 = new Uint32Array([s0, s1, s2, s3]);\n    const buf = u8(b32);\n    for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n    clean(b32);\n  }\n  return dst;\n}\n\n// AES CTR with overflowing 32 bit counter\n// It's possible to do 32le significantly simpler (and probably faster) by using u32.\n// But, we need both, and perf bottleneck is in ghash anyway.\nfunction ctr32(\n  xk: Uint32Array,\n  isLE: boolean,\n  nonce: Uint8Array,\n  src: Uint8Array,\n  dst?: Uint8Array\n): Uint8Array {\n  abytes(nonce, BLOCK_SIZE);\n  abytes(src);\n  dst = getOutput(src.length, dst);\n  const ctr = nonce; // write new value to nonce, so it can be re-used\n  const c32 = u32(ctr);\n  const view = createView(ctr);\n  const src32 = u32(src);\n  const dst32 = u32(dst);\n  const ctrPos = isLE ? 0 : 12;\n  const srcLen = src.length;\n  // Fill block (empty, ctr=0)\n  let ctrNum = view.getUint32(ctrPos, isLE); // read current counter value\n  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n  // process blocks\n  for (let i = 0; i + 4 <= src32.length; i += 4) {\n    dst32[i + 0] = src32[i + 0] ^ s0;\n    dst32[i + 1] = src32[i + 1] ^ s1;\n    dst32[i + 2] = src32[i + 2] ^ s2;\n    dst32[i + 3] = src32[i + 3] ^ s3;\n    ctrNum = (ctrNum + 1) >>> 0; // u32 wrap\n    view.setUint32(ctrPos, ctrNum, isLE);\n    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n  }\n  // leftovers (less than a block)\n  const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n  if (start < srcLen) {\n    const b32 = new Uint32Array([s0, s1, s2, s3]);\n    const buf = u8(b32);\n    for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n    clean(b32);\n  }\n  return dst;\n}\n\n/**\n * CTR: counter mode. Creates stream cipher.\n * Requires good IV. Parallelizable. OK, but no MAC.\n */\nexport const ctr: ((key: Uint8Array, nonce: Uint8Array) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function aesctr(key: Uint8Array, nonce: Uint8Array): CipherWithOutput {\n    function processCtr(buf: Uint8Array, dst?: Uint8Array) {\n      abytes(buf);\n      if (dst !== undefined) {\n        abytes(dst);\n        if (!isAligned32(dst)) throw new Error('unaligned destination');\n      }\n      const xk = expandKeyLE(key);\n      const n = copyBytes(nonce); // align + avoid changing\n      const toClean = [xk, n];\n      if (!isAligned32(buf)) toClean.push((buf = copyBytes(buf)));\n      const out = ctrCounter(xk, n, buf, dst);\n      clean(...toClean);\n      return out;\n    }\n    return {\n      encrypt: (plaintext: Uint8Array, dst?: Uint8Array) => processCtr(plaintext, dst),\n      decrypt: (ciphertext: Uint8Array, dst?: Uint8Array) => processCtr(ciphertext, dst),\n    };\n  }\n);\n\nfunction validateBlockDecrypt(data: Uint8Array) {\n  abytes(data);\n  if (data.length % BLOCK_SIZE !== 0) {\n    throw new Error(\n      'aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size ' + BLOCK_SIZE\n    );\n  }\n}\n\nfunction validateBlockEncrypt(plaintext: Uint8Array, pcks5: boolean, dst?: Uint8Array) {\n  abytes(plaintext);\n  let outLen = plaintext.length;\n  const remaining = outLen % BLOCK_SIZE;\n  if (!pcks5 && remaining !== 0)\n    throw new Error('aec/(cbc-ecb): unpadded plaintext with disabled padding');\n  if (!isAligned32(plaintext)) plaintext = copyBytes(plaintext);\n  const b = u32(plaintext);\n  if (pcks5) {\n    let left = BLOCK_SIZE - remaining;\n    if (!left) left = BLOCK_SIZE; // if no bytes left, create empty padding block\n    outLen = outLen + left;\n  }\n  dst = getOutput(outLen, dst);\n  complexOverlapBytes(plaintext, dst);\n  const o = u32(dst);\n  return { b, o, out: dst };\n}\n\nfunction validatePCKS(data: Uint8Array, pcks5: boolean) {\n  if (!pcks5) return data;\n  const len = data.length;\n  if (!len) throw new Error('aes/pcks5: empty ciphertext not allowed');\n  const lastByte = data[len - 1];\n  if (lastByte <= 0 || lastByte > 16) throw new Error('aes/pcks5: wrong padding');\n  const out = data.subarray(0, -lastByte);\n  for (let i = 0; i < lastByte; i++)\n    if (data[len - i - 1] !== lastByte) throw new Error('aes/pcks5: wrong padding');\n  return out;\n}\n\nfunction padPCKS(left: Uint8Array) {\n  const tmp = new Uint8Array(16);\n  const tmp32 = u32(tmp);\n  tmp.set(left);\n  const paddingByte = BLOCK_SIZE - left.length;\n  for (let i = BLOCK_SIZE - paddingByte; i < BLOCK_SIZE; i++) tmp[i] = paddingByte;\n  return tmp32;\n}\n\n/** Options for ECB and CBC. */\nexport type BlockOpts = { disablePadding?: boolean };\n\n/**\n * ECB: Electronic CodeBook. Simple deterministic replacement.\n * Dangerous: always map x to y. See [AES Penguin](https://words.filippo.io/the-ecb-penguin/).\n */\nexport const ecb: ((key: Uint8Array, opts?: BlockOpts) => CipherWithOutput) & {\n  blockSize: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16 },\n  function aesecb(key: Uint8Array, opts: BlockOpts = {}): CipherWithOutput {\n    const pcks5 = !opts.disablePadding;\n    return {\n      encrypt(plaintext: Uint8Array, dst?: Uint8Array) {\n        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n        const xk = expandKeyLE(key);\n        let i = 0;\n        for (; i + 4 <= b.length; ) {\n          const { s0, s1, s2, s3 } = encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        if (pcks5) {\n          const tmp32 = padPCKS(plaintext.subarray(i * 4));\n          const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        clean(xk);\n        return _out;\n      },\n      decrypt(ciphertext: Uint8Array, dst?: Uint8Array) {\n        validateBlockDecrypt(ciphertext);\n        const xk = expandKeyDecLE(key);\n        dst = getOutput(ciphertext.length, dst);\n        const toClean: (Uint8Array | Uint32Array)[] = [xk];\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        complexOverlapBytes(ciphertext, dst);\n        const b = u32(ciphertext);\n        const o = u32(dst);\n        for (let i = 0; i + 4 <= b.length; ) {\n          const { s0, s1, s2, s3 } = decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        clean(...toClean);\n        return validatePCKS(dst, pcks5);\n      },\n    };\n  }\n);\n\n/**\n * CBC: Cipher-Block-Chaining. Key is previous round’s block.\n * Fragile: needs proper padding. Unauthenticated: needs MAC.\n */\nexport const cbc: ((key: Uint8Array, iv: Uint8Array, opts?: BlockOpts) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function aescbc(key: Uint8Array, iv: Uint8Array, opts: BlockOpts = {}): CipherWithOutput {\n    const pcks5 = !opts.disablePadding;\n    return {\n      encrypt(plaintext: Uint8Array, dst?: Uint8Array) {\n        const xk = expandKeyLE(key);\n        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n        let _iv = iv;\n        const toClean: (Uint8Array | Uint32Array)[] = [xk];\n        if (!isAligned32(_iv)) toClean.push((_iv = copyBytes(_iv)));\n        const n32 = u32(_iv);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        let i = 0;\n        for (; i + 4 <= b.length; ) {\n          (s0 ^= b[i + 0]), (s1 ^= b[i + 1]), (s2 ^= b[i + 2]), (s3 ^= b[i + 3]);\n          ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        if (pcks5) {\n          const tmp32 = padPCKS(plaintext.subarray(i * 4));\n          (s0 ^= tmp32[0]), (s1 ^= tmp32[1]), (s2 ^= tmp32[2]), (s3 ^= tmp32[3]);\n          ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        clean(...toClean);\n        return _out;\n      },\n      decrypt(ciphertext: Uint8Array, dst?: Uint8Array) {\n        validateBlockDecrypt(ciphertext);\n        const xk = expandKeyDecLE(key);\n        let _iv = iv;\n        const toClean: (Uint8Array | Uint32Array)[] = [xk];\n        if (!isAligned32(_iv)) toClean.push((_iv = copyBytes(_iv)));\n        const n32 = u32(_iv);\n        dst = getOutput(ciphertext.length, dst);\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        complexOverlapBytes(ciphertext, dst);\n        const b = u32(ciphertext);\n        const o = u32(dst);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        for (let i = 0; i + 4 <= b.length; ) {\n          // prettier-ignore\n          const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;\n          (s0 = b[i + 0]), (s1 = b[i + 1]), (s2 = b[i + 2]), (s3 = b[i + 3]);\n          const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);\n          (o[i++] = o0 ^ ps0), (o[i++] = o1 ^ ps1), (o[i++] = o2 ^ ps2), (o[i++] = o3 ^ ps3);\n        }\n        clean(...toClean);\n        return validatePCKS(dst, pcks5);\n      },\n    };\n  }\n);\n\n/**\n * CFB: Cipher Feedback Mode. The input for the block cipher is the previous cipher output.\n * Unauthenticated: needs MAC.\n */\nexport const cfb: ((key: Uint8Array, iv: Uint8Array) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function aescfb(key: Uint8Array, iv: Uint8Array): CipherWithOutput {\n    function processCfb(src: Uint8Array, isEncrypt: boolean, dst?: Uint8Array) {\n      abytes(src);\n      const srcLen = src.length;\n      dst = getOutput(srcLen, dst);\n      if (overlapBytes(src, dst)) throw new Error('overlapping src and dst not supported.');\n      const xk = expandKeyLE(key);\n      let _iv = iv;\n      const toClean: (Uint8Array | Uint32Array)[] = [xk];\n      if (!isAligned32(_iv)) toClean.push((_iv = copyBytes(_iv)));\n      if (!isAligned32(src)) toClean.push((src = copyBytes(src)));\n      const src32 = u32(src);\n      const dst32 = u32(dst);\n      const next32 = isEncrypt ? dst32 : src32;\n      const n32 = u32(_iv);\n      // prettier-ignore\n      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n      for (let i = 0; i + 4 <= src32.length; ) {\n        const { s0: e0, s1: e1, s2: e2, s3: e3 } = encrypt(xk, s0, s1, s2, s3);\n        dst32[i + 0] = src32[i + 0] ^ e0;\n        dst32[i + 1] = src32[i + 1] ^ e1;\n        dst32[i + 2] = src32[i + 2] ^ e2;\n        dst32[i + 3] = src32[i + 3] ^ e3;\n        (s0 = next32[i++]), (s1 = next32[i++]), (s2 = next32[i++]), (s3 = next32[i++]);\n      }\n      // leftovers (less than block)\n      const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n      if (start < srcLen) {\n        ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n        const buf = u8(new Uint32Array([s0, s1, s2, s3]));\n        for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n        clean(buf);\n      }\n      clean(...toClean);\n      return dst;\n    }\n    return {\n      encrypt: (plaintext: Uint8Array, dst?: Uint8Array) => processCfb(plaintext, true, dst),\n      decrypt: (ciphertext: Uint8Array, dst?: Uint8Array) => processCfb(ciphertext, false, dst),\n    };\n  }\n);\n\n// TODO: merge with chacha, however gcm has bitLen while chacha has byteLen\nfunction computeTag(\n  fn: typeof ghash,\n  isLE: boolean,\n  key: Uint8Array,\n  data: Uint8Array,\n  AAD?: Uint8Array\n) {\n  const aadLength = AAD ? AAD.length : 0;\n  const h = fn.create(key, data.length + aadLength);\n  if (AAD) h.update(AAD);\n  const num = u64Lengths(8 * data.length, 8 * aadLength, isLE);\n  h.update(data);\n  h.update(num);\n  const res = h.digest();\n  clean(num);\n  return res;\n}\n\n/**\n * GCM: Galois/Counter Mode.\n * Modern, parallel version of CTR, with MAC.\n * Be careful: MACs can be forged.\n * Unsafe to use random nonces under the same key, due to collision chance.\n * As for nonce size, prefer 12-byte, instead of 8-byte.\n */\nexport const gcm: ((key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array) => Cipher) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n  varSizeNonce: true;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true },\n  function aesgcm(key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): Cipher {\n    // NIST 800-38d doesn't enforce minimum nonce length.\n    // We enforce 8 bytes for compat with openssl.\n    // 12 bytes are recommended. More than 12 bytes would be converted into 12.\n    if (nonce.length < 8) throw new Error('aes/gcm: invalid nonce length');\n    const tagLength = 16;\n    function _computeTag(authKey: Uint8Array, tagMask: Uint8Array, data: Uint8Array) {\n      const tag = computeTag(ghash, false, authKey, data, AAD);\n      for (let i = 0; i < tagMask.length; i++) tag[i] ^= tagMask[i];\n      return tag;\n    }\n    function deriveKeys() {\n      const xk = expandKeyLE(key);\n      const authKey = EMPTY_BLOCK.slice();\n      const counter = EMPTY_BLOCK.slice();\n      ctr32(xk, false, counter, counter, authKey);\n      // NIST 800-38d, page 15: different behavior for 96-bit and non-96-bit nonces\n      if (nonce.length === 12) {\n        counter.set(nonce);\n      } else {\n        const nonceLen = EMPTY_BLOCK.slice();\n        const view = createView(nonceLen);\n        setBigUint64(view, 8, BigInt(nonce.length * 8), false);\n        // ghash(nonce || u64be(0) || u64be(nonceLen*8))\n        const g = ghash.create(authKey).update(nonce).update(nonceLen);\n        g.digestInto(counter); // digestInto doesn't trigger '.destroy'\n        g.destroy();\n      }\n      const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);\n      return { xk, authKey, counter, tagMask };\n    }\n    return {\n      encrypt(plaintext: Uint8Array) {\n        const { xk, authKey, counter, tagMask } = deriveKeys();\n        const out = new Uint8Array(plaintext.length + tagLength);\n        const toClean: (Uint8Array | Uint32Array)[] = [xk, authKey, counter, tagMask];\n        if (!isAligned32(plaintext)) toClean.push((plaintext = copyBytes(plaintext)));\n        ctr32(xk, false, counter, plaintext, out.subarray(0, plaintext.length));\n        const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));\n        toClean.push(tag);\n        out.set(tag, plaintext.length);\n        clean(...toClean);\n        return out;\n      },\n      decrypt(ciphertext: Uint8Array) {\n        const { xk, authKey, counter, tagMask } = deriveKeys();\n        const toClean: (Uint8Array | Uint32Array)[] = [xk, authKey, tagMask, counter];\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        const data = ciphertext.subarray(0, -tagLength);\n        const passedTag = ciphertext.subarray(-tagLength);\n        const tag = _computeTag(authKey, tagMask, data);\n        toClean.push(tag);\n        if (!equalBytes(tag, passedTag)) throw new Error('aes/gcm: invalid ghash tag');\n        const out = ctr32(xk, false, counter, data);\n        clean(...toClean);\n        return out;\n      },\n    };\n  }\n);\n\nconst limit = (name: string, min: number, max: number) => (value: number) => {\n  if (!Number.isSafeInteger(value) || min > value || value > max) {\n    const minmax = '[' + min + '..' + max + ']';\n    throw new Error('' + name + ': expected value in range ' + minmax + ', got ' + value);\n  }\n};\n\n/**\n * AES-GCM-SIV: classic AES-GCM with nonce-misuse resistance.\n * Guarantees that, when a nonce is repeated, the only security loss is that identical\n * plaintexts will produce identical ciphertexts.\n * RFC 8452, https://datatracker.ietf.org/doc/html/rfc8452\n */\nexport const gcmsiv: ((key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array) => Cipher) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n  varSizeNonce: true;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true },\n  function aessiv(key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): Cipher {\n    const tagLength = 16;\n    // From RFC 8452: Section 6\n    const AAD_LIMIT = limit('AAD', 0, 2 ** 36);\n    const PLAIN_LIMIT = limit('plaintext', 0, 2 ** 36);\n    const NONCE_LIMIT = limit('nonce', 12, 12);\n    const CIPHER_LIMIT = limit('ciphertext', 16, 2 ** 36 + 16);\n    abytes(key, 16, 24, 32);\n    NONCE_LIMIT(nonce.length);\n    if (AAD !== undefined) AAD_LIMIT(AAD.length);\n    function deriveKeys() {\n      const xk = expandKeyLE(key);\n      const encKey = new Uint8Array(key.length);\n      const authKey = new Uint8Array(16);\n      const toClean: (Uint8Array | Uint32Array)[] = [xk, encKey];\n      let _nonce = nonce;\n      if (!isAligned32(_nonce)) toClean.push((_nonce = copyBytes(_nonce)));\n      const n32 = u32(_nonce);\n      // prettier-ignore\n      let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];\n      let counter = 0;\n      for (const derivedKey of [authKey, encKey].map(u32)) {\n        const d32 = u32(derivedKey);\n        for (let i = 0; i < d32.length; i += 2) {\n          // aes(u32le(0) || nonce)[:8] || aes(u32le(1) || nonce)[:8] ...\n          const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);\n          d32[i + 0] = o0;\n          d32[i + 1] = o1;\n          s0 = ++counter; // increment counter inside state\n        }\n      }\n      const res = { authKey, encKey: expandKeyLE(encKey) };\n      // Cleanup\n      clean(...toClean);\n      return res;\n    }\n    function _computeTag(encKey: Uint32Array, authKey: Uint8Array, data: Uint8Array) {\n      const tag = computeTag(polyval, true, authKey, data, AAD);\n      // Compute the expected tag by XORing S_s and the nonce, clearing the\n      // most significant bit of the last byte and encrypting with the\n      // message-encryption key.\n      for (let i = 0; i < 12; i++) tag[i] ^= nonce[i];\n      tag[15] &= 0x7f; // Clear the highest bit\n      // encrypt tag as block\n      const t32 = u32(tag);\n      // prettier-ignore\n      let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];\n      ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));\n      (t32[0] = s0), (t32[1] = s1), (t32[2] = s2), (t32[3] = s3);\n      return tag;\n    }\n    // actual decrypt/encrypt of message.\n    function processSiv(encKey: Uint32Array, tag: Uint8Array, input: Uint8Array) {\n      let block = copyBytes(tag);\n      block[15] |= 0x80; // Force highest bit\n      const res = ctr32(encKey, true, block, input);\n      // Cleanup\n      clean(block);\n      return res;\n    }\n    return {\n      encrypt(plaintext: Uint8Array) {\n        PLAIN_LIMIT(plaintext.length);\n        const { encKey, authKey } = deriveKeys();\n        const tag = _computeTag(encKey, authKey, plaintext);\n        const toClean: (Uint8Array | Uint32Array)[] = [encKey, authKey, tag];\n        if (!isAligned32(plaintext)) toClean.push((plaintext = copyBytes(plaintext)));\n        const out = new Uint8Array(plaintext.length + tagLength);\n        out.set(tag, plaintext.length);\n        out.set(processSiv(encKey, tag, plaintext));\n        // Cleanup\n        clean(...toClean);\n        return out;\n      },\n      decrypt(ciphertext: Uint8Array) {\n        CIPHER_LIMIT(ciphertext.length);\n        const tag = ciphertext.subarray(-tagLength);\n        const { encKey, authKey } = deriveKeys();\n        const toClean: (Uint8Array | Uint32Array)[] = [encKey, authKey];\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));\n        const expectedTag = _computeTag(encKey, authKey, plaintext);\n        toClean.push(expectedTag);\n        if (!equalBytes(tag, expectedTag)) {\n          clean(...toClean);\n          throw new Error('invalid polyval tag');\n        }\n        // Cleanup\n        clean(...toClean);\n        return plaintext;\n      },\n    };\n  }\n);\n\n/**\n * AES-GCM-SIV, not AES-SIV.\n * This is legace name, use `gcmsiv` export instead.\n * @deprecated\n */\nexport const siv: typeof gcmsiv = gcmsiv;\n\nfunction isBytes32(a: unknown): a is Uint32Array {\n  return (\n    a instanceof Uint32Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint32Array')\n  );\n}\n\nfunction encryptBlock(xk: Uint32Array, block: Uint8Array): Uint8Array {\n  abytes(block, 16);\n  if (!isBytes32(xk)) throw new Error('_encryptBlock accepts result of expandKeyLE');\n  const b32 = u32(block);\n  let { s0, s1, s2, s3 } = encrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n  (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n  return block;\n}\n\nfunction decryptBlock(xk: Uint32Array, block: Uint8Array): Uint8Array {\n  abytes(block, 16);\n  if (!isBytes32(xk)) throw new Error('_decryptBlock accepts result of expandKeyLE');\n  const b32 = u32(block);\n  let { s0, s1, s2, s3 } = decrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n  (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n  return block;\n}\n\n/**\n * AES-W (base for AESKW/AESKWP).\n * Specs: [SP800-38F](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf),\n * [RFC 3394](https://datatracker.ietf.org/doc/rfc3394/),\n * [RFC 5649](https://datatracker.ietf.org/doc/rfc5649/).\n */\nconst AESW = {\n  /*\n  High-level pseudocode:\n  ```\n  A: u64 = IV\n  out = []\n  for (let i=0, ctr = 0; i<6; i++) {\n    for (const chunk of chunks(plaintext, 8)) {\n      A ^= swapEndianess(ctr++)\n      [A, res] = chunks(encrypt(A || chunk), 8);\n      out ||= res\n    }\n  }\n  out = A || out\n  ```\n  Decrypt is the same, but reversed.\n  */\n  encrypt(kek: Uint8Array, out: Uint8Array) {\n    // Size is limited to 4GB, otherwise ctr will overflow and we'll need to switch to bigints.\n    // If you need it larger, open an issue.\n    if (out.length >= 2 ** 32) throw new Error('plaintext should be less than 4gb');\n    const xk = expandKeyLE(kek);\n    if (out.length === 16) encryptBlock(xk, out);\n    else {\n      const o32 = u32(out);\n      // prettier-ignore\n      let a0 = o32[0], a1 = o32[1]; // A\n      for (let j = 0, ctr = 1; j < 6; j++) {\n        for (let pos = 2; pos < o32.length; pos += 2, ctr++) {\n          const { s0, s1, s2, s3 } = encrypt(xk, a0, a1, o32[pos], o32[pos + 1]);\n          // A = MSB(64, B) ^ t where t = (n*j)+i\n          (a0 = s0), (a1 = s1 ^ byteSwap(ctr)), (o32[pos] = s2), (o32[pos + 1] = s3);\n        }\n      }\n      (o32[0] = a0), (o32[1] = a1); // out = A || out\n    }\n    xk.fill(0);\n  },\n  decrypt(kek: Uint8Array, out: Uint8Array) {\n    if (out.length - 8 >= 2 ** 32) throw new Error('ciphertext should be less than 4gb');\n    const xk = expandKeyDecLE(kek);\n    const chunks = out.length / 8 - 1; // first chunk is IV\n    if (chunks === 1) decryptBlock(xk, out);\n    else {\n      const o32 = u32(out);\n      // prettier-ignore\n      let a0 = o32[0], a1 = o32[1]; // A\n      for (let j = 0, ctr = chunks * 6; j < 6; j++) {\n        for (let pos = chunks * 2; pos >= 1; pos -= 2, ctr--) {\n          a1 ^= byteSwap(ctr);\n          const { s0, s1, s2, s3 } = decrypt(xk, a0, a1, o32[pos], o32[pos + 1]);\n          (a0 = s0), (a1 = s1), (o32[pos] = s2), (o32[pos + 1] = s3);\n        }\n      }\n      (o32[0] = a0), (o32[1] = a1);\n    }\n    xk.fill(0);\n  },\n};\n\nconst AESKW_IV = /* @__PURE__ */ new Uint8Array(8).fill(0xa6); // A6A6A6A6A6A6A6A6\n\n/**\n * AES-KW (key-wrap). Injects static IV into plaintext, adds counter, encrypts 6 times.\n * Reduces block size from 16 to 8 bytes.\n * For padded version, use aeskwp.\n * [RFC 3394](https://datatracker.ietf.org/doc/rfc3394/),\n * [NIST.SP.800-38F](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf).\n */\nexport const aeskw: ((kek: Uint8Array) => Cipher) & {\n  blockSize: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 8 },\n  (kek: Uint8Array): Cipher => ({\n    encrypt(plaintext: Uint8Array) {\n      if (!plaintext.length || plaintext.length % 8 !== 0)\n        throw new Error('invalid plaintext length');\n      if (plaintext.length === 8)\n        throw new Error('8-byte keys not allowed in AESKW, use AESKWP instead');\n      const out = concatBytes(AESKW_IV, plaintext);\n      AESW.encrypt(kek, out);\n      return out;\n    },\n    decrypt(ciphertext: Uint8Array) {\n      // ciphertext must be at least 24 bytes and a multiple of 8 bytes\n      // 24 because should have at least two block (1 iv + 2).\n      // Replace with 16 to enable '8-byte keys'\n      if (ciphertext.length % 8 !== 0 || ciphertext.length < 3 * 8)\n        throw new Error('invalid ciphertext length');\n      const out = copyBytes(ciphertext);\n      AESW.decrypt(kek, out);\n      if (!equalBytes(out.subarray(0, 8), AESKW_IV)) throw new Error('integrity check failed');\n      out.subarray(0, 8).fill(0); // ciphertext.subarray(0, 8) === IV, but we clean it anyway\n      return out.subarray(8);\n    },\n  })\n);\n\n/*\nWe don't support 8-byte keys. The rabbit hole:\n\n- Wycheproof says: \"NIST SP 800-38F does not define the wrapping of 8 byte keys.\n  RFC 3394 Section 2  on the other hand specifies that 8 byte keys are wrapped\n  by directly encrypting one block with AES.\"\n    - https://github.com/C2SP/wycheproof/blob/master/doc/key_wrap.md\n    - \"RFC 3394 specifies in Section 2, that the input for the key wrap\n      algorithm must be at least two blocks and otherwise the constant\n      field and key are simply encrypted with ECB as a single block\"\n- What RFC 3394 actually says (in Section 2):\n    - \"Before being wrapped, the key data is parsed into n blocks of 64 bits.\n      The only restriction the key wrap algorithm places on n is that n be\n      at least two\"\n    - \"For key data with length less than or equal to 64 bits, the constant\n      field used in this specification and the key data form a single\n      128-bit codebook input making this key wrap unnecessary.\"\n- Which means \"assert(n >= 2)\" and \"use something else for 8 byte keys\"\n- NIST SP800-38F actually prohibits 8-byte in \"5.3.1 Mandatory Limits\".\n  It states that plaintext for KW should be \"2 to 2^54 -1 semiblocks\".\n- So, where does \"directly encrypt single block with AES\" come from?\n    - Not RFC 3394. Pseudocode of key wrap in 2.2 explicitly uses\n      loop of 6 for any code path\n    - There is a weird W3C spec:\n      https://www.w3.org/TR/2002/REC-xmlenc-core-20021210/Overview.html#kw-aes128\n    - This spec is outdated, as admitted by Wycheproof authors\n    - There is RFC 5649 for padded key wrap, which is padding construction on\n      top of AESKW. In '4.1.2' it says: \"If the padded plaintext contains exactly\n      eight octets, then prepend the AIV as defined in Section 3 above to P[1] and\n      encrypt the resulting 128-bit block using AES in ECB mode [Modes] with key\n      K (the KEK).  In this case, the output is two 64-bit blocks C[0] and C[1]:\"\n    - Browser subtle crypto is actually crashes on wrapping keys less than 16 bytes:\n      `Error: error:1C8000E6:Provider routines::invalid input length] { opensslErrorStack: [ 'error:030000BD:digital envelope routines::update error' ]`\n\nIn the end, seems like a bug in Wycheproof.\nThe 8-byte check can be easily disabled inside of AES_W.\n*/\n\nconst AESKWP_IV = 0xa65959a6; // single u32le value\n\n/**\n * AES-KW, but with padding and allows random keys.\n * Second u32 of IV is used as counter for length.\n * [RFC 5649](https://www.rfc-editor.org/rfc/rfc5649)\n */\nexport const aeskwp: ((kek: Uint8Array) => Cipher) & {\n  blockSize: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 8 },\n  (kek: Uint8Array): Cipher => ({\n    encrypt(plaintext: Uint8Array) {\n      if (!plaintext.length) throw new Error('invalid plaintext length');\n      const padded = Math.ceil(plaintext.length / 8) * 8;\n      const out = new Uint8Array(8 + padded);\n      out.set(plaintext, 8);\n      const out32 = u32(out);\n      out32[0] = AESKWP_IV;\n      out32[1] = byteSwap(plaintext.length);\n      AESW.encrypt(kek, out);\n      return out;\n    },\n    decrypt(ciphertext: Uint8Array) {\n      // 16 because should have at least one block\n      if (ciphertext.length < 16) throw new Error('invalid ciphertext length');\n      const out = copyBytes(ciphertext);\n      const o32 = u32(out);\n      AESW.decrypt(kek, out);\n      const len = byteSwap(o32[1]) >>> 0;\n      const padded = Math.ceil(len / 8) * 8;\n      if (o32[0] !== AESKWP_IV || out.length - 8 !== padded)\n        throw new Error('integrity check failed');\n      for (let i = len; i < padded; i++)\n        if (out[8 + i] !== 0) throw new Error('integrity check failed');\n      out.subarray(0, 8).fill(0); // ciphertext.subarray(0, 8) === IV, but we clean it anyway\n      return out.subarray(8, 8 + len);\n    },\n  })\n);\n\n/** Unsafe low-level internal methods. May change at any time. */\nexport const unsafe: {\n  expandKeyLE: typeof expandKeyLE;\n  expandKeyDecLE: typeof expandKeyDecLE;\n  encrypt: typeof encrypt;\n  decrypt: typeof decrypt;\n  encryptBlock: typeof encryptBlock;\n  decryptBlock: typeof decryptBlock;\n  ctrCounter: typeof ctrCounter;\n  ctr32: typeof ctr32;\n} = {\n  expandKeyLE,\n  expandKeyDecLE,\n  encrypt,\n  decrypt,\n  encryptBlock,\n  decryptBlock,\n  ctrCounter,\n  ctr32,\n};\n", "/**\n * RFC 7914 Scrypt KDF. Can be used to create a key from password and salt.\n * @module\n */\nimport { pbkdf2 } from './pbkdf2.ts';\nimport { sha256 } from './sha2.ts';\n// prettier-ignore\nimport {\n  anumber, asyncLoop,\n  checkOpts, clean,\n  type KDFInput, rotl,\n  swap32IfBE,\n  u32\n} from './utils.ts';\n\n// The main Scrypt loop: uses Salsa extensively.\n// Six versions of the function were tried, this is the fastest one.\n// prettier-ignore\nfunction XorAndSalsa(\n  prev: Uint32Array,\n  pi: number,\n  input: Uint32Array,\n  ii: number,\n  out: Uint32Array,\n  oi: number\n) {\n  // Based on https://cr.yp.to/salsa20.html\n  // Xor blocks\n  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];\n  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];\n  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];\n  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];\n  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];\n  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];\n  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];\n  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];\n  // Save state to temporary variables (salsa)\n  let x00 = y00, x01 = y01, x02 = y02, x03 = y03,\n      x04 = y04, x05 = y05, x06 = y06, x07 = y07,\n      x08 = y08, x09 = y09, x10 = y10, x11 = y11,\n      x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n  // Main loop (salsa)\n  for (let i = 0; i < 8; i += 2) {\n    x04 ^= rotl(x00 + x12 | 0,  7); x08 ^= rotl(x04 + x00 | 0,  9);\n    x12 ^= rotl(x08 + x04 | 0, 13); x00 ^= rotl(x12 + x08 | 0, 18);\n    x09 ^= rotl(x05 + x01 | 0,  7); x13 ^= rotl(x09 + x05 | 0,  9);\n    x01 ^= rotl(x13 + x09 | 0, 13); x05 ^= rotl(x01 + x13 | 0, 18);\n    x14 ^= rotl(x10 + x06 | 0,  7); x02 ^= rotl(x14 + x10 | 0,  9);\n    x06 ^= rotl(x02 + x14 | 0, 13); x10 ^= rotl(x06 + x02 | 0, 18);\n    x03 ^= rotl(x15 + x11 | 0,  7); x07 ^= rotl(x03 + x15 | 0,  9);\n    x11 ^= rotl(x07 + x03 | 0, 13); x15 ^= rotl(x11 + x07 | 0, 18);\n    x01 ^= rotl(x00 + x03 | 0,  7); x02 ^= rotl(x01 + x00 | 0,  9);\n    x03 ^= rotl(x02 + x01 | 0, 13); x00 ^= rotl(x03 + x02 | 0, 18);\n    x06 ^= rotl(x05 + x04 | 0,  7); x07 ^= rotl(x06 + x05 | 0,  9);\n    x04 ^= rotl(x07 + x06 | 0, 13); x05 ^= rotl(x04 + x07 | 0, 18);\n    x11 ^= rotl(x10 + x09 | 0,  7); x08 ^= rotl(x11 + x10 | 0,  9);\n    x09 ^= rotl(x08 + x11 | 0, 13); x10 ^= rotl(x09 + x08 | 0, 18);\n    x12 ^= rotl(x15 + x14 | 0,  7); x13 ^= rotl(x12 + x15 | 0,  9);\n    x14 ^= rotl(x13 + x12 | 0, 13); x15 ^= rotl(x14 + x13 | 0, 18);\n  }\n  // Write output (salsa)\n  out[oi++] = (y00 + x00) | 0; out[oi++] = (y01 + x01) | 0;\n  out[oi++] = (y02 + x02) | 0; out[oi++] = (y03 + x03) | 0;\n  out[oi++] = (y04 + x04) | 0; out[oi++] = (y05 + x05) | 0;\n  out[oi++] = (y06 + x06) | 0; out[oi++] = (y07 + x07) | 0;\n  out[oi++] = (y08 + x08) | 0; out[oi++] = (y09 + x09) | 0;\n  out[oi++] = (y10 + x10) | 0; out[oi++] = (y11 + x11) | 0;\n  out[oi++] = (y12 + x12) | 0; out[oi++] = (y13 + x13) | 0;\n  out[oi++] = (y14 + x14) | 0; out[oi++] = (y15 + x15) | 0;\n}\n\nfunction BlockMix(input: Uint32Array, ii: number, out: Uint32Array, oi: number, r: number) {\n  // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)\n  let head = oi + 0;\n  let tail = oi + 16 * r;\n  for (let i = 0; i < 16; i++) out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X ← B[2r−1]\n  for (let i = 0; i < r; i++, head += 16, ii += 16) {\n    // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1\n    XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])\n    if (i > 0) tail += 16; // First iteration overwrites tmp value in tail\n    XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])\n  }\n}\n\nexport type ScryptOpts = {\n  N: number; // cost factor\n  r: number; // block size\n  p: number; // parallelization\n  dkLen?: number; // key length\n  asyncTick?: number; // block execution max time\n  maxmem?: number;\n  onProgress?: (progress: number) => void;\n};\n\n// Common prologue and epilogue for sync/async functions\nfunction scryptInit(password: KDFInput, salt: KDFInput, _opts?: ScryptOpts) {\n  // Maxmem - 1GB+1KB by default\n  const opts = checkOpts(\n    {\n      dkLen: 32,\n      asyncTick: 10,\n      maxmem: 1024 ** 3 + 1024,\n    },\n    _opts\n  );\n  const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;\n  anumber(N);\n  anumber(r);\n  anumber(p);\n  anumber(dkLen);\n  anumber(asyncTick);\n  anumber(maxmem);\n  if (onProgress !== undefined && typeof onProgress !== 'function')\n    throw new Error('progressCb should be function');\n  const blockSize = 128 * r;\n  const blockSize32 = blockSize / 4;\n\n  // Max N is 2^32 (Integrify is 32-bit). Real limit is 2^22: JS engines Uint8Array limit is 4GB in 2024.\n  // Spec check `N >= 2^(blockSize / 8)` is not done for compat with popular libs,\n  // which used incorrect r: 1, p: 8. Also, the check seems to be a spec error:\n  // https://www.rfc-editor.org/errata_search.php?rfc=7914\n  const pow32 = Math.pow(2, 32);\n  if (N <= 1 || (N & (N - 1)) !== 0 || N > pow32) {\n    throw new Error('Scrypt: N must be larger than 1, a power of 2, and less than 2^32');\n  }\n  if (p < 0 || p > ((pow32 - 1) * 32) / blockSize) {\n    throw new Error(\n      'Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)'\n    );\n  }\n  if (dkLen < 0 || dkLen > (pow32 - 1) * 32) {\n    throw new Error(\n      'Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32'\n    );\n  }\n  const memUsed = blockSize * (N + p);\n  if (memUsed > maxmem) {\n    throw new Error(\n      'Scrypt: memused is bigger than maxMem. Expected 128 * r * (N + p) > maxmem of ' + maxmem\n    );\n  }\n  // [B0...Bp−1] ← PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)\n  // Since it has only one iteration there is no reason to use async variant\n  const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });\n  const B32 = u32(B);\n  // Re-used between parallel iterations. Array(iterations) of B\n  const V = u32(new Uint8Array(blockSize * N));\n  const tmp = u32(new Uint8Array(blockSize));\n  let blockMixCb = () => {};\n  if (onProgress) {\n    const totalBlockMix = 2 * N * p;\n    // Invoke callback if progress changes from 10.01 to 10.02\n    // Allows to draw smooth progress bar on up to 8K screen\n    const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);\n    let blockMixCnt = 0;\n    blockMixCb = () => {\n      blockMixCnt++;\n      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))\n        onProgress(blockMixCnt / totalBlockMix);\n    };\n  }\n  return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };\n}\n\nfunction scryptOutput(\n  password: KDFInput,\n  dkLen: number,\n  B: Uint8Array,\n  V: Uint32Array,\n  tmp: Uint32Array\n) {\n  const res = pbkdf2(sha256, password, B, { c: 1, dkLen });\n  clean(B, V, tmp);\n  return res;\n}\n\n/**\n * Scrypt KDF from RFC 7914.\n * @param password - pass\n * @param salt - salt\n * @param opts - parameters\n * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)\n * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance\n * - `p` is parallelization factor (1 is common)\n * - `dkLen` is output key length in bytes e.g. 32.\n * - `asyncTick` - (default: 10) max time in ms for which async function can block execution\n * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt\n * - `onProgress` - callback function that would be executed for progress report\n * @returns Derived key\n * @example\n * scrypt('password', 'salt', { N: 2**18, r: 8, p: 1, dkLen: 32 });\n */\nexport function scrypt(password: KDFInput, salt: KDFInput, opts: ScryptOpts): Uint8Array {\n  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(\n    password,\n    salt,\n    opts\n  );\n  swap32IfBE(B32);\n  for (let pi = 0; pi < p; pi++) {\n    const Pi = blockSize32 * pi;\n    for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i]; // V[0] = B[i]\n    for (let i = 0, pos = 0; i < N - 1; i++) {\n      BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n      blockMixCb();\n    }\n    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n    blockMixCb();\n    for (let i = 0; i < N; i++) {\n      // First u32 of the last 64-byte block (u32 is LE)\n      const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n      for (let k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n      BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n      blockMixCb();\n    }\n  }\n  swap32IfBE(B32);\n  return scryptOutput(password, dkLen, B, V, tmp);\n}\n\n/**\n * Scrypt KDF from RFC 7914. Async version.\n * @example\n * await scryptAsync('password', 'salt', { N: 2**18, r: 8, p: 1, dkLen: 32 });\n */\nexport async function scryptAsync(\n  password: KDFInput,\n  salt: KDFInput,\n  opts: ScryptOpts\n): Promise<Uint8Array> {\n  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(\n    password,\n    salt,\n    opts\n  );\n  swap32IfBE(B32);\n  for (let pi = 0; pi < p; pi++) {\n    const Pi = blockSize32 * pi;\n    for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i]; // V[0] = B[i]\n    let pos = 0;\n    await asyncLoop(N - 1, asyncTick, () => {\n      BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n      blockMixCb();\n    });\n    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n    blockMixCb();\n    await asyncLoop(N, asyncTick, () => {\n      // First u32 of the last 64-byte block (u32 is LE)\n      const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n      for (let k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n      BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n      blockMixCb();\n    });\n  }\n  swap32IfBE(B32);\n  return scryptOutput(password, dkLen, B, V, tmp);\n}\n", "import {\n  generateMnemonic,\n  mnemonicToSeedSync,\n  validateMnemonic,\n} from '@scure/bip39'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as HdKey from './HdKey.js'\nimport type * as Hex from './Hex.js'\n\nexport { path } from './HdKey.js'\n\nexport {\n  czech,\n  english,\n  french,\n  italian,\n  japanese,\n  korean,\n  portuguese,\n  simplifiedChinese,\n  spanish,\n  traditionalChinese,\n} from './internal/mnemonic/wordlists.js'\n\n/**\n * Generates a random mnemonic.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * // @log: 'buyer zoo end danger ice capable shrug naive twist relief mass bonus'\n * ```\n *\n * @param wordlist - The wordlist to use.\n * @param options - Generation options.\n * @returns The mnemonic.\n */\nexport function random(\n  wordlist: string[],\n  options: random.Options = {},\n): string {\n  const { strength = 128 } = options\n  return generateMnemonic(wordlist, strength)\n}\n\nexport declare namespace random {\n  type Options = {\n    /**\n     * The strength of the mnemonic to generate, in bits.\n     * @default 128\n     */\n    strength?: number | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a mnemonic to a HD Key.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const hdKey = Mnemonic.toHdKey(mnemonic)\n * ```\n *\n * @example\n * ### Path Derivation\n *\n * You can derive a HD Key at a specific path using `derive`:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const hdKey = Mnemonic.toHdKey(mnemonic).derive(Mnemonic.path({ index: 1 }))\n * ```\n *\n * @param mnemonic - The mnemonic to convert.\n * @param options - Conversion options.\n * @returns The HD Key.\n */\nexport function toHdKey(\n  mnemonic: string,\n  options: toHdKey.Options = {},\n): HdKey.HdKey {\n  const { passphrase } = options\n  const seed = toSeed(mnemonic, { passphrase })\n  return HdKey.fromSeed(seed)\n}\n\nexport declare namespace toHdKey {\n  type Options = {\n    /** An optional passphrase for additional protection to the seed. */\n    passphrase?: string | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a mnemonic to a private key.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const privateKey = Mnemonic.toPrivateKey(mnemonic)\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Paths\n *\n * You can derive a private key at a specific path using the `path` option.\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const privateKey = Mnemonic.toPrivateKey(mnemonic, {\n *   path: Mnemonic.path({ index: 1 }) // 'm/44'/60'/0'/0/1' // [!code focus]\n * })\n * // @log: '0x...'\n * ```\n *\n * @param mnemonic - The mnemonic to convert.\n * @param options - Conversion options.\n * @returns The private key.\n */\nexport function toPrivateKey<as extends 'Bytes' | 'Hex' = 'Bytes'>(\n  mnemonic: string,\n  options: toPrivateKey.Options<as> = {},\n): toPrivateKey.ReturnType<as> {\n  const { path = HdKey.path(), passphrase } = options\n  const hdKey = toHdKey(mnemonic, { passphrase }).derive(path)\n  if (options.as === 'Bytes') return Bytes.from(hdKey.privateKey) as never\n  return hdKey.privateKey as never\n}\n\nexport declare namespace toPrivateKey {\n  type Options<as extends 'Bytes' | 'Hex' = 'Bytes'> = {\n    /** The output format. @default 'Bytes' */\n    as?: as | 'Bytes' | 'Hex' | undefined\n    /** An optional path to derive the private key from. @default `m/44'/60'/0'/0/0` */\n    path?: string | undefined\n    /** An optional passphrase for additional protection to the seed. */\n    passphrase?: string | undefined\n  }\n\n  type ReturnType<as extends 'Bytes' | 'Hex' = 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a mnemonic to a master seed.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const seed = Mnemonic.toSeed(mnemonic)\n * // @log: Uint8Array [...64 bytes]\n * ```\n *\n * @param mnemonic - The mnemonic to convert.\n * @param options - Conversion options.\n * @returns The master seed.\n */\nexport function toSeed<as extends 'Bytes' | 'Hex' = 'Bytes'>(\n  mnemonic: string,\n  options: toSeed.Options<as> = {},\n): toSeed.ReturnType<as> {\n  const { passphrase } = options\n  const seed = mnemonicToSeedSync(mnemonic, passphrase)\n  if (options.as === 'Hex') return Bytes.toHex(seed) as never\n  return seed as never\n}\n\nexport declare namespace toSeed {\n  type Options<as extends 'Bytes' | 'Hex' = 'Bytes'> = {\n    /** The output format. @default 'Bytes' */\n    as?: as | 'Bytes' | 'Hex' | undefined\n    /** An optional passphrase for additional protection to the seed. */\n    passphrase?: string | undefined\n  }\n\n  type ReturnType<as extends 'Bytes' | 'Hex' = 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Checks if a mnemonic is valid, given a wordlist.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.validate(\n *   'buyer zoo end danger ice capable shrug naive twist relief mass bonus',\n *   Mnemonic.english\n * )\n * // @log: true\n * ```\n *\n * @param mnemonic - The mnemonic to validate.\n * @param wordlist - The wordlist to use.\n * @returns Whether the mnemonic is valid.\n */\nexport function validate(mnemonic: string, wordlist: string[]): boolean {\n  return validateMnemonic(mnemonic, wordlist)\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import type * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\n\n/**\n * Encodes a personal sign message in [ERC-191 format](https://eips.ethereum.org/EIPS/eip-191#version-0x45-e): `0x19 ‖ \"Ethereum Signed Message:\\n\" + message.length ‖ message`.\n *\n * @example\n * ```ts twoslash\n * import { Hex, PersonalMessage } from 'ox'\n *\n * const data = PersonalMessage.encode(Hex.fromString('hello world'))\n * // @log: '0x19457468657265756d205369676e6564204d6573736167653a0a313168656c6c6f20776f726c64'\n * // @log: (0x19 ‖ 'Ethereum Signed Message:\\n11' ‖ 'hello world')\n * ```\n *\n * @param data - The data to encode.\n * @returns The encoded personal sign message.\n */\nexport function encode(data: Hex.Hex | Bytes.Bytes): Hex.Hex {\n  const message = Hex.from(data)\n  return Hex.concat(\n    // Personal Sign Format: `0x19 ‖ \"Ethereum Signed Message:\\n\" ‖ message.length ‖ message`\n    '0x19',\n    Hex.fromString('Ethereum Signed Message:\\n' + Hex.size(message)),\n    message,\n  )\n}\n\nexport declare namespace encode {\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.from.ErrorType\n    | Hex.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Gets the payload to use for signing an [ERC-191 formatted](https://eips.ethereum.org/EIPS/eip-191#version-0x45-e) personal message.\n *\n * @example\n * ```ts twoslash\n * import { Hex, PersonalMessage, Secp256k1 } from 'ox'\n *\n * const payload = PersonalMessage.getSignPayload(Hex.fromString('hello world')) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param data - The data to get the sign payload for.\n * @returns The payload to use for signing.\n */\nexport function getSignPayload(data: Hex.Hex | Bytes.Bytes): Hex.Hex {\n  return Hash.keccak256(encode(data))\n}\n\nexport declare namespace getSignPayload {\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | encode.ErrorType\n    | Errors.GlobalErrorType\n}\n", "import { EventEmitter } from 'eventemitter3'\nimport type * as Address from './Address.js'\nimport * as Errors from './Errors.js'\nimport type * as RpcSchema_internal from './internal/rpcSchema.js'\nimport type { Compute, IsNarrowable, IsNever } from './internal/types.js'\nimport * as RpcResponse from './RpcResponse.js'\nimport type * as RpcSchema from './RpcSchema.js'\n\n/** Options for a {@link ox#Provider.Provider}. */\nexport type Options = {\n  /**\n   * RPC Schema to use for the Provider's `request` function.\n   * See {@link ox#RpcSchema.(from:function)} for more.\n   *\n   * @default `RpcSchema.Generic`\n   */\n  schema?: RpcSchema.Generic | undefined\n}\n\n/** Root type for an EIP-1193 Provider. */\nexport type Provider<\n  options extends Options | undefined = undefined,\n  eventMap extends boolean | Record<string, unknown> = false,\n  ///\n  _schema extends RpcSchema.Generic = options extends {\n    schema: infer schema extends RpcSchema.Generic\n  }\n    ? schema\n    : RpcSchema.Default,\n> = Compute<\n  {\n    request: RequestFn<_schema>\n  } & (\n    | (eventMap extends true ? Emitter<EventMap> : never)\n    | (eventMap extends false ? Partial<Emitter<EventMap>> : never)\n    | (eventMap extends Record<string, unknown> ? Emitter<eventMap> : never)\n  )\n>\n\n/** Type for an EIP-1193 Provider's event emitter. */\nexport type Emitter<\n  eventMap extends Record<string, unknown> | undefined = undefined,\n> = Compute<EventEmitter<EventMap<eventMap>>>\n\n/** EIP-1193 Provider's `request` function. */\nexport type RequestFn<schema extends RpcSchema.Generic = RpcSchema.Generic> = <\n  methodName extends RpcSchema.MethodNameGeneric,\n>(\n  parameters: RpcSchema_internal.ExtractRequestOpaque<schema, methodName>,\n) => Promise<RpcSchema.ExtractReturnType<schema, methodName>>\n\nexport type ConnectInfo = {\n  chainId: string\n}\n\nexport type Message = {\n  type: string\n  data: unknown\n}\n\nexport class ProviderRpcError extends Error {\n  override name = 'ProviderRpcError'\n\n  code: number\n  details: string\n\n  constructor(code: number, message: string) {\n    super(message)\n    this.code = code\n    this.details = message\n  }\n}\n\nexport type EventMap<\n  eventMap extends Record<string, unknown> | undefined = undefined,\n> = {\n  accountsChanged: (accounts: readonly Address.Address[]) => void\n  chainChanged: (chainId: string) => void\n  connect: (connectInfo: ConnectInfo) => void\n  disconnect: (error: ProviderRpcError) => void\n  message: (message: Message) => void\n} & (eventMap extends Record<string, unknown> ? eventMap : {})\n\n/** The user rejected the request. */\nexport class UserRejectedRequestError extends ProviderRpcError {\n  static readonly code = 4001\n  override readonly code = 4001\n  override readonly name = 'Provider.UserRejectedRequestError'\n\n  constructor({\n    message = 'The user rejected the request.',\n  }: { message?: string | undefined } = {}) {\n    super(4001, message)\n  }\n}\n\n/** The requested method and/or account has not been authorized by the user. */\nexport class UnauthorizedError extends ProviderRpcError {\n  static readonly code = 4100\n  override readonly code = 4100\n  override readonly name = 'Provider.UnauthorizedError'\n\n  constructor({\n    message = 'The requested method and/or account has not been authorized by the user.',\n  }: { message?: string | undefined } = {}) {\n    super(4100, message)\n  }\n}\n\n/** The provider does not support the requested method. */\nexport class UnsupportedMethodError extends ProviderRpcError {\n  static readonly code = 4200\n  override readonly code = 4200\n  override readonly name = 'Provider.UnsupportedMethodError'\n\n  constructor({\n    message = 'The provider does not support the requested method.',\n  }: { message?: string | undefined } = {}) {\n    super(4200, message)\n  }\n}\n\n/** The provider is disconnected from all chains. */\nexport class DisconnectedError extends ProviderRpcError {\n  static readonly code = 4900\n  override readonly code = 4900\n  override readonly name = 'Provider.DisconnectedError'\n\n  constructor({\n    message = 'The provider is disconnected from all chains.',\n  }: { message?: string | undefined } = {}) {\n    super(4900, message)\n  }\n}\n\n/** The provider is not connected to the requested chain. */\nexport class ChainDisconnectedError extends ProviderRpcError {\n  static readonly code = 4901\n  override readonly code = 4901\n  override readonly name = 'Provider.ChainDisconnectedError'\n\n  constructor({\n    message = 'The provider is not connected to the requested chain.',\n  }: { message?: string | undefined } = {}) {\n    super(4901, message)\n  }\n}\n\n/** An error occurred when attempting to switch chain. */\nexport class SwitchChainError extends ProviderRpcError {\n  static readonly code = 4902\n  override readonly code = 4902\n  override readonly name = 'Provider.SwitchChainError'\n\n  constructor({\n    message = 'An error occurred when attempting to switch chain.',\n  }: { message?: string | undefined } = {}) {\n    super(4902, message)\n  }\n}\n\n/** This Wallet does not support a capability that was not marked as optional. */\nexport class UnsupportedNonOptionalCapabilityError extends ProviderRpcError {\n  static readonly code = 5700\n  override readonly code = 5700\n  override readonly name = 'Provider.UnsupportedNonOptionalCapabilityError'\n\n  constructor({\n    message = 'This Wallet does not support a capability that was not marked as optional.',\n  }: { message?: string | undefined } = {}) {\n    super(5700, message)\n  }\n}\n\n/** This Wallet does not support the requested chain ID. */\nexport class UnsupportedChainIdError extends ProviderRpcError {\n  static readonly code = 5710\n  override readonly code = 5710\n  override readonly name = 'Provider.UnsupportedChainIdError'\n\n  constructor({\n    message = 'This Wallet does not support the requested chain ID.',\n  }: { message?: string | undefined } = {}) {\n    super(5710, message)\n  }\n}\n\n/** There is already a bundle submitted with this ID. */\nexport class DuplicateIdError extends ProviderRpcError {\n  static readonly code = 5720\n  override readonly code = 5720\n  override readonly name = 'Provider.DuplicateIdError'\n\n  constructor({\n    message = 'There is already a bundle submitted with this ID.',\n  }: { message?: string | undefined } = {}) {\n    super(5720, message)\n  }\n}\n\n/** This bundle id is unknown / has not been submitted. */\nexport class UnknownBundleIdError extends ProviderRpcError {\n  static readonly code = 5730\n  override readonly code = 5730\n  override readonly name = 'Provider.UnknownBundleIdError'\n\n  constructor({\n    message = 'This bundle id is unknown / has not been submitted.',\n  }: { message?: string | undefined } = {}) {\n    super(5730, message)\n  }\n}\n\n/** The call bundle is too large for the Wallet to process. */\nexport class BundleTooLargeError extends ProviderRpcError {\n  static readonly code = 5740\n  override readonly code = 5740\n  override readonly name = 'Provider.BundleTooLargeError'\n\n  constructor({\n    message = 'The call bundle is too large for the Wallet to process.',\n  }: { message?: string | undefined } = {}) {\n    super(5740, message)\n  }\n}\n\n/** The Wallet can support atomicity after an upgrade, but the user rejected the upgrade. */\nexport class AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {\n  static readonly code = 5750\n  override readonly code = 5750\n  override readonly name = 'Provider.AtomicReadyWalletRejectedUpgradeError'\n\n  constructor({\n    message = 'The Wallet can support atomicity after an upgrade, but the user rejected the upgrade.',\n  }: { message?: string | undefined } = {}) {\n    super(5750, message)\n  }\n}\n\n/** The wallet does not support atomic execution but the request requires it. */\nexport class AtomicityNotSupportedError extends ProviderRpcError {\n  static readonly code = 5760\n  override readonly code = 5760\n  override readonly name = 'Provider.AtomicityNotSupportedError'\n\n  constructor({\n    message = 'The wallet does not support atomic execution but the request requires it.',\n  }: { message?: string | undefined } = {}) {\n    super(5760, message)\n  }\n}\n\n/**\n * Creates an EIP-1193 flavored event emitter to be injected onto a Provider.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox' // [!code focus]\n *\n * // 1. Instantiate a Provider Emitter. // [!code focus]\n * const emitter = Provider.createEmitter() // [!code focus]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider. // [!code focus]\n *   ...emitter, // [!code focus]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events. // [!code focus]\n * emitter.emit('accountsChanged', ['0x...']) // [!code focus]\n * ```\n *\n * @returns An event emitter.\n */\nexport function createEmitter<\n  eventMap extends Record<string, unknown> = Record<string, unknown>,\n>(): Emitter<eventMap> {\n  const emitter = new EventEmitter<EventMap<eventMap>>()\n\n  return {\n    get eventNames() {\n      return emitter.eventNames.bind(emitter)\n    },\n    get listenerCount() {\n      return emitter.listenerCount.bind(emitter)\n    },\n    get listeners() {\n      return emitter.listeners.bind(emitter)\n    },\n    addListener: emitter.addListener.bind(emitter),\n    emit: emitter.emit.bind(emitter),\n    off: emitter.off.bind(emitter),\n    on: emitter.on.bind(emitter),\n    once: emitter.once.bind(emitter),\n    removeAllListeners: emitter.removeAllListeners.bind(emitter),\n    removeListener: emitter.removeListener.bind(emitter),\n  }\n}\n\nexport declare namespace createEmitter {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates an [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) {@link ox#Provider.Provider}\n * from an arbitrary [EIP-1193 Provider](https://eips.ethereum.org/EIPS/eip-1193) interface.\n *\n * @example\n * ### Instantiating with RPC Transport\n *\n * Ox's {@link ox#RpcTransport} is EIP-1193 compliant, and can be used to instantiate an EIP-1193 Provider. This means you can use any HTTP RPC endpoint as an EIP-1193 Provider.\n *\n * ```ts twoslash\n * import { Provider, RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n * const provider = Provider.from(transport)\n * ```\n *\n * @example\n * ### Instantiating with External Providers\n *\n * The example below demonstrates how we can instantiate a typed EIP-1193 Provider from an\n * external EIP-1193 Provider like `window.ethereum`.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider } from 'ox'\n *\n * const provider = Provider.from(window.ethereum)\n *\n * const blockNumber = await provider.request({ method: 'eth_blockNumber' })\n * ```\n *\n * :::tip\n *\n * There are also libraries that distribute EIP-1193 Provider objects that you can use with `Provider.from`:\n *\n * - [`@walletconnect/ethereum-provider`](https://www.npmjs.com/package/\\@walletconnect/ethereum-provider)\n *\n * - [`@coinbase/wallet-sdk`](https://www.npmjs.com/package/\\@coinbase/wallet-sdk)\n *\n * - [`@metamask/detect-provider`](https://www.npmjs.com/package/\\@metamask/detect-provider)\n *\n * - [`@safe-global/safe-apps-provider`](https://github.com/safe-global/safe-apps-sdk/tree/main/packages/safe-apps-provider)\n *\n * - [`mipd`](https://github.com/wevm/mipd): EIP-6963 Multi Injected Providers\n *\n * :::\n *\n * @example\n * ### Instantiating a Custom Provider\n *\n * The example below demonstrates how we can instantiate a typed EIP-1193 Provider from a\n * HTTP `fetch` JSON-RPC request. You can use this pattern to integrate with any asynchronous JSON-RPC\n * transport, including WebSockets and IPC.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * const blockNumber = await provider.request({ method: 'eth_blockNumber' })\n * ```\n *\n * @example\n * ### Type-safe Custom Schemas\n *\n * It is possible to define your own type-safe schema by using the {@link ox#RpcSchema.(from:function)} type.\n *\n * ```ts twoslash\n * // @noErrors\n * import 'ox/window'\n * import { Provider, RpcSchema } from 'ox'\n *\n * const schema = RpcSchema.from<\n *   | RpcSchema.Default\n *   | {\n *       Request: {\n *         method: 'abe_foo',\n *         params: [id: number],\n *       }\n *       ReturnType: string\n *     }\n *   | {\n *       Request: {\n *         method: 'abe_bar',\n *         params: [id: string],\n *       }\n *       ReturnType: string\n *     }\n * >()\n *\n * const provider = Provider.from(window.ethereum, { schema })\n *\n * const blockNumber = await provider.request({ method: 'e' })\n * //                                                    ^|\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating a Provider with Events\n *\n * The example below demonstrates how to instantiate a Provider with your own EIP-1193 flavored event emitter.\n *\n * This example is useful for Wallets that distribute an EIP-1193 Provider (e.g. webpage injection via `window.ethereum`).\n *\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Instantiate a Provider Emitter.\n * const emitter = Provider.createEmitter() // [!code ++]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider.\n *   ...emitter, // [!code ++]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events.\n * emitter.emit('accountsChanged', ['0x...']) // [!code ++]\n * ```\n *\n * @param provider - The EIP-1193 provider to convert.\n * @returns An typed EIP-1193 Provider.\n */\nexport function from<\n  options extends Options | undefined,\n  //\n  provider extends from.Value<options> | undefined = undefined,\n>(\n  provider: provider | from.Value<options> | undefined,\n  options?: options | Options,\n): from.ReturnType<options, provider>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function from(provider: any, _options: Options = {}): Provider {\n  if (!provider) throw new IsUndefinedError()\n  return {\n    ...provider,\n    async request(args) {\n      try {\n        const result = await provider.request(args)\n        if (\n          result &&\n          typeof result === 'object' &&\n          'jsonrpc' in (result as { jsonrpc?: unknown })\n        )\n          return RpcResponse.parse(result) as never\n        return result\n      } catch (error) {\n        throw parseError(error)\n      }\n    },\n  }\n}\n\nexport declare namespace from {\n  type Value<options extends Options | undefined = undefined> = Partial<\n    Emitter<any>\n  > & {\n    request: (\n      parameters: options extends {\n        schema: infer schema extends RpcSchema.Generic\n      }\n        ? schema['Request']\n        : RpcSchema.Generic['Request'],\n    ) => unknown\n  }\n\n  type ReturnType<\n    options extends Options | undefined = Options | undefined,\n    provider extends from.Value<options> | undefined =\n      | from.Value<options>\n      | undefined,\n  > = Omit<provider, 'request'> & {\n    request: RequestFn<\n      options extends { schema: infer schema extends RpcSchema.Generic }\n        ? schema\n        : RpcSchema.Default\n    >\n  }\n\n  type ErrorType = IsUndefinedError | Errors.GlobalErrorType\n}\n\n/**\n * Parses an error into a Provider error instance.\n *\n * @example\n * ```ts twoslash\n * import { Provider } from 'ox'\n *\n * const error = Provider.parseError({ code: 4200, message: 'foo' })\n *\n * error\n * // ^?\n *\n * ```\n *\n * @param error - The error object to parse.\n * @returns An error instance.\n */\nexport function parseError<\n  const error extends RpcResponse.ErrorObject | Error | unknown,\n>(\n  error: error | Error | RpcResponse.ErrorObject,\n): parseError.ReturnType<error> {\n  const error_ = RpcResponse.parseError(error)\n  if (error_ instanceof RpcResponse.InternalError) {\n    if (!error_.data) return error_ as never\n\n    const { code } = error_.data as RpcResponse.ErrorObject\n    if (code === DisconnectedError.code)\n      return new DisconnectedError(error_) as never\n    if (code === ChainDisconnectedError.code)\n      return new ChainDisconnectedError(error_) as never\n    if (code === UserRejectedRequestError.code)\n      return new UserRejectedRequestError(error_) as never\n    if (code === UnauthorizedError.code)\n      return new UnauthorizedError(error_) as never\n    if (code === UnsupportedMethodError.code)\n      return new UnsupportedMethodError(error_) as never\n    if (code === SwitchChainError.code)\n      return new SwitchChainError(error_) as never\n    if (code === AtomicReadyWalletRejectedUpgradeError.code)\n      return new AtomicReadyWalletRejectedUpgradeError(error_) as never\n    if (code === AtomicityNotSupportedError.code)\n      return new AtomicityNotSupportedError(error_) as never\n    if (code === BundleTooLargeError.code)\n      return new BundleTooLargeError(error_) as never\n    if (code === UnknownBundleIdError.code)\n      return new UnknownBundleIdError(error_) as never\n    if (code === DuplicateIdError.code)\n      return new DuplicateIdError(error_) as never\n    if (code === UnsupportedChainIdError.code)\n      return new UnsupportedChainIdError(error_) as never\n    if (code === UnsupportedNonOptionalCapabilityError.code)\n      return new UnsupportedNonOptionalCapabilityError(error_) as never\n  }\n  return error_ as never\n}\n\nexport declare namespace parseError {\n  type ReturnType<\n    errorObject extends RpcResponse.ErrorObject | unknown,\n    //\n    error = errorObject extends RpcResponse.ErrorObject\n      ?\n          | (errorObject['code'] extends DisconnectedError['code']\n              ? DisconnectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? DisconnectedError\n              : never)\n          | (errorObject['code'] extends ChainDisconnectedError['code']\n              ? ChainDisconnectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ChainDisconnectedError\n              : never)\n          | (errorObject['code'] extends UserRejectedRequestError['code']\n              ? UserRejectedRequestError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UserRejectedRequestError\n              : never)\n          | (errorObject['code'] extends UnauthorizedError['code']\n              ? UnauthorizedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnauthorizedError\n              : never)\n          | (errorObject['code'] extends UnsupportedMethodError['code']\n              ? UnsupportedMethodError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnsupportedMethodError\n              : never)\n          | (errorObject['code'] extends SwitchChainError['code']\n              ? SwitchChainError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? SwitchChainError\n              : never)\n          | (errorObject['code'] extends AtomicReadyWalletRejectedUpgradeError['code']\n              ? AtomicReadyWalletRejectedUpgradeError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? AtomicReadyWalletRejectedUpgradeError\n              : never)\n          | (errorObject['code'] extends AtomicityNotSupportedError['code']\n              ? AtomicityNotSupportedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? AtomicityNotSupportedError\n              : never)\n          | (errorObject['code'] extends BundleTooLargeError['code']\n              ? BundleTooLargeError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? BundleTooLargeError\n              : never)\n          | (errorObject['code'] extends UnknownBundleIdError['code']\n              ? UnknownBundleIdError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnknownBundleIdError\n              : never)\n          | (errorObject['code'] extends DuplicateIdError['code']\n              ? DuplicateIdError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? DuplicateIdError\n              : never)\n          | (errorObject['code'] extends UnsupportedChainIdError['code']\n              ? UnsupportedChainIdError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnsupportedChainIdError\n              : never)\n          | (errorObject['code'] extends UnsupportedNonOptionalCapabilityError['code']\n              ? UnsupportedNonOptionalCapabilityError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnsupportedNonOptionalCapabilityError\n              : never)\n      : RpcResponse.parseError.ReturnType<RpcResponse.ErrorObject>,\n  > = IsNever<error> extends true\n    ? RpcResponse.parseError.ReturnType<errorObject>\n    : error\n}\n\n/** Thrown when the provider is undefined. */\nexport class IsUndefinedError extends Errors.BaseError {\n  override readonly name = 'Provider.IsUndefinedError'\n\n  constructor() {\n    super('`provider` is undefined.')\n  }\n}\n", "import type { Errors, RpcRequest } from '../index.js'\nimport type {\n  Compute,\n  IsNarrowable,\n  IsNever,\n  OneOf,\n  UnionPartialBy,\n} from './internal/types.js'\n\n/** A JSON-RPC response object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object). */\nexport type RpcResponse<\n  result = unknown,\n  error extends ErrorObject = ErrorObject,\n> = Compute<\n  {\n    id: number\n    jsonrpc: '2.0'\n  } & OneOf<{ result: result } | { error: error }>\n>\n\n/** JSON-RPC error object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#error_object). */\nexport type ErrorObject = {\n  code: number\n  message: string\n  data?: unknown | undefined\n}\n\n/**\n * A type-safe interface to instantiate a JSON-RPC response object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#response_object).\n *\n * @example\n * ### Instantiating a Response Object\n *\n * ```ts twoslash\n * import { RpcResponse } from 'ox'\n *\n * const response = RpcResponse.from({\n *   id: 0,\n *   jsonrpc: '2.0',\n *   result: '0x69420',\n * })\n * ```\n *\n * @example\n * ### Type-safe Instantiation\n *\n * If you have a JSON-RPC request object, you can use it to strongly-type the response. If a `request` is provided,\n * then the `id` and `jsonrpc` properties will be overridden with the values from the request.\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * const request = RpcRequest.from({ id: 0, method: 'eth_blockNumber' })\n *\n * const response = RpcResponse.from(\n *   { result: '0x69420' },\n *   { request },\n * )\n * ```\n *\n * @param response - Opaque JSON-RPC response object.\n * @param options - Parsing options.\n * @returns Typed JSON-RPC result, or response object (if `raw` is `true`).\n */\nexport function from<\n  request extends RpcRequest.RpcRequest | undefined = undefined,\n  const response =\n    | (request extends RpcRequest.RpcRequest\n        ? request['_returnType']\n        : RpcResponse)\n    | unknown,\n>(\n  response: from.Response<request, response>,\n  options?: from.Options<request>,\n): Compute<from.ReturnType<response>>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function from(response: RpcResponse, options: any = {}): RpcResponse {\n  const { request } = options\n  return {\n    ...response,\n    id: response.id ?? request?.id,\n    jsonrpc: response.jsonrpc ?? request.jsonrpc,\n  }\n}\n\nexport declare namespace from {\n  type Response<\n    request extends RpcRequest.RpcRequest | undefined = undefined,\n    response = unknown,\n  > = response &\n    (request extends RpcRequest.RpcRequest\n      ? UnionPartialBy<RpcResponse<request['_returnType']>, 'id' | 'jsonrpc'>\n      : RpcResponse)\n\n  type Options<\n    request extends RpcRequest.RpcRequest | undefined =\n      | RpcRequest.RpcRequest\n      | undefined,\n  > = {\n    request?: request | RpcRequest.RpcRequest | undefined\n  }\n\n  type ReturnType<response> = IsNarrowable<response, RpcResponse> extends true\n    ? RpcResponse\n    : response & Readonly<{ id: number; jsonrpc: '2.0' }>\n}\n\n/**\n * A type-safe interface to parse a JSON-RPC response object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#response_object), and extract the result.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Create a request store.\n * const store = RpcRequest.createStore()\n *\n * // 2. Get a request object.\n * const request = store.prepare({\n *   method: 'eth_getBlockByNumber',\n *   params: ['0x1', false],\n * })\n *\n * // 3. Send the JSON-RPC request via HTTP.\n * const block = await fetch('https://1.rpc.thirdweb.com', {\n *   body: JSON.stringify(request),\n *   headers: {\n *     'Content-Type': 'application/json',\n *   },\n *   method: 'POST',\n * })\n *  .then((response) => response.json())\n *  // 4. Parse the JSON-RPC response into a type-safe result. // [!code focus]\n *  .then((response) => RpcResponse.parse(response, { request })) // [!code focus]\n *\n * block // [!code focus]\n * // ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::tip\n *\n * If you don't need the return type, you can omit the options entirely.\n *\n * ```ts twoslash\n * // @noErrors\n * import { RpcResponse } from 'ox'\n *\n * const block = await fetch('https://1.rpc.thirdweb.com', {})\n *  .then((response) => response.json())\n *  .then((response) => RpcResponse.parse(response, { request })) // [!code --]\n *  .then(RpcResponse.parse) // [!code ++]\n * ```\n * :::\n *\n * @example\n * ### Raw Mode\n *\n * If `raw` is `true`, the response will be returned as an object with `result` and `error` properties instead of returning the `result` directly and throwing errors.\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const request = store.prepare({\n *   method: 'eth_blockNumber',\n * })\n *\n * const response = RpcResponse.parse({}, {\n *   request,\n *   raw: true, // [!code hl]\n * })\n *\n * response.result\n * //       ^?\n *\n *\n * response.error\n * //       ^?\n *\n *\n * ```\n *\n * @param response - Opaque JSON-RPC response object.\n * @param options - Parsing options.\n * @returns Typed JSON-RPC result, or response object (if `raw` is `true`).\n */\nexport function parse<\n  const response extends RpcResponse | unknown,\n  returnType,\n  raw extends boolean = false,\n>(\n  response: response,\n  options: parse.Options<returnType, raw> = {},\n): parse.ReturnType<\n  unknown extends response\n    ? returnType\n    : response extends RpcResponse\n      ? response extends { result: infer result }\n        ? result\n        : never\n      : returnType,\n  raw\n> {\n  const { raw = false } = options\n  const response_ = response as RpcResponse\n  if (raw) return response as never\n  if (response_.error) throw parseError(response_.error)\n  return response_.result as never\n}\n\nexport declare namespace parse {\n  type Options<returnType, raw extends boolean = false> = {\n    /**\n     * JSON-RPC Method that was used to make the request. Used for typing the response.\n     */\n    request?:\n      | {\n          _returnType: returnType\n        }\n      | RpcRequest.RpcRequest\n      | undefined\n    /**\n     * Enables raw mode – responses will return an object with `result` and `error` properties instead of returning the `result` directly and throwing errors.\n     *\n     * - `true`: a JSON-RPC response object will be returned with `result` and `error` properties.\n     * - `false`: the JSON-RPC response object's `result` property will be returned directly, and JSON-RPC Errors will be thrown.\n     *\n     * @default false\n     */\n    raw?: raw | boolean | undefined\n  }\n\n  type ReturnType<returnType, raw extends boolean = false> = Compute<\n    raw extends true ? RpcResponse<returnType> : returnType\n  >\n\n  type ErrorType =\n    | ParseError\n    | InvalidInputError\n    | ResourceNotFoundError\n    | ResourceUnavailableError\n    | TransactionRejectedError\n    | MethodNotSupportedError\n    | LimitExceededError\n    | VersionNotSupportedError\n    | InvalidRequestError\n    | MethodNotFoundError\n    | InvalidParamsError\n    | InternalError\n    | BaseErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Parses an error into a RPC Error instance.\n *\n * @example\n * ```ts twoslash\n * import { RpcResponse } from 'ox'\n *\n * const error = RpcResponse.parseError({ code: -32000, message: 'unsupported method' })\n *\n * error\n * // ^?\n *\n * ```\n *\n * @param error - Error.\n * @returns RPC Error instance.\n */\nexport function parseError<const error extends Error | ErrorObject | unknown>(\n  error: error | Error | ErrorObject,\n): parseError.ReturnType<error> {\n  const error_ = error as Error | ErrorObject\n\n  if (error_ instanceof Error && !('code' in error_))\n    return new InternalError({\n      cause: error_,\n      data: error_,\n      message: error_.message,\n      stack: error_.stack,\n    }) as never\n\n  const { code } = error_\n  if (code === InternalError.code)\n    return new InternalError(error_ as never) as never\n  if (code === InvalidInputError.code)\n    return new InvalidInputError(error_) as never\n  if (code === InvalidParamsError.code)\n    return new InvalidParamsError(error_) as never\n  if (code === InvalidRequestError.code)\n    return new InvalidRequestError(error_) as never\n  if (code === LimitExceededError.code)\n    return new LimitExceededError(error_) as never\n  if (code === MethodNotFoundError.code)\n    return new MethodNotFoundError(error_) as never\n  if (code === MethodNotSupportedError.code)\n    return new MethodNotSupportedError(error_) as never\n  if (code === ParseError.code) return new ParseError(error_) as never\n  if (code === ResourceNotFoundError.code)\n    return new ResourceNotFoundError(error_) as never\n  if (code === ResourceUnavailableError.code)\n    return new ResourceUnavailableError(error_) as never\n  if (code === TransactionRejectedError.code)\n    return new TransactionRejectedError(error_) as never\n  if (code === VersionNotSupportedError.code)\n    return new VersionNotSupportedError(error_) as never\n  return new InternalError({\n    cause: error_ instanceof Error ? error_ : undefined,\n    data: error_,\n    message: error_.message,\n    stack: error_ instanceof Error ? error_.stack : undefined,\n  }) as never\n}\n\nexport declare namespace parseError {\n  type ReturnType<\n    errorObject extends ErrorObject | unknown,\n    //\n    error = errorObject extends ErrorObject\n      ?\n          | (errorObject['code'] extends InternalError['code']\n              ? InternalError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InternalError\n              : never)\n          | (errorObject['code'] extends InvalidInputError['code']\n              ? InvalidInputError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InvalidInputError\n              : never)\n          | (errorObject['code'] extends ResourceNotFoundError['code']\n              ? ResourceNotFoundError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ResourceNotFoundError\n              : never)\n          | (errorObject['code'] extends ResourceUnavailableError['code']\n              ? ResourceUnavailableError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ResourceUnavailableError\n              : never)\n          | (errorObject['code'] extends TransactionRejectedError['code']\n              ? TransactionRejectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? TransactionRejectedError\n              : never)\n          | (errorObject['code'] extends ParseError['code']\n              ? ParseError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ParseError\n              : never)\n          | (errorObject['code'] extends MethodNotSupportedError['code']\n              ? MethodNotSupportedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? MethodNotSupportedError\n              : never)\n          | (errorObject['code'] extends LimitExceededError['code']\n              ? LimitExceededError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? LimitExceededError\n              : never)\n          | (errorObject['code'] extends VersionNotSupportedError['code']\n              ? VersionNotSupportedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? VersionNotSupportedError\n              : never)\n          | (errorObject['code'] extends InvalidRequestError['code']\n              ? InvalidRequestError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InvalidRequestError\n              : never)\n          | (errorObject['code'] extends MethodNotFoundError['code']\n              ? MethodNotFoundError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? MethodNotFoundError\n              : never)\n          | (errorObject['code'] extends InvalidParamsError['code']\n              ? InvalidParamsError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InvalidParamsError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? BaseError\n              : never)\n      : parseError.ReturnType<ErrorObject>,\n  > = IsNever<error> extends true ? BaseError : error\n}\n\nexport type BaseErrorType = BaseError & { name: 'BaseError' }\n\n/** Thrown when a JSON-RPC error has occurred. */\nexport class BaseError extends Error {\n  override name = 'RpcResponse.BaseError'\n\n  override readonly cause: Error | undefined\n  override readonly stack: string\n  readonly code: number\n  readonly data?: unknown | undefined\n\n  constructor(\n    errorObject: ErrorObject & {\n      cause?: Error | undefined\n      stack?: string | undefined\n    },\n  ) {\n    const { cause, code, message, data, stack } = errorObject\n\n    super(message, { cause })\n\n    this.cause = cause\n    this.code = code\n    this.data = data\n    this.stack = stack ?? ''\n  }\n}\n\n/** Thrown when the input to a JSON-RPC method is invalid. */\nexport class InvalidInputError extends BaseError {\n  static readonly code = -32000\n  override readonly code = -32000\n  override readonly name = 'RpcResponse.InvalidInputError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: InvalidInputError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Missing or invalid parameters.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC resource is not found. */\nexport class ResourceNotFoundError extends BaseError {\n  static readonly code = -32001\n  override readonly code = -32001\n  override readonly name = 'RpcResponse.ResourceNotFoundError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: ResourceNotFoundError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Requested resource not found.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC resource is unavailable. */\nexport class ResourceUnavailableError extends BaseError {\n  static readonly code = -32002\n  override readonly code = -32002\n  override readonly name = 'RpcResponse.ResourceUnavailableError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: ResourceUnavailableError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Requested resource not available.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC transaction is rejected. */\nexport class TransactionRejectedError extends BaseError {\n  static readonly code = -32003\n  override readonly code = -32003\n  override readonly name = 'RpcResponse.TransactionRejectedError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: TransactionRejectedError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Transaction creation failed.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC method is not supported. */\nexport class MethodNotSupportedError extends BaseError {\n  static readonly code = -32004\n  override readonly code = -32004\n  override readonly name = 'RpcResponse.MethodNotSupportedError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: MethodNotSupportedError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Method is not implemented.',\n    })\n  }\n}\n\n/** Thrown when a rate-limit is exceeded. */\nexport class LimitExceededError extends BaseError {\n  static readonly code = -32005\n  override readonly code = -32005\n  override readonly name = 'RpcResponse.LimitExceededError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: LimitExceededError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Rate limit exceeded.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC version is not supported. */\nexport class VersionNotSupportedError extends BaseError {\n  static readonly code = -32006\n  override readonly code = -32006\n  override readonly name = 'RpcResponse.VersionNotSupportedError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: VersionNotSupportedError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'JSON-RPC version not supported.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC request is invalid. */\nexport class InvalidRequestError extends BaseError {\n  static readonly code = -32600\n  override readonly code = -32600\n  override readonly name = 'RpcResponse.InvalidRequestError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: InvalidRequestError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Input is not a valid JSON-RPC request.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC method is not found. */\nexport class MethodNotFoundError extends BaseError {\n  static readonly code = -32601\n  override readonly code = -32601\n  override readonly name = 'RpcResponse.MethodNotFoundError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: MethodNotFoundError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Method does not exist.',\n    })\n  }\n}\n\n/** Thrown when the parameters to a JSON-RPC method are invalid. */\nexport class InvalidParamsError extends BaseError {\n  static readonly code = -32602\n  override readonly code = -32602\n  override readonly name = 'RpcResponse.InvalidParamsError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: InvalidParamsError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Invalid method parameters.',\n    })\n  }\n}\n\n/** Thrown when an internal JSON-RPC error has occurred. */\nexport class InternalError extends BaseError {\n  static readonly code = -32603\n  override readonly code = -32603\n  override readonly name = 'RpcResponse.InternalError'\n\n  constructor(\n    parameters: Partial<Omit<ErrorObject, 'code'>> & {\n      cause?: Error | undefined\n      stack?: string | undefined\n    } = {},\n  ) {\n    super({\n      cause: parameters.cause,\n      code: InternalError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Internal JSON-RPC error.',\n      stack: parameters.stack,\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC response is invalid. */\nexport class ParseError extends BaseError {\n  static readonly code = -32700\n  override readonly code = -32700\n  override readonly name = 'RpcResponse.ParseError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: ParseError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Failed to parse JSON-RPC response.',\n    })\n  }\n}\n", "import type { Errors } from '../index.js'\nimport type * as RpcSchema_internal from './internal/rpcSchema.js'\nimport type { Compute } from './internal/types.js'\nimport type * as RpcSchema from './RpcSchema.js'\n\n/** A JSON-RPC request object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object). */\nexport type RpcRequest<schema extends RpcSchema.Generic = RpcSchema.Generic> =\n  Compute<\n    schema extends any\n      ? schema['Request'] & {\n          id: number\n          jsonrpc: '2.0'\n          /** @deprecated internal */\n          _returnType: schema['ReturnType']\n        }\n      : never\n  >\n\n/** JSON-RPC request store type. */\nexport type Store<schema extends RpcSchema.Generic | undefined = undefined> =\n  Compute<{\n    prepare: <methodName extends RpcSchema.MethodNameGeneric>(\n      parameters: Compute<\n        schema extends RpcSchema.Generic\n          ? RpcSchema.ExtractRequest<schema, methodName>\n          : RpcSchema_internal.ExtractRequestOpaque<\n              RpcSchema.Default,\n              methodName\n            >\n      >,\n    ) => Compute<\n      RpcRequest<\n        RpcSchema.ExtractItem<\n          schema extends RpcSchema.Generic ? schema : RpcSchema.Default,\n          methodName\n        >\n      >\n    >\n    readonly id: number\n  }>\n\n/**\n * Creates a JSON-RPC request store to build requests with an incrementing `id`.\n *\n * Returns a type-safe `prepare` function to build a JSON-RPC request object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object).\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const request_1 = store.prepare({\n *   method: 'eth_blockNumber',\n * })\n * // @log: { id: 0, jsonrpc: '2.0', method: 'eth_blockNumber' }\n *\n * const request_2 = store.prepare({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       to: '0x0000000000000000000000000000000000000000',\n *       data: '0xdeadbeef',\n *     },\n *   ],\n * })\n * // @log: { id: 1, jsonrpc: '2.0', method: 'eth_call', params: [{ to: '0x0000000000000000000000000000000000000000', data: '0xdeadbeef' }] }\n * ```\n *\n * @example\n * ### Type-safe Custom Schemas\n *\n * It is possible to define your own type-safe schema by using {@link ox#RpcSchema.from}.\n *\n * ```ts twoslash\n * import { RpcSchema, RpcRequest } from 'ox'\n *\n * const schema = RpcSchema.from<{ // [!code focus]\n *   Request: { // [!code focus]\n *     method: 'eth_foobar' // [!code focus]\n *     params: [number] // [!code focus]\n *   } // [!code focus]\n *   ReturnType: string // [!code focus]\n * } | { // [!code focus]\n *   Request: { // [!code focus]\n *     method: 'eth_foobaz' // [!code focus]\n *     params: [string] // [!code focus]\n *   } // [!code focus]\n *   ReturnType: string // [!code focus]\n * }>() // [!code focus]\n *\n * const store = RpcRequest.createStore({ schema }) // [!code focus]\n *\n * const request = store.prepare({\n *   method: 'eth_foobar', // [!code focus]\n *   // ^?\n *   params: [42],\n * })\n * ```\n *\n * @param options - Request store options.\n * @returns The request store\n */\nexport function createStore<\n  schema extends RpcSchema.Generic | undefined = undefined,\n>(options: createStore.Options<schema> = {}): createStore.ReturnType<schema> {\n  let id = options.id ?? 0\n  return {\n    prepare(options) {\n      return from({\n        id: id++,\n        ...options,\n      } as never) as never\n    },\n    get id() {\n      return id\n    },\n  }\n}\n\nexport declare namespace createStore {\n  type Options<schema extends RpcSchema.Generic | undefined = undefined> = {\n    /** The initial request ID. */\n    id?: number\n    /** RPC Schema to use for the request store. */\n    schema?: schema | RpcSchema.Generic | undefined\n  }\n\n  type ReturnType<schema extends RpcSchema.Generic | undefined = undefined> =\n    Store<schema>\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * A type-safe interface to build a JSON-RPC request object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object).\n *\n * :::warning\n *\n * You will likely want to use {@link ox#RpcRequest.(createStore:function)} instead as it will also manage `id`s and uses this function internally.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Build a request object.\n * const request = RpcRequest.from({ // [!code focus]\n *   id: 0, // [!code focus]\n *   method: 'eth_estimateGas', // [!code focus]\n *   params: [ // [!code focus]\n *     { // [!code focus]\n *       from: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]\n *       to: '0x0D44f617435088c947F00B31160f64b074e412B4', // [!code focus]\n *       value: '0x69420', // [!code focus]\n *     }, // [!code focus]\n *   ], // [!code focus]\n * }) // [!code focus]\n *\n * // 2. Send the JSON-RPC request via HTTP.\n * const gas = await fetch('https://1.rpc.thirdweb.com', {\n *   body: JSON.stringify(request),\n *   headers: {\n *     'Content-Type': 'application/json',\n *   },\n *   method: 'POST',\n * })\n *  .then((response) => response.json())\n *  // 3. Parse the JSON-RPC response into a type-safe result.\n *  .then((response) => RpcResponse.parse(response, { request }))\n * ```\n *\n * @param options - JSON-RPC request options.\n * @returns The fully-formed JSON-RPC request object.\n */\nexport function from<methodName extends RpcSchema.MethodNameGeneric>(\n  options: from.Options<methodName>,\n): from.ReturnType<methodName> {\n  return {\n    ...options,\n    jsonrpc: '2.0',\n  } as never\n}\n\nexport declare namespace from {\n  type Options<methodName extends RpcSchema.MethodNameGeneric> = Compute<\n    RpcSchema_internal.ExtractRequestOpaque<RpcSchema.Default, methodName> & {\n      id: number\n    }\n  >\n\n  type ReturnType<methodName extends RpcSchema.MethodNameGeneric> = Compute<\n    RpcRequest<RpcSchema.ExtractItem<RpcSchema.Default, methodName>>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import type { ResolvedRegister } from './internal/register.js'\nimport type { Compute, IsNarrowable } from './internal/types.js'\n\nexport type { Eth } from './internal/rpcSchemas/eth.js'\nexport type { Wallet } from './internal/rpcSchemas/wallet.js'\n\n/**\n * Instantiates a statically typed Schema. This is a runtime-noop function, and is purposed\n * to be used as a type-level tag to be used with {@link ox#Provider.(from:function)} or\n * {@link ox#RpcTransport.(fromHttp:function)}.\n *\n * @example\n * ### Using with `Provider.from`\n *\n * ```ts twoslash\n * // @noErrors\n * import 'ox/window'\n * import { Provider, RpcSchema } from 'ox'\n *\n * const schema = RpcSchema.from<\n *   | RpcSchema.Default\n *   | {\n *       Request: {\n *         method: 'abe_foo',\n *         params: [id: number],\n *       }\n *       ReturnType: string\n *     }\n *   | {\n *       Request: {\n *         method: 'abe_bar',\n *         params: [id: string],\n *       }\n *       ReturnType: string\n *     }\n * >()\n *\n * const provider = Provider.from(window.ethereum, { schema })\n *\n * const blockNumber = await provider.request({ method: 'e' })\n * //                                                    ^|\n *\n *\n *\n *\n *\n * ```\n */\nexport function from<schema extends Generic>(): schema {\n  return null as never\n}\n\n/**\n * Extracts a schema item from a {@link ox#RpcSchema.Generic} or {@link ox#RpcSchema.MethodNameGeneric}.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema } from 'ox'\n *\n * type Item = RpcSchema.ExtractItem<RpcSchema.Eth, 'eth_getBlockByNumber'>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type ExtractItem<\n  schema extends Generic,\n  methodName extends MethodNameGeneric<schema> = MethodNameGeneric<schema>,\n> = Compute<{\n  Request: ExtractRequest<schema, methodName>\n  ReturnType: ExtractReturnType<schema, methodName>\n}>\n\n/**\n * Extracts request from a {@link ox#RpcSchema.Generic} or {@link ox#RpcSchema.MethodNameGeneric}.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema } from 'ox'\n *\n * type Request = RpcSchema.ExtractRequest<RpcSchema.Eth, 'eth_getBlockByNumber'>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type ExtractRequest<\n  schema extends Generic,\n  methodName extends MethodNameGeneric<schema> = MethodNameGeneric<schema>,\n> = Extract<schema['Request'], { method: methodName }>\n\n/**\n * Type-safe union of all JSON-RPC Method Names.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema } from 'ox'\n *\n * type MethodName = RpcSchema.ExtractMethodName<RpcSchema.Default>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type ExtractMethodName<schema extends Generic> =\n  schema['Request']['method']\n\n/**\n * Extracts parameters from a {@link ox#RpcSchema.Generic} or {@link ox#RpcSchema.MethodNameGeneric}.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema } from 'ox'\n *\n * type Eth_GetBlockByNumber = RpcSchema.ExtractParams<RpcSchema.Eth, 'eth_getBlockByNumber'>\n * //   ^?\n *\n *\n *\n *\n *\n * ```\n */\nexport type ExtractParams<\n  schema extends Generic,\n  methodName extends MethodNameGeneric<schema> = MethodNameGeneric<schema>,\n> = ExtractRequest<schema, methodName>['params']\n\n/**\n * Extracts return type from a {@link ox#RpcSchema.Generic} or {@link ox#RpcSchema.MethodNameGeneric}.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema } from 'ox'\n *\n * type ReturnType = RpcSchema.ExtractReturnType<RpcSchema.Eth, 'eth_getBlockByNumber'>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type ExtractReturnType<\n  schema extends Generic,\n  methodName extends MethodNameGeneric<schema> = MethodNameGeneric<schema>,\n> = methodName extends schema['Request']['method']\n  ? IsNarrowable<schema, Generic> extends true\n    ? Extract<schema, { Request: { method: methodName } }>['ReturnType']\n    : unknown\n  : unknown\n\n/**\n * Type to define a custom type-safe JSON-RPC Schema.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema, RpcRequest } from 'ox'\n *\n * type Schema = RpcSchema.From<{\n *   Request: {\n *     method: 'eth_foobar',\n *     params: [id: number],\n *   }\n *   ReturnType: string\n * }>\n * ```\n */\nexport type From<schema extends Generic> = schema\n\n/**\n * Generic type to define a JSON-RPC Method.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema } from 'ox'\n *\n * type Schema = RpcSchema.Generic\n * //   ^?\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type Generic<name extends string = string, params = unknown> = {\n  Request: {\n    method: name\n    params?: params | undefined\n  }\n  ReturnType?: unknown\n}\n\n/**\n * Type-safe union of all JSON-RPC Methods.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema } from 'ox'\n *\n * type Schema = RpcSchema.Default\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type Default = ResolvedRegister['RpcSchema']\n\n/**\n * Generic type to define a JSON-RPC Method Name.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema } from 'ox'\n *\n * type Name = RpcSchema.MethodNameGeneric\n * //   ^?\n *\n *\n *\n *\n *\n * ```\n */\nexport type MethodNameGeneric<schema extends Generic = Generic> =\n  | schema['Request']['method']\n  | (string & {})\n", "import * as Errors from './Errors.js'\nimport { getUrl } from './internal/errors.js'\nimport * as promise from './internal/promise.js'\nimport type * as RpcSchema_internal from './internal/rpcSchema.js'\nimport * as internal from './internal/rpcTransport.js'\nimport type { Compute } from './internal/types.js'\nimport type * as RpcResponse from './RpcResponse.js'\nimport type * as RpcSchema from './RpcSchema.js'\n\n/** Root type for an RPC Transport. */\nexport type RpcTransport<\n  raw extends boolean = false,\n  options extends Record<string, unknown> = {},\n  schema extends RpcSchema.Generic = RpcSchema.Default,\n> = Compute<{\n  request: RequestFn<raw, options, schema>\n}>\n\n/** HTTP-based RPC Transport. */\nexport type Http<\n  raw extends boolean = false,\n  schema extends RpcSchema.Generic = RpcSchema.Default,\n> = RpcTransport<raw, HttpOptions, schema>\n\nexport type HttpOptions = {\n  /** Request configuration to pass to `fetch`. */\n  fetchOptions?:\n    | Omit<RequestInit, 'body'>\n    | ((\n        method: RpcSchema.Generic['Request'],\n      ) => Omit<RequestInit, 'body'> | Promise<Omit<RequestInit, 'body'>>)\n    | undefined\n  /** Function to use to make the request. @default fetch */\n  fetchFn?: typeof fetch | undefined\n  /** Timeout for the request in milliseconds. @default 10_000 */\n  timeout?: number | undefined\n}\n\nexport type RequestFn<\n  raw extends boolean = false,\n  options extends Record<string, unknown> = {},\n  schema extends RpcSchema.Generic = RpcSchema.Default,\n> = <\n  methodName extends RpcSchema.MethodNameGeneric,\n  raw_override extends boolean | undefined = undefined,\n>(\n  parameters: Compute<\n    RpcSchema_internal.ExtractRequestOpaque<schema, methodName>\n  >,\n  options?: internal.Options<raw_override, options, schema> | undefined,\n) => Promise<\n  raw_override extends boolean\n    ? raw_override extends true\n      ? RpcResponse.RpcResponse<RpcSchema.ExtractReturnType<schema, methodName>>\n      : RpcSchema.ExtractReturnType<schema, methodName>\n    : raw extends true\n      ? RpcResponse.RpcResponse<RpcSchema.ExtractReturnType<schema, methodName>>\n      : RpcSchema.ExtractReturnType<schema, methodName>\n>\n\n/**\n * Creates a HTTP JSON-RPC Transport from a URL.\n *\n * @example\n * ```ts twoslash\n * import { RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n *\n * const blockNumber = await transport.request({ method: 'eth_blockNumber' })\n * // @log: '0x1a2b3c'\n * ```\n *\n * @param url - URL to perform the JSON-RPC requests to.\n * @param options - Transport options.\n * @returns HTTP JSON-RPC Transport.\n */\nexport function fromHttp<\n  raw extends boolean = false,\n  schema extends RpcSchema.Generic = RpcSchema.Default,\n>(url: string, options: fromHttp.Options<raw, schema> = {}): Http<raw, schema> {\n  return internal.create<HttpOptions, schema, raw>(\n    {\n      async request(body_, options_) {\n        const {\n          fetchFn = options.fetchFn ?? fetch,\n          fetchOptions: fetchOptions_ = options.fetchOptions,\n          timeout = options.timeout ?? 10_000,\n        } = options_\n\n        const body = JSON.stringify(body_)\n\n        const fetchOptions =\n          typeof fetchOptions_ === 'function'\n            ? await fetchOptions_(body_)\n            : fetchOptions_\n\n        const response = await promise.withTimeout(\n          ({ signal }) => {\n            const init: RequestInit = {\n              ...fetchOptions,\n              body,\n              headers: {\n                'Content-Type': 'application/json',\n                ...fetchOptions?.headers,\n              },\n              method: fetchOptions?.method ?? 'POST',\n              signal: fetchOptions?.signal ?? (timeout > 0 ? signal : null),\n            }\n            const request = new Request(url, init)\n            return fetchFn(request)\n          },\n          {\n            timeout,\n            signal: true,\n          },\n        )\n\n        const data = await (async () => {\n          if (\n            response.headers.get('Content-Type')?.startsWith('application/json')\n          )\n            return response.json()\n          return response.text().then((data) => {\n            try {\n              return JSON.parse(data || '{}')\n            } catch (_err) {\n              if (response.ok)\n                throw new MalformedResponseError({\n                  response: data,\n                })\n              return { error: data }\n            }\n          })\n        })()\n\n        if (!response.ok)\n          throw new HttpError({\n            body,\n            details: JSON.stringify(data.error) ?? response.statusText,\n            response,\n            url,\n          })\n\n        return data as never\n      },\n    },\n    { raw: options.raw },\n  )\n}\n\nexport declare namespace fromHttp {\n  type Options<\n    raw extends boolean = false,\n    schema extends RpcSchema.Generic = RpcSchema.Default,\n  > = internal.Options<raw, HttpOptions, schema>\n\n  type ErrorType =\n    | promise.withTimeout.ErrorType\n    | HttpError\n    | Errors.GlobalErrorType\n}\n\n/** Thrown when a HTTP request fails. */\nexport class HttpError extends Errors.BaseError {\n  override readonly name = 'RpcTransport.HttpError'\n\n  constructor({\n    body,\n    details,\n    response,\n    url,\n  }: { body: unknown; details: string; response: Response; url: string }) {\n    super('HTTP request failed.', {\n      details,\n      metaMessages: [\n        `Status: ${response.status}`,\n        `URL: ${getUrl(url)}`,\n        body ? `Body: ${JSON.stringify(body)}` : undefined,\n      ],\n    })\n  }\n}\n\n/** Thrown when a HTTP response is malformed. */\nexport class MalformedResponseError extends Errors.BaseError {\n  override readonly name = 'RpcTransport.MalformedResponseError'\n\n  constructor({ response }: { response: string }) {\n    super('HTTP Response could not be parsed as JSON.', {\n      metaMessages: [`Response: ${response}`],\n    })\n  }\n}\n", "import * as Errors from '../Errors.js'\n\n/** @internal */\nexport function withTimeout<data>(\n  fn: withTimeout.Fn<data>,\n  options: withTimeout.Options,\n): Promise<data> {\n  const { errorInstance = new TimeoutError(), timeout, signal } = options\n  return new Promise((resolve, reject) => {\n    ;(async () => {\n      let timeoutId: any\n      try {\n        const controller = new AbortController()\n        if (timeout > 0)\n          timeoutId = setTimeout(() => {\n            if (signal) {\n              controller.abort()\n            } else {\n              reject(errorInstance)\n            }\n          }, timeout) as any\n        resolve(await fn({ signal: controller.signal }))\n      } catch (err) {\n        if ((err as Error)?.name === 'AbortError') reject(errorInstance)\n        reject(err)\n      } finally {\n        clearTimeout(timeoutId)\n      }\n    })()\n  })\n}\n\n/** @internal */\nexport declare namespace withTimeout {\n  type Fn<data> = ({\n    signal,\n  }: {\n    signal: AbortController['signal'] | null\n  }) => Promise<data>\n\n  type Options = {\n    // The error instance to throw when the timeout is reached.\n    errorInstance?: Error | undefined\n    // The timeout (in ms).\n    timeout: number\n    // Whether or not the timeout should use an abort signal.\n    signal?: boolean | undefined\n  }\n\n  type ErrorType = TimeoutError | Errors.GlobalErrorType\n}\n\n/** @internal */\n\n/**\n * Thrown when an operation times out.\n * @internal\n */\nexport class TimeoutError extends Errors.BaseError {\n  override readonly name = 'Promise.TimeoutError'\n\n  constructor() {\n    super('Operation timed out.')\n  }\n}\n", "import type * as Errors from '../Errors.js'\nimport * as RpcRequest from '../RpcRequest.js'\nimport * as RpcResponse from '../RpcResponse.js'\nimport type * as RpcSchema from '../RpcSchema.js'\nimport type * as RpcTransport from '../RpcTransport.js'\nimport type { Compute } from './types.js'\n\n/** @internal */\nexport type Options<\n  raw extends boolean | undefined = undefined,\n  options extends Record<string, unknown> = {},\n  schema extends RpcSchema.Generic = RpcSchema.Default,\n> = {\n  /**\n   * Enables raw mode – responses will return an object with `result` and `error` properties instead of returning the `result` directly and throwing errors.\n   *\n   * - `true`: a JSON-RPC response object will be returned with `result` and `error` properties.\n   * - `false`: the JSON-RPC response object's `result` property will be returned directly, and JSON-RPC Errors will be thrown.\n   *\n   * @default false\n   */\n  raw?: raw | boolean | undefined\n  /**\n   * RPC Schema to use for the Transport's `request` function.\n   * See {@link ox#RpcSchema.(from:function)} for more.\n   *\n   * @default `RpcSchema.Default`\n   */\n  schema?: schema | RpcSchema.Default | undefined\n} & options\n\n/** @internal */\nexport function create<\n  options extends Record<string, unknown> = {},\n  schema extends RpcSchema.Generic = RpcSchema.Default,\n  raw extends boolean = false,\n>(\n  transport: create.Transport<options>,\n  options_root?: Options<raw, options, schema>,\n): RpcTransport.RpcTransport<raw, options, schema> {\n  const requestStore = RpcRequest.createStore()\n\n  return {\n    request: async ({ method, params }, options: any = {}) => {\n      const body = requestStore.prepare({ method, params } as never)\n\n      const data = await transport.request(body as never, options as never)\n\n      return RpcResponse.parse(data, {\n        raw: options.raw ?? options_root?.raw,\n      }) as never\n    },\n  }\n}\n\n/** @internal */\nexport declare namespace create {\n  type Transport<options extends Record<string, unknown> = {}> = {\n    request: (\n      body: Compute<Omit<RpcRequest.RpcRequest, '_returnType'>>,\n      options: options,\n    ) => Promise<RpcResponse.RpcResponse>\n  }\n\n  type ErrorType =\n    | RpcRequest.createStore.ErrorType\n    | RpcResponse.parse.ErrorType\n    | Errors.GlobalErrorType\n}\n", "import * as Address from './Address.js'\nimport * as Errors from './Errors.js'\nimport type { ExactPartial } from './internal/types.js'\nimport { uid } from './internal/uid.js'\n\nexport const domainRegex =\n  /^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$/\n\nexport const ipRegex =\n  /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]{1,5})?$/\n\nexport const localhostRegex = /^localhost(:[0-9]{1,5})?$/\n\nexport const nonceRegex = /^[a-zA-Z0-9]{8,}$/\n\nexport const schemeRegex = /^([a-zA-Z][a-zA-Z0-9+-.]*)$/\n\n// https://regexr.com/80gdj\nexport const prefixRegex =\n  /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\\/\\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\\n)(?<address>0x[a-fA-F0-9]{40})\\n\\n(?:(?<statement>.*)\\n\\n)?/\n\n// https://regexr.com/80gf9\nexport const suffixRegex =\n  /(?:URI: (?<uri>.+))\\n(?:Version: (?<version>.+))\\n(?:Chain ID: (?<chainId>\\d+))\\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\\n(?:Issued At: (?<issuedAt>.+))(?:\\nExpiration Time: (?<expirationTime>.+))?(?:\\nNot Before: (?<notBefore>.+))?(?:\\nRequest ID: (?<requestId>.+))?/\n\n/** [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) message fields. */\nexport type Message = {\n  /**\n   * The Ethereum address performing the signing.\n   */\n  address: Address.Address\n  /**\n   * The [EIP-155](https://eips.ethereum.org/EIPS/eip-155) Chain ID to which the session is bound,\n   */\n  chainId: number\n  /**\n   * [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986) authority that is requesting the signing.\n   */\n  domain: string\n  /**\n   * Time when the signed authentication message is no longer valid.\n   */\n  expirationTime?: Date | undefined\n  /**\n   * Time when the message was generated, typically the current time.\n   */\n  issuedAt?: Date | undefined\n  /**\n   * A random string typically chosen by the relying party and used to prevent replay attacks.\n   */\n  nonce: string\n  /**\n   * Time when the signed authentication message will become valid.\n   */\n  notBefore?: Date | undefined\n  /**\n   * A system-specific identifier that may be used to uniquely refer to the sign-in request.\n   */\n  requestId?: string | undefined\n  /**\n   * A list of information or references to information the user wishes to have resolved as part of authentication by the relying party.\n   */\n  resources?: string[] | undefined\n  /**\n   * [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986#section-3.1) URI scheme of the origin of the request.\n   */\n  scheme?: string | undefined\n  /**\n   * A human-readable ASCII assertion that the user will sign.\n   */\n  statement?: string | undefined\n  /**\n   * [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986) URI referring to the resource that is the subject of the signing (as in the subject of a claim).\n   */\n  uri: string\n  /**\n   * The current version of the SIWE Message.\n   */\n  version: '1'\n}\n\n/**\n * Creates [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.createMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   chainId: 1,\n *   domain: 'example.com',\n *   nonce: 'foobarbaz',\n *   uri: 'https://example.com/path',\n *   version: '1',\n * })\n * // @log: \"example.com wants you to sign in with your Ethereum account:\n * // @log: 0xA0Cf798816D4b9b9866b5330EEa46a18382f251e\n * // @log:\n * // @log:\n * // @log: URI: https://example.com/path\n * // @log: Version: 1\n * // @log: Chain ID: 1\n * // @log: Nonce: foobarbaz\n * // @log: Issued At: 2023-02-01T00:00:00.000Z\"\n * ```\n *\n * @param value - Values to use when creating EIP-4361 formatted message.\n * @returns EIP-4361 formatted message.\n */\nexport function createMessage(value: Message): string {\n  const {\n    chainId,\n    domain,\n    expirationTime,\n    issuedAt = new Date(),\n    nonce,\n    notBefore,\n    requestId,\n    resources,\n    scheme,\n    uri,\n    version,\n  } = value\n\n  // Validate fields\n  {\n    // Required fields\n    if (chainId !== Math.floor(chainId))\n      throw new InvalidMessageFieldError({\n        field: 'chainId',\n        metaMessages: [\n          '- Chain ID must be a EIP-155 chain ID.',\n          '- See https://eips.ethereum.org/EIPS/eip-155',\n          '',\n          `Provided value: ${chainId}`,\n        ],\n      })\n    if (\n      !(\n        domainRegex.test(domain) ||\n        ipRegex.test(domain) ||\n        localhostRegex.test(domain)\n      )\n    )\n      throw new InvalidMessageFieldError({\n        field: 'domain',\n        metaMessages: [\n          '- Domain must be an RFC 3986 authority.',\n          '- See https://www.rfc-editor.org/rfc/rfc3986',\n          '',\n          `Provided value: ${domain}`,\n        ],\n      })\n    if (!nonceRegex.test(nonce))\n      throw new InvalidMessageFieldError({\n        field: 'nonce',\n        metaMessages: [\n          '- Nonce must be at least 8 characters.',\n          '- Nonce must be alphanumeric.',\n          '',\n          `Provided value: ${nonce}`,\n        ],\n      })\n    if (!isUri(uri))\n      throw new InvalidMessageFieldError({\n        field: 'uri',\n        metaMessages: [\n          '- URI must be a RFC 3986 URI referring to the resource that is the subject of the signing.',\n          '- See https://www.rfc-editor.org/rfc/rfc3986',\n          '',\n          `Provided value: ${uri}`,\n        ],\n      })\n    if (version !== '1')\n      throw new InvalidMessageFieldError({\n        field: 'version',\n        metaMessages: [\n          \"- Version must be '1'.\",\n          '',\n          `Provided value: ${version}`,\n        ],\n      })\n\n    // Optional fields\n    if (scheme && !schemeRegex.test(scheme))\n      throw new InvalidMessageFieldError({\n        field: 'scheme',\n        metaMessages: [\n          '- Scheme must be an RFC 3986 URI scheme.',\n          '- See https://www.rfc-editor.org/rfc/rfc3986#section-3.1',\n          '',\n          `Provided value: ${scheme}`,\n        ],\n      })\n    const statement = value.statement\n    if (statement?.includes('\\n'))\n      throw new InvalidMessageFieldError({\n        field: 'statement',\n        metaMessages: [\n          \"- Statement must not include '\\\\n'.\",\n          '',\n          `Provided value: ${statement}`,\n        ],\n      })\n  }\n\n  // Construct message\n  const address = Address.from(value.address, { checksum: true })\n  const origin = (() => {\n    if (scheme) return `${scheme}://${domain}`\n    return domain\n  })()\n  const statement = (() => {\n    if (!value.statement) return ''\n    return `${value.statement}\\n`\n  })()\n  const prefix = `${origin} wants you to sign in with your Ethereum account:\\n${address}\\n\\n${statement}`\n\n  let suffix = `URI: ${uri}\\nVersion: ${version}\\nChain ID: ${chainId}\\nNonce: ${nonce}\\nIssued At: ${issuedAt.toISOString()}`\n\n  if (expirationTime)\n    suffix += `\\nExpiration Time: ${expirationTime.toISOString()}`\n  if (notBefore) suffix += `\\nNot Before: ${notBefore.toISOString()}`\n  if (requestId) suffix += `\\nRequest ID: ${requestId}`\n  if (resources) {\n    let content = '\\nResources:'\n    for (const resource of resources) {\n      if (!isUri(resource))\n        throw new InvalidMessageFieldError({\n          field: 'resources',\n          metaMessages: [\n            '- Every resource must be a RFC 3986 URI.',\n            '- See https://www.rfc-editor.org/rfc/rfc3986',\n            '',\n            `Provided value: ${resource}`,\n          ],\n        })\n      content += `\\n- ${resource}`\n    }\n    suffix += content\n  }\n\n  return `${prefix}\\n${suffix}`\n}\n\nexport declare namespace createMessage {\n  type ErrorType =\n    | Address.from.ErrorType\n    | InvalidMessageFieldError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Generates random [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) nonce.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.generateNonce()\n * // @log: '65ed4681d4efe0270b923ff5f4b097b1c95974dc33aeebecd5724c42fd86dfd25dc70b27ef836b2aa22e68f19ebcccc1'\n * ```\n *\n * @returns Random nonce.\n */\nexport function generateNonce(): string {\n  return uid(96)\n}\n\n/**\n * Check if the given URI is a valid [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986) URI.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.isUri('https://example.com/foo')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `false` if invalid, otherwise the valid URI.\n */\n// based on https://github.com/ogt/valid-url\nexport function isUri(value: string): false | string {\n  // check for illegal characters\n  if (/[^a-z0-9:/?#[\\]@!$&'()*+,;=.\\-_~%]/i.test(value)) return false\n\n  // check for hex escapes that aren't complete\n  if (/%[^0-9a-f]/i.test(value)) return false\n  if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return false\n\n  // from RFC 3986\n  const splitted = splitUri(value)\n  const scheme = splitted[1]\n  const authority = splitted[2]\n  const path = splitted[3]\n  const query = splitted[4]\n  const fragment = splitted[5]\n\n  // scheme and path are required, though the path can be empty\n  if (!(scheme?.length && path && path.length >= 0)) return false\n\n  // if authority is present, the path must be empty or begin with a /\n  if (authority?.length) {\n    if (!(path.length === 0 || /^\\//.test(path))) return false\n  } else {\n    // if authority is not present, the path must not start with //\n    if (/^\\/\\//.test(path)) return false\n  }\n\n  // scheme must begin with a letter, then consist of letters, digits, +, ., or -\n  if (!/^[a-z][a-z0-9+\\-.]*$/.test(scheme.toLowerCase())) return false\n\n  let out = ''\n  // re-assemble the URL per section 5.3 in RFC 3986\n  out += `${scheme}:`\n  if (authority?.length) out += `//${authority}`\n\n  out += path\n\n  if (query?.length) out += `?${query}`\n  if (fragment?.length) out += `#${fragment}`\n\n  return out\n}\n\nfunction splitUri(value: string) {\n  return value.match(\n    /(?:([^:/?#]+):)?(?:\\/\\/([^/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/,\n  )!\n}\n\n/**\n * [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message into message fields object.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.parseMessage(`example.com wants you to sign in with your Ethereum account:\n * 0xA0Cf798816D4b9b9866b5330EEa46a18382f251e\n *\n * I accept the ExampleOrg Terms of Service: https://example.com/tos\n *\n * URI: https://example.com/path\n * Version: 1\n * Chain ID: 1\n * Nonce: foobarbaz\n * Issued At: 2023-02-01T00:00:00.000Z`)\n * // @log: {\n * // @log:   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * // @log:   chainId: 1,\n * // @log:   domain: 'example.com',\n * // @log:   issuedAt: '2023-02-01T00:00:00.000Z',\n * // @log:   nonce: 'foobarbaz',\n * // @log:   statement: 'I accept the ExampleOrg Terms of Service: https://example.com/tos',\n * // @log:   uri: 'https://example.com/path',\n * // @log:   version: '1',\n * // @log: }\n * ```\n *\n * @param message - [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message.\n * @returns Message fields object.\n */\nexport function parseMessage(message: string): ExactPartial<Message> {\n  const { scheme, statement, ...prefix } = (message.match(prefixRegex)\n    ?.groups ?? {}) as {\n    address: Address.Address\n    domain: string\n    scheme?: string\n    statement?: string\n  }\n  const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } =\n    (message.match(suffixRegex)?.groups ?? {}) as {\n      chainId: string\n      expirationTime?: string\n      issuedAt?: string\n      nonce: string\n      notBefore?: string\n      requestId?: string\n      uri: string\n      version: '1'\n    }\n  const resources = message.split('Resources:')[1]?.split('\\n- ').slice(1)\n  return {\n    ...prefix,\n    ...suffix,\n    ...(chainId ? { chainId: Number(chainId) } : {}),\n    ...(expirationTime ? { expirationTime: new Date(expirationTime) } : {}),\n    ...(issuedAt ? { issuedAt: new Date(issuedAt) } : {}),\n    ...(notBefore ? { notBefore: new Date(notBefore) } : {}),\n    ...(requestId ? { requestId } : {}),\n    ...(resources ? { resources } : {}),\n    ...(scheme ? { scheme } : {}),\n    ...(statement ? { statement } : {}),\n  }\n}\n\n/**\n * Validates [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) message.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.validateMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   domain: 'example.com',\n *   message: {\n *     address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *     chainId: 1,\n *     domain: 'example.com',\n *     nonce: 'foobarbaz',\n *     uri: 'https://example.com/path',\n *     version: '1',\n *   },\n *   nonce: 'foobarbaz',\n * })\n * // @log: true\n * ```\n *\n * @param value - Values to use when validating EIP-4361 formatted message.\n * @returns Whether the message is valid.\n */\nexport function validateMessage(value: validateMessage.Value): boolean {\n  const { address, domain, message, nonce, scheme, time = new Date() } = value\n\n  if (domain && message.domain !== domain) return false\n  if (nonce && message.nonce !== nonce) return false\n  if (scheme && message.scheme !== scheme) return false\n\n  if (message.expirationTime && time >= message.expirationTime) return false\n  if (message.notBefore && time < message.notBefore) return false\n\n  try {\n    if (!message.address) return false\n    if (address && !Address.isEqual(message.address, address)) return false\n  } catch {\n    return false\n  }\n\n  return true\n}\n\nexport declare namespace validateMessage {\n  interface Value {\n    /**\n     * Ethereum address to check against.\n     */\n    address?: Address.Address | undefined\n    /**\n     * [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986) authority to check against.\n     */\n    domain?: string | undefined\n    /**\n     * EIP-4361 message fields.\n     */\n    message: ExactPartial<Message>\n    /**\n     * Random string to check against.\n     */\n    nonce?: string | undefined\n    /**\n     * [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986#section-3.1) URI scheme to check against.\n     */\n    scheme?: string | undefined\n    /**\n     * Current time to check optional `expirationTime` and `notBefore` fields.\n     *\n     * @default new Date()\n     */\n    time?: Date | undefined\n  }\n}\n\n/**\n * Thrown when a field in a SIWE Message is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.createMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   chainId: 1.1,\n *   domain: 'example.com',\n *   nonce: 'foobarbaz',\n *   uri: 'https://example.com/path',\n *   version: '1',\n * })\n * // @error: Siwe.InvalidMessageFieldError: Invalid Sign-In with Ethereum message field \"chainId\".\n * // @error: - Chain ID must be a EIP-155 chain ID.\n * // @error: - See https://eips.ethereum.org/EIPS/eip-155\n * // @error: Provided value: 1.1\n * ```\n */\nexport class InvalidMessageFieldError extends Errors.BaseError {\n  override readonly name = 'Siwe.InvalidMessageFieldError'\n\n  constructor(parameters: {\n    field: string\n    metaMessages?: string[] | undefined\n  }) {\n    const { field, metaMessages } = parameters\n    super(`Invalid Sign-In with Ethereum message field \"${field}\".`, {\n      metaMessages,\n    })\n  }\n}\n", "const size = 256\nlet index = size\nlet buffer: string\n\n/** @internal */\nexport function uid(length = 11) {\n  if (!buffer || index + length > size * 2) {\n    buffer = ''\n    index = 0\n    for (let i = 0; i < size; i++) {\n      buffer += ((256 + Math.random() * 256) | 0).toString(16).substring(1)\n    }\n  }\n  return buffer.substring(index, index++ + length)\n}\n", "import type * as Address from './Address.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, OneOf } from './internal/types.js'\n\n/**\n * State override set to specify state to be ephemerally overridden prior to executing a call.\n */\nexport type StateOverrides<bigintType = bigint> = Compute<{\n  [address: Address.Address]: AccountOverrides<bigintType>\n}>\n\n/**\n * RPC state overrides.\n */\nexport type Rpc = StateOverrides<Hex.Hex>\n\n/**\n * Details of an account to be overridden.\n */\nexport type AccountOverrides<bigintType = bigint> = Compute<\n  {\n    /** Balance to set for the account. */\n    balance?: bigintType | undefined\n    /** Code to set for the account. */\n    code?: Hex.Hex | undefined\n    /** Address to move the precompile to. */\n    movePrecompileToAddress?: Address.Address | undefined\n    /** Nonce to set for the account. */\n    nonce?: bigintType | undefined\n  } & OneOf<\n    | {\n        /** Key-value mapping to override all slots in the account storage. */\n        state?: AccountStorage | undefined\n      }\n    | {\n        /** Key-value mapping to override individual slots in the account storage. */\n        stateDiff?: AccountStorage | undefined\n      }\n  >\n>\n\n/**\n * RPC account overrides.\n */\nexport type RpcAccountOverrides = AccountOverrides<Hex.Hex>\n\n/**\n * Key-value mapping to override all slots in the account storage before executing the call.\n */\nexport type AccountStorage = Compute<{\n  [slot: Hex.Hex]: Hex.Hex\n}>\n\n/**\n * Converts an {@link ox#StateOverrides.Rpc} to an {@link ox#StateOverrides.StateOverrides}.\n *\n * @example\n * ```ts twoslash\n * import { StateOverrides } from 'ox'\n *\n * const stateOverrides = StateOverrides.fromRpc({\n *   '0x0000000000000000000000000000000000000000': {\n *     balance: '0x1',\n *   },\n * })\n * ```\n *\n * @param rpcStateOverrides - The RPC state overrides to convert.\n * @returns An instantiated {@link ox#StateOverrides.StateOverrides}.\n */\nexport function fromRpc(rpcStateOverrides: Rpc): StateOverrides {\n  const stateOverrides: StateOverrides = {}\n  for (const [address, accountOverridesRpc] of Object.entries(\n    rpcStateOverrides,\n  )) {\n    const accountOverrides: AccountOverrides = {}\n    if (accountOverridesRpc.balance)\n      accountOverrides.balance = BigInt(accountOverridesRpc.balance)\n    if (accountOverridesRpc.code)\n      accountOverrides.code = accountOverridesRpc.code\n    if (accountOverridesRpc.movePrecompileToAddress)\n      accountOverrides.movePrecompileToAddress =\n        accountOverridesRpc.movePrecompileToAddress\n    if (accountOverridesRpc.nonce)\n      accountOverrides.nonce = BigInt(accountOverridesRpc.nonce)\n    if (accountOverridesRpc.state)\n      accountOverrides.state = accountOverridesRpc.state\n    if (accountOverridesRpc.stateDiff)\n      accountOverrides.stateDiff = accountOverridesRpc.stateDiff\n    ;(stateOverrides as any)[address] = accountOverrides\n  }\n  return stateOverrides\n}\n\n/**\n * Converts an {@link ox#StateOverrides.StateOverrides} to an {@link ox#StateOverrides.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { StateOverrides } from 'ox'\n *\n * const stateOverrides = StateOverrides.toRpc({\n *   '0x0000000000000000000000000000000000000000': {\n *     balance: 1n,\n *   },\n * })\n * ```\n *\n * @param stateOverrides - The state overrides to convert.\n * @returns An instantiated {@link ox#StateOverrides.Rpc}.\n */\nexport function toRpc(stateOverrides: StateOverrides): Rpc {\n  const rpcStateOverrides: Rpc = {}\n  for (const [address, accountOverrides] of Object.entries(stateOverrides)) {\n    const accountOverridesRpc: RpcAccountOverrides = {}\n    if (typeof accountOverrides.balance === 'bigint')\n      accountOverridesRpc.balance = Hex.fromNumber(accountOverrides.balance)\n    if (accountOverrides.code) accountOverridesRpc.code = accountOverrides.code\n    if (accountOverrides.movePrecompileToAddress)\n      accountOverridesRpc.movePrecompileToAddress =\n        accountOverrides.movePrecompileToAddress\n    if (typeof accountOverrides.nonce === 'bigint')\n      accountOverridesRpc.nonce = Hex.fromNumber(accountOverrides.nonce)\n    if (accountOverrides.state)\n      accountOverridesRpc.state = accountOverrides.state\n    if (accountOverrides.stateDiff)\n      accountOverridesRpc.stateDiff = accountOverrides.stateDiff\n    ;(rpcStateOverrides as any)[address] = accountOverridesRpc\n  }\n  return rpcStateOverrides\n}\n", "import * as AccessList from './AccessList.js'\nimport * as Address from './Address.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type {\n  Assign,\n  Compute,\n  PartialBy,\n  UnionPartialBy,\n} from './internal/types.js'\nimport * as Rlp from './Rlp.js'\nimport * as Signature from './Signature.js'\nimport * as TransactionEnvelope from './TxEnvelope.js'\n\nexport type TxEnvelopeEip1559<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = Type,\n> = Compute<\n  TransactionEnvelope.Base<type, signed, bigintType, numberType> & {\n    /** EIP-2930 Access List. */\n    accessList?: AccessList.AccessList | undefined\n    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */\n    maxFeePerGas?: bigintType | undefined\n    /** Max priority fee per gas (in wei). */\n    maxPriorityFeePerGas?: bigintType | undefined\n  }\n>\n\nexport type Rpc<signed extends boolean = boolean> = TxEnvelopeEip1559<\n  signed,\n  Hex.Hex,\n  Hex.Hex,\n  '0x2'\n>\n\nexport type Serialized = `${SerializedType}${string}`\n\nexport const serializedType = '0x02' as const\nexport type SerializedType = typeof serializedType\n\nexport type Signed = TxEnvelopeEip1559<true>\n\nexport const type = 'eip1559' as const\nexport type Type = typeof type\n\n/**\n * Asserts a {@link ox#TxEnvelopeEip1559.TxEnvelopeEip1559} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559, Value } from 'ox'\n *\n * TxEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: FeeCapTooHighError:\n * // @error: The fee cap (`masFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope: PartialBy<TxEnvelopeEip1559, 'type'>) {\n  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = envelope\n  if (chainId <= 0)\n    throw new TransactionEnvelope.InvalidChainIdError({ chainId })\n  if (to) Address.assert(to, { strict: false })\n  if (maxFeePerGas && BigInt(maxFeePerGas) > 2n ** 256n - 1n)\n    throw new TransactionEnvelope.FeeCapTooHighError({ feeCap: maxFeePerGas })\n  if (\n    maxPriorityFeePerGas &&\n    maxFeePerGas &&\n    maxPriorityFeePerGas > maxFeePerGas\n  )\n    throw new TransactionEnvelope.TipAboveFeeCapError({\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    })\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | Address.assert.ErrorType\n    | TransactionEnvelope.InvalidChainIdError\n    | TransactionEnvelope.FeeCapTooHighError\n    | TransactionEnvelope.TipAboveFeeCapError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#TxEnvelopeEip1559.TxEnvelopeEip1559} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TxEnvelopeEip1559.deserialize('0x02ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'eip1559',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(\n  serialized: Serialized,\n): Compute<TxEnvelopeEip1559> {\n  const transactionArray = Rlp.toHex(Hex.slice(serialized, 1))\n\n  const [\n    chainId,\n    nonce,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    gas,\n    to,\n    value,\n    data,\n    accessList,\n    yParity,\n    r,\n    s,\n  ] = transactionArray as readonly Hex.Hex[]\n\n  if (!(transactionArray.length === 9 || transactionArray.length === 12))\n    throw new TransactionEnvelope.InvalidSerializedError({\n      attributes: {\n        chainId,\n        nonce,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n        gas,\n        to,\n        value,\n        data,\n        accessList,\n        ...(transactionArray.length > 9\n          ? {\n              yParity,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serialized,\n      type,\n    })\n\n  let transaction = {\n    chainId: Number(chainId),\n    type,\n  } as TxEnvelopeEip1559\n  if (Hex.validate(to) && to !== '0x') transaction.to = to\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas)\n  if (Hex.validate(data) && data !== '0x') transaction.data = data\n  if (Hex.validate(nonce))\n    transaction.nonce = nonce === '0x' ? 0n : BigInt(nonce)\n  if (Hex.validate(value) && value !== '0x') transaction.value = BigInt(value)\n  if (Hex.validate(maxFeePerGas) && maxFeePerGas !== '0x')\n    transaction.maxFeePerGas = BigInt(maxFeePerGas)\n  if (Hex.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas)\n  if (accessList!.length !== 0 && accessList !== '0x')\n    transaction.accessList = AccessList.fromTupleList(accessList as any)\n\n  const signature =\n    r && s && yParity ? Signature.fromTuple([yParity, r, s]) : undefined\n  if (signature)\n    transaction = {\n      ...transaction,\n      ...signature,\n    } as TxEnvelopeEip1559\n\n  assert(transaction)\n\n  return transaction\n}\n\nexport declare namespace deserialize {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an arbitrary transaction object into an EIP-1559 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TxEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TxEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TxEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TxEnvelopeEip1559.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip1559',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-1559 Transaction Envelope from a {@link ox#TxEnvelopeEip1559.Serialized} value.\n *\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TxEnvelopeEip1559.from('0x02f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip1559',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-1559 Transaction Envelope.\n */\nexport function from<\n  const envelope extends UnionPartialBy<TxEnvelopeEip1559, 'type'> | Serialized,\n  const signature extends Signature.Signature | undefined = undefined,\n>(\n  envelope: envelope | UnionPartialBy<TxEnvelopeEip1559, 'type'> | Serialized,\n  options: from.Options<signature> = {},\n): from.ReturnType<envelope, signature> {\n  const { signature } = options\n\n  const envelope_ = (\n    typeof envelope === 'string' ? deserialize(envelope) : envelope\n  ) as TxEnvelopeEip1559\n\n  assert(envelope_)\n\n  return {\n    ...envelope_,\n    ...(signature ? Signature.from(signature) : {}),\n    type: 'eip1559',\n  } as never\n}\n\nexport declare namespace from {\n  type Options<signature extends Signature.Signature | undefined = undefined> =\n    {\n      signature?: signature | Signature.Signature | undefined\n    }\n\n  type ReturnType<\n    envelope extends UnionPartialBy<TxEnvelopeEip1559, 'type'> | Hex.Hex =\n      | TxEnvelopeEip1559\n      | Hex.Hex,\n    signature extends Signature.Signature | undefined = undefined,\n  > = Compute<\n    envelope extends Hex.Hex\n      ? TxEnvelopeEip1559\n      : Assign<\n          envelope,\n          (signature extends Signature.Signature ? Readonly<signature> : {}) & {\n            readonly type: 'eip1559'\n          }\n        >\n  >\n\n  type ErrorType =\n    | deserialize.ErrorType\n    | assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the payload to sign for a {@link ox#TxEnvelopeEip1559.TxEnvelopeEip1559}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Secp256k1, TxEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TxEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TxEnvelopeEip1559.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(\n  envelope: TxEnvelopeEip1559,\n): getSignPayload.ReturnType {\n  return hash(envelope, { presign: true })\n}\n\nexport declare namespace getSignPayload {\n  type ReturnType = Hex.Hex\n\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes a {@link ox#TxEnvelopeEip1559.TxEnvelopeEip1559}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TxEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TxEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TxEnvelopeEip1559.from(envelope, { signature })\n *\n * const hash = TxEnvelopeEip1559.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-1559 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash<presign extends boolean = false>(\n  envelope: TxEnvelopeEip1559<presign extends true ? false : true>,\n  options: hash.Options<presign> = {},\n): hash.ReturnType {\n  const { presign } = options\n  return Hash.keccak256(\n    serialize({\n      ...envelope,\n      ...(presign\n        ? {\n            r: undefined,\n            s: undefined,\n            yParity: undefined,\n            v: undefined,\n          }\n        : {}),\n    }),\n  )\n}\n\nexport declare namespace hash {\n  type Options<presign extends boolean = false> = {\n    /** Whether to hash this transaction for signing. @default false */\n    presign?: presign | boolean | undefined\n  }\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | serialize.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#TxEnvelopeEip1559.TxEnvelopeEip1559}.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TxEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TxEnvelopeEip1559.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TxEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TxEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TxEnvelopeEip1559.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(\n  envelope: PartialBy<TxEnvelopeEip1559, 'type'>,\n  options: serialize.Options = {},\n): Serialized {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n    input,\n  } = envelope\n\n  assert(envelope)\n\n  const accessTupleList = AccessList.toTupleList(accessList)\n\n  const signature = Signature.extract(options.signature || envelope)\n\n  const serialized = [\n    Hex.fromNumber(chainId),\n    nonce ? Hex.fromNumber(nonce) : '0x',\n    maxPriorityFeePerGas ? Hex.fromNumber(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? Hex.fromNumber(maxFeePerGas) : '0x',\n    gas ? Hex.fromNumber(gas) : '0x',\n    to ?? '0x',\n    value ? Hex.fromNumber(value) : '0x',\n    data ?? input ?? '0x',\n    accessTupleList,\n    ...(signature ? Signature.toTuple(signature) : []),\n  ]\n\n  return Hex.concat(serializedType, Rlp.fromHex(serialized)) as Serialized\n}\n\nexport declare namespace serialize {\n  type Options = {\n    /** Signature to append to the serialized Transaction Envelope. */\n    signature?: Signature.Signature | undefined\n  }\n\n  type ErrorType =\n    | assert.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Signature.toTuple.ErrorType\n    | Hex.concat.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#TxEnvelopeEip1559.TxEnvelopeEip1559} to an {@link ox#TxEnvelopeEip1559.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TxEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TxEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TxEnvelopeEip1559.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-1559 transaction envelope to convert.\n * @returns An RPC-formatted EIP-1559 transaction envelope.\n */\nexport function toRpc(envelope: Omit<TxEnvelopeEip1559, 'type'>): Rpc {\n  const signature = Signature.extract(envelope)\n\n  return {\n    ...envelope,\n    chainId: Hex.fromNumber(envelope.chainId),\n    data: envelope.data ?? envelope.input,\n    type: '0x2',\n    ...(typeof envelope.gas === 'bigint'\n      ? { gas: Hex.fromNumber(envelope.gas) }\n      : {}),\n    ...(typeof envelope.nonce === 'bigint'\n      ? { nonce: Hex.fromNumber(envelope.nonce) }\n      : {}),\n    ...(typeof envelope.value === 'bigint'\n      ? { value: Hex.fromNumber(envelope.value) }\n      : {}),\n    ...(typeof envelope.maxFeePerGas === 'bigint'\n      ? { maxFeePerGas: Hex.fromNumber(envelope.maxFeePerGas) }\n      : {}),\n    ...(typeof envelope.maxPriorityFeePerGas === 'bigint'\n      ? {\n          maxPriorityFeePerGas: Hex.fromNumber(envelope.maxPriorityFeePerGas),\n        }\n      : {}),\n    ...(signature ? Signature.toRpc(signature) : {}),\n  } as never\n}\n\nexport declare namespace toRpc {\n  export type ErrorType = Signature.extract.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Validates a {@link ox#TxEnvelopeEip1559.TxEnvelopeEip1559}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559, Value } from 'ox'\n *\n * const valid = TxEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope: PartialBy<TxEnvelopeEip1559, 'type'>) {\n  try {\n    assert(envelope)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as AccessList from './AccessList.js'\nimport * as Address from './Address.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type {\n  Assign,\n  Compute,\n  PartialBy,\n  UnionPartialBy,\n} from './internal/types.js'\nimport * as Rlp from './Rlp.js'\nimport * as Signature from './Signature.js'\nimport * as TransactionEnvelope from './TxEnvelope.js'\n\nexport type TxEnvelopeEip2930<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = Type,\n> = Compute<\n  TransactionEnvelope.Base<type, signed, bigintType, numberType> & {\n    /** EIP-2930 Access List. */\n    accessList?: AccessList.AccessList | undefined\n    /** Base fee per gas. */\n    gasPrice?: bigintType | undefined\n  }\n>\n\nexport type Rpc<signed extends boolean = boolean> = TxEnvelopeEip2930<\n  signed,\n  Hex.Hex,\n  Hex.Hex,\n  '0x1'\n>\n\nexport type Serialized = `${SerializedType}${string}`\n\nexport const serializedType = '0x01' as const\nexport type SerializedType = typeof serializedType\n\nexport type Signed = TxEnvelopeEip2930<true>\n\nexport const type = 'eip2930' as const\nexport type Type = typeof type\n\n/**\n * Asserts a {@link ox#TxEnvelopeEip2930.TxEnvelopeEip2930} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip2930, Value } from 'ox'\n *\n * TxEnvelopeEip2930.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope: PartialBy<TxEnvelopeEip2930, 'type'>) {\n  const { chainId, gasPrice, to } = envelope\n  if (chainId <= 0)\n    throw new TransactionEnvelope.InvalidChainIdError({ chainId })\n  if (to) Address.assert(to, { strict: false })\n  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)\n    throw new TransactionEnvelope.GasPriceTooHighError({ gasPrice })\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | Address.assert.ErrorType\n    | TransactionEnvelope.InvalidChainIdError\n    | TransactionEnvelope.GasPriceTooHighError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#TxEnvelopeEip2930.TxEnvelopeEip2930} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TxEnvelopeEip2930.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'eip2930',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(serialized: Serialized): TxEnvelopeEip2930 {\n  const transactionArray = Rlp.toHex(Hex.slice(serialized, 1))\n\n  const [\n    chainId,\n    nonce,\n    gasPrice,\n    gas,\n    to,\n    value,\n    data,\n    accessList,\n    yParity,\n    r,\n    s,\n  ] = transactionArray as readonly Hex.Hex[]\n\n  if (!(transactionArray.length === 8 || transactionArray.length === 11))\n    throw new TransactionEnvelope.InvalidSerializedError({\n      attributes: {\n        chainId,\n        nonce,\n        gasPrice,\n        gas,\n        to,\n        value,\n        data,\n        accessList,\n        ...(transactionArray.length > 8\n          ? {\n              yParity,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serialized,\n      type,\n    })\n\n  let transaction = {\n    chainId: Number(chainId as Hex.Hex),\n    type,\n  } as TxEnvelopeEip2930\n  if (Hex.validate(to) && to !== '0x') transaction.to = to\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas)\n  if (Hex.validate(data) && data !== '0x') transaction.data = data\n  if (Hex.validate(nonce))\n    transaction.nonce = nonce === '0x' ? 0n : BigInt(nonce)\n  if (Hex.validate(value) && value !== '0x') transaction.value = BigInt(value)\n  if (Hex.validate(gasPrice) && gasPrice !== '0x')\n    transaction.gasPrice = BigInt(gasPrice)\n  if (accessList!.length !== 0 && accessList !== '0x')\n    transaction.accessList = AccessList.fromTupleList(accessList as any)\n\n  const signature =\n    r && s && yParity ? Signature.fromTuple([yParity, r, s]) : undefined\n  if (signature)\n    transaction = {\n      ...transaction,\n      ...signature,\n    } as TxEnvelopeEip2930\n\n  assert(transaction)\n\n  return transaction\n}\n\nexport declare namespace deserialize {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an arbitrary transaction object into an EIP-2930 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TxEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TxEnvelopeEip2930.from({\n *   chainId: 1,\n *   accessList: [...],\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TxEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TxEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TxEnvelopeEip2930.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip2930',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-2930 Transaction Envelope from a {@link ox#TxEnvelopeEip2930.Serialized} value.\n *\n * ```ts twoslash\n * import { TxEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TxEnvelopeEip2930.from('0x01f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip2930',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A {@link ox#TxEnvelopeEip2930.TxEnvelopeEip2930}\n */\nexport function from<\n  const envelope extends UnionPartialBy<TxEnvelopeEip2930, 'type'> | Serialized,\n  const signature extends Signature.Signature | undefined = undefined,\n>(\n  envelope: envelope | UnionPartialBy<TxEnvelopeEip2930, 'type'> | Serialized,\n  options: from.Options<signature> = {},\n): from.ReturnType<envelope, signature> {\n  const { signature } = options\n\n  const envelope_ = (\n    typeof envelope === 'string' ? deserialize(envelope) : envelope\n  ) as TxEnvelopeEip2930\n\n  assert(envelope_)\n\n  return {\n    ...envelope_,\n    ...(signature ? Signature.from(signature) : {}),\n    type: 'eip2930',\n  } as never\n}\n\nexport declare namespace from {\n  type Options<signature extends Signature.Signature | undefined = undefined> =\n    {\n      signature?: signature | Signature.Signature | undefined\n    }\n\n  type ReturnType<\n    envelope extends UnionPartialBy<TxEnvelopeEip2930, 'type'> | Hex.Hex =\n      | TxEnvelopeEip2930\n      | Hex.Hex,\n    signature extends Signature.Signature | undefined = undefined,\n  > = Compute<\n    envelope extends Hex.Hex\n      ? TxEnvelopeEip2930\n      : Assign<\n          envelope,\n          (signature extends Signature.Signature ? Readonly<signature> : {}) & {\n            readonly type: 'eip2930'\n          }\n        >\n  >\n\n  type ErrorType =\n    | deserialize.ErrorType\n    | assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the payload to sign for a {@link ox#TxEnvelopeEip2930.TxEnvelopeEip2930}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Secp256k1, TxEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TxEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TxEnvelopeEip2930.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(\n  envelope: TxEnvelopeEip2930,\n): getSignPayload.ReturnType {\n  return hash(envelope, { presign: true })\n}\n\nexport declare namespace getSignPayload {\n  type ReturnType = Hex.Hex\n\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes a {@link ox#TxEnvelopeEip2930.TxEnvelopeEip2930}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TxEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TxEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TxEnvelopeEip2930.from(envelope, {\n *   signature,\n * })\n *\n * const hash = TxEnvelopeEip2930.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-2930 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash<presign extends boolean = false>(\n  envelope: TxEnvelopeEip2930<presign extends true ? false : true>,\n  options: hash.Options<presign> = {},\n): hash.ReturnType {\n  const { presign } = options\n  return Hash.keccak256(\n    serialize({\n      ...envelope,\n      ...(presign\n        ? {\n            r: undefined,\n            s: undefined,\n            yParity: undefined,\n            v: undefined,\n          }\n        : {}),\n    }),\n  )\n}\n\nexport declare namespace hash {\n  type Options<presign extends boolean = false> = {\n    /** Whether to hash this transaction for signing. @default false */\n    presign?: presign | boolean | undefined\n  }\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | serialize.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#TxEnvelopeEip2930.TxEnvelopeEip2930}.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TxEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TxEnvelopeEip2930.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TxEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TxEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TxEnvelopeEip2930.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(\n  envelope: PartialBy<TxEnvelopeEip2930, 'type'>,\n  options: serialize.Options = {},\n): Serialized {\n  const { chainId, gas, data, input, nonce, to, value, accessList, gasPrice } =\n    envelope\n\n  assert(envelope)\n\n  const accessTupleList = AccessList.toTupleList(accessList)\n\n  const signature = Signature.extract(options.signature || (envelope as any))\n\n  const serialized = [\n    Hex.fromNumber(chainId),\n    nonce ? Hex.fromNumber(nonce) : '0x',\n    gasPrice ? Hex.fromNumber(gasPrice) : '0x',\n    gas ? Hex.fromNumber(gas) : '0x',\n    to ?? '0x',\n    value ? Hex.fromNumber(value) : '0x',\n    data ?? input ?? '0x',\n    accessTupleList,\n    ...(signature ? Signature.toTuple(signature) : []),\n  ] as const\n\n  return Hex.concat('0x01', Rlp.fromHex(serialized)) as Serialized\n}\n\nexport declare namespace serialize {\n  type Options = {\n    /** Signature to append to the serialized Transaction Envelope. */\n    signature?: Signature.Signature | undefined\n  }\n\n  type ErrorType =\n    | assert.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Signature.toTuple.ErrorType\n    | Hex.concat.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#TxEnvelopeEip2930.TxEnvelopeEip2930} to an {@link ox#TxEnvelopeEip2930.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TxEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TxEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TxEnvelopeEip2930.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-2930 transaction envelope to convert.\n * @returns An RPC-formatted EIP-2930 transaction envelope.\n */\nexport function toRpc(envelope: Omit<TxEnvelopeEip2930, 'type'>): Rpc {\n  const signature = Signature.extract(envelope)!\n\n  return {\n    ...envelope,\n    chainId: Hex.fromNumber(envelope.chainId),\n    data: envelope.data ?? envelope.input,\n    ...(typeof envelope.gas === 'bigint'\n      ? { gas: Hex.fromNumber(envelope.gas) }\n      : {}),\n    ...(typeof envelope.nonce === 'bigint'\n      ? { nonce: Hex.fromNumber(envelope.nonce) }\n      : {}),\n    ...(typeof envelope.value === 'bigint'\n      ? { value: Hex.fromNumber(envelope.value) }\n      : {}),\n    ...(typeof envelope.gasPrice === 'bigint'\n      ? { gasPrice: Hex.fromNumber(envelope.gasPrice) }\n      : {}),\n    type: '0x1',\n    ...(signature ? Signature.toRpc(signature) : {}),\n  } as never\n}\n\nexport declare namespace toRpc {\n  export type ErrorType = Signature.extract.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Validates a {@link ox#TxEnvelopeEip2930.TxEnvelopeEip2930}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip2930, Value } from 'ox'\n *\n * const valid = TxEnvelopeEip2930.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope: PartialBy<TxEnvelopeEip2930, 'type'>) {\n  try {\n    assert(envelope)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as AccessList from './AccessList.js'\nimport * as Blobs from './Blobs.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type {\n  Assign,\n  Compute,\n  PartialBy,\n  UnionPartialBy,\n} from './internal/types.js'\nimport * as Kzg from './Kzg.js'\nimport * as Rlp from './Rlp.js'\nimport * as Signature from './Signature.js'\nimport * as TransactionEnvelope from './TxEnvelope.js'\nimport * as TxEnvelopeEip1559 from './TxEnvelopeEip1559.js'\n\nexport type TxEnvelopeEip4844<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = Type,\n> = Compute<\n  TransactionEnvelope.Base<type, signed, bigintType, numberType> & {\n    /** EIP-2930 Access List. */\n    accessList?: AccessList.AccessList | undefined\n    /** Versioned hashes of blobs to be included in the transaction. */\n    blobVersionedHashes: readonly Hex.Hex[]\n    /** Maximum total fee per gas sender is willing to pay for blob gas (in wei). */\n    maxFeePerBlobGas?: bigintType | undefined\n    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */\n    maxFeePerGas?: bigintType | undefined\n    /** Max priority fee per gas (in wei). */\n    maxPriorityFeePerGas?: bigintType | undefined\n    /** The sidecars associated with this transaction. When defined, the envelope is in the \"network wrapper\" format. */\n    sidecars?: readonly Blobs.BlobSidecar<Hex.Hex>[] | undefined\n  }\n>\n\nexport type Rpc<signed extends boolean = boolean> = TxEnvelopeEip4844<\n  signed,\n  Hex.Hex,\n  Hex.Hex,\n  '0x3'\n>\n\nexport type Serialized = `${SerializedType}${string}`\n\nexport const serializedType = '0x03' as const\nexport type SerializedType = typeof serializedType\n\nexport type Signed = TxEnvelopeEip4844<true>\n\nexport const type = 'eip4844' as const\nexport type Type = 'eip4844'\n\n/**\n * Asserts a {@link ox#TxEnvelopeEip4844.TxEnvelopeEip4844} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip4844, Value } from 'ox'\n *\n * TxEnvelopeEip4844.assert({\n *   blobVersionedHashes: [],\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: EmptyBlobVersionedHashesError: Blob versioned hashes must not be empty.\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope: PartialBy<TxEnvelopeEip4844, 'type'>) {\n  const { blobVersionedHashes } = envelope\n  if (blobVersionedHashes) {\n    if (blobVersionedHashes.length === 0)\n      throw new Blobs.EmptyBlobVersionedHashesError()\n    for (const hash of blobVersionedHashes) {\n      const size = Hex.size(hash)\n      const version = Hex.toNumber(Hex.slice(hash, 0, 1))\n      if (size !== 32)\n        throw new Blobs.InvalidVersionedHashSizeError({ hash, size })\n      if (version !== Kzg.versionedHashVersion)\n        throw new Blobs.InvalidVersionedHashVersionError({\n          hash,\n          version,\n        })\n    }\n  }\n  TxEnvelopeEip1559.assert(\n    envelope as {} as TxEnvelopeEip1559.TxEnvelopeEip1559,\n  )\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | TxEnvelopeEip1559.assert.ErrorType\n    | Hex.size.ErrorType\n    | Hex.toNumber.ErrorType\n    | Hex.slice.ErrorType\n    | Blobs.EmptyBlobVersionedHashesError\n    | Blobs.InvalidVersionedHashSizeError\n    | Blobs.InvalidVersionedHashVersionError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#TxEnvelopeEip4844.TxEnvelopeEip4844} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip4844 } from 'ox'\n *\n * const envelope = TxEnvelopeEip4844.deserialize('0x03ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   blobVersionedHashes: [...],\n * // @log:   type: 'eip4844',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(\n  serialized: Serialized,\n): Compute<TxEnvelopeEip4844> {\n  const transactionOrWrapperArray = Rlp.toHex(Hex.slice(serialized, 1))\n\n  const hasNetworkWrapper = transactionOrWrapperArray.length === 4\n\n  const transactionArray = hasNetworkWrapper\n    ? transactionOrWrapperArray[0]!\n    : transactionOrWrapperArray\n  const wrapperArray = hasNetworkWrapper\n    ? transactionOrWrapperArray.slice(1)\n    : []\n\n  const [\n    chainId,\n    nonce,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    gas,\n    to,\n    value,\n    data,\n    accessList,\n    maxFeePerBlobGas,\n    blobVersionedHashes,\n    yParity,\n    r,\n    s,\n  ] = transactionArray\n  const [blobs, commitments, proofs] = wrapperArray\n\n  if (!(transactionArray.length === 11 || transactionArray.length === 14))\n    throw new TransactionEnvelope.InvalidSerializedError({\n      attributes: {\n        chainId,\n        nonce,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n        gas,\n        to,\n        value,\n        data,\n        accessList,\n        ...(transactionArray.length > 9\n          ? {\n              yParity,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serialized,\n      type,\n    })\n\n  let transaction = {\n    blobVersionedHashes: blobVersionedHashes as Hex.Hex[],\n    chainId: Number(chainId),\n    type,\n  } as TxEnvelopeEip4844\n  if (Hex.validate(to) && to !== '0x') transaction.to = to\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas)\n  if (Hex.validate(data) && data !== '0x') transaction.data = data\n  if (Hex.validate(nonce))\n    transaction.nonce = nonce === '0x' ? 0n : BigInt(nonce)\n  if (Hex.validate(value) && value !== '0x') transaction.value = BigInt(value)\n  if (Hex.validate(maxFeePerBlobGas) && maxFeePerBlobGas !== '0x')\n    transaction.maxFeePerBlobGas = BigInt(maxFeePerBlobGas)\n  if (Hex.validate(maxFeePerGas) && maxFeePerGas !== '0x')\n    transaction.maxFeePerGas = BigInt(maxFeePerGas)\n  if (Hex.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas)\n  if (accessList?.length !== 0 && accessList !== '0x')\n    transaction.accessList = AccessList.fromTupleList(accessList as any)\n  if (blobs && commitments && proofs)\n    transaction.sidecars = Blobs.toSidecars(blobs as Hex.Hex[], {\n      commitments: commitments as Hex.Hex[],\n      proofs: proofs as Hex.Hex[],\n    })\n\n  const signature =\n    r && s && yParity\n      ? Signature.fromTuple([yParity as Hex.Hex, r as Hex.Hex, s as Hex.Hex])\n      : undefined\n  if (signature)\n    transaction = {\n      ...transaction,\n      ...signature,\n    } as TxEnvelopeEip4844\n\n  assert(transaction)\n\n  return transaction\n}\n\nexport declare namespace deserialize {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an arbitrary transaction object into an EIP-4844 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, TxEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TxEnvelopeEip4844.from({\n *   chainId: 1,\n *   blobVersionedHashes,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TxEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const blobVersionedHashes = Blobs.sidecarsToVersionedHashes(sidecars)\n *\n * const envelope = TxEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeEip4844.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TxEnvelopeEip4844.from(envelope, { // [!code focus]\n *   sidecars, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   blobVersionedHashes: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerBlobGas: 3000000000n,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip4844',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-4844 Transaction Envelope from a {@link ox#TxEnvelopeEip4844.Serialized} value.\n *\n * ```ts twoslash\n * import { TxEnvelopeEip4844 } from 'ox'\n *\n * const envelope = TxEnvelopeEip4844.from('0x03f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   blobVersionedHashes: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip4844',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-4844 Transaction Envelope.\n */\nexport function from<\n  const envelope extends UnionPartialBy<TxEnvelopeEip4844, 'type'> | Serialized,\n  const signature extends Signature.Signature | undefined = undefined,\n>(\n  envelope: envelope | UnionPartialBy<TxEnvelopeEip4844, 'type'> | Serialized,\n  options: from.Options<signature> = {},\n): from.ReturnType<envelope, signature> {\n  const { signature } = options\n\n  const envelope_ = (\n    typeof envelope === 'string' ? deserialize(envelope) : envelope\n  ) as TxEnvelopeEip4844\n\n  assert(envelope_)\n\n  return {\n    ...envelope_,\n    ...(signature ? Signature.from(signature) : {}),\n    type: 'eip4844',\n  } as never\n}\n\nexport declare namespace from {\n  type Options<signature extends Signature.Signature | undefined = undefined> =\n    {\n      signature?: signature | Signature.Signature | undefined\n    }\n\n  type ReturnType<\n    envelope extends UnionPartialBy<TxEnvelopeEip4844, 'type'> | Hex.Hex =\n      | TxEnvelopeEip4844\n      | Hex.Hex,\n    signature extends Signature.Signature | undefined = undefined,\n  > = Compute<\n    envelope extends Hex.Hex\n      ? TxEnvelopeEip4844\n      : Assign<\n          envelope,\n          (signature extends Signature.Signature ? Readonly<signature> : {}) & {\n            readonly type: 'eip4844'\n          }\n        >\n  >\n\n  type ErrorType =\n    | deserialize.ErrorType\n    | assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the payload to sign for a {@link ox#TxEnvelopeEip4844.TxEnvelopeEip4844}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TxEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TxEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TxEnvelopeEip4844.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(\n  envelope: TxEnvelopeEip4844,\n): getSignPayload.ReturnType {\n  return hash(envelope, { presign: true })\n}\n\nexport declare namespace getSignPayload {\n  type ReturnType = Hex.Hex\n\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes a {@link ox#TxEnvelopeEip4844.TxEnvelopeEip4844}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, TxEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TxEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const hash = TxEnvelopeEip4844.hash(envelope) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-4844 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash<presign extends boolean = false>(\n  envelope: TxEnvelopeEip4844<presign extends true ? false : true>,\n  options: hash.Options<presign> = {},\n): hash.ReturnType {\n  const { presign } = options\n  return Hash.keccak256(\n    serialize({\n      ...envelope,\n      ...(presign\n        ? {\n            sidecars: undefined,\n            r: undefined,\n            s: undefined,\n            yParity: undefined,\n            v: undefined,\n          }\n        : {}),\n    }),\n  )\n}\n\nexport declare namespace hash {\n  type Options<presign extends boolean = false> = {\n    /** Whether to hash this transaction for signing. @default false */\n    presign?: presign | boolean | undefined\n  }\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | serialize.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#TxEnvelopeEip4844.TxEnvelopeEip4844}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, TxEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TxEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TxEnvelopeEip4844.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TxEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const blobVersionedHashes = Blobs.sidecarsToVersionedHashes(blobs)\n *\n * const envelope = TxEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeEip4844.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TxEnvelopeEip4844.serialize(envelope, { // [!code focus]\n *   sidecars, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(\n  envelope: PartialBy<TxEnvelopeEip4844, 'type'>,\n  options: serialize.Options = {},\n): Serialized {\n  const {\n    blobVersionedHashes,\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = envelope\n\n  assert(envelope)\n\n  const accessTupleList = AccessList.toTupleList(accessList)\n\n  const signature = Signature.extract(options.signature || envelope)\n\n  const serialized = [\n    Hex.fromNumber(chainId),\n    nonce ? Hex.fromNumber(nonce) : '0x',\n    maxPriorityFeePerGas ? Hex.fromNumber(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? Hex.fromNumber(maxFeePerGas) : '0x',\n    gas ? Hex.fromNumber(gas) : '0x',\n    to ?? '0x',\n    value ? Hex.fromNumber(value) : '0x',\n    data ?? '0x',\n    accessTupleList,\n    maxFeePerBlobGas ? Hex.fromNumber(maxFeePerBlobGas) : '0x',\n    blobVersionedHashes ?? [],\n    ...(signature ? Signature.toTuple(signature) : []),\n  ] as const\n\n  const sidecars = options.sidecars || envelope.sidecars\n  const blobs: Hex.Hex[] = []\n  const commitments: Hex.Hex[] = []\n  const proofs: Hex.Hex[] = []\n  if (sidecars)\n    for (let i = 0; i < sidecars.length; i++) {\n      const { blob, commitment, proof } = sidecars[i]!\n      blobs.push(blob)\n      commitments.push(commitment)\n      proofs.push(proof)\n    }\n\n  return Hex.concat(\n    '0x03',\n    sidecars\n      ? // If sidecars are provided, envelope turns into a \"network wrapper\":\n        Rlp.fromHex([serialized, blobs, commitments, proofs])\n      : // Otherwise, standard envelope is used:\n        Rlp.fromHex(serialized),\n  ) as Serialized\n}\n\nexport declare namespace serialize {\n  type Options = {\n    /** Signature to append to the serialized Transaction Envelope. */\n    signature?: Signature.Signature | undefined\n    /** Sidecars to append to the serialized Transaction Envelope. */\n    sidecars?: Blobs.BlobSidecars<Hex.Hex> | undefined\n  }\n\n  type ErrorType =\n    | assert.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Signature.toTuple.ErrorType\n    | Hex.concat.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#TxEnvelopeEip4844.TxEnvelopeEip4844} to an {@link ox#TxEnvelopeEip4844.Rpc}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, RpcRequest, TxEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TxEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   maxFeePerBlobGas: Value.fromGwei('20'),\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TxEnvelopeEip4844.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-4844 transaction envelope to convert.\n * @returns An RPC-formatted EIP-4844 transaction envelope.\n */\nexport function toRpc(envelope: Omit<TxEnvelopeEip4844, 'type'>): Rpc {\n  const signature = Signature.extract(envelope)\n\n  return {\n    ...envelope,\n    chainId: Hex.fromNumber(envelope.chainId),\n    data: envelope.data ?? envelope.input,\n    ...(typeof envelope.gas === 'bigint'\n      ? { gas: Hex.fromNumber(envelope.gas) }\n      : {}),\n    ...(typeof envelope.nonce === 'bigint'\n      ? { nonce: Hex.fromNumber(envelope.nonce) }\n      : {}),\n    ...(typeof envelope.value === 'bigint'\n      ? { value: Hex.fromNumber(envelope.value) }\n      : {}),\n    ...(typeof envelope.maxFeePerBlobGas === 'bigint'\n      ? { maxFeePerBlobGas: Hex.fromNumber(envelope.maxFeePerBlobGas) }\n      : {}),\n    ...(typeof envelope.maxFeePerGas === 'bigint'\n      ? { maxFeePerGas: Hex.fromNumber(envelope.maxFeePerGas) }\n      : {}),\n    ...(typeof envelope.maxPriorityFeePerGas === 'bigint'\n      ? { maxPriorityFeePerGas: Hex.fromNumber(envelope.maxPriorityFeePerGas) }\n      : {}),\n    type: '0x3',\n    ...(signature ? Signature.toRpc(signature) : {}),\n  } as never\n}\n\nexport declare namespace toRpc {\n  export type ErrorType = Signature.extract.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Validates a {@link ox#TxEnvelopeEip4844.TxEnvelopeEip4844}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip4844, Value } from 'ox'\n *\n * const valid = TxEnvelopeEip4844.assert({\n *   blobVersionedHashes: [],\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope: PartialBy<TxEnvelopeEip4844, 'type'>) {\n  try {\n    assert(envelope)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as AccessList from './AccessList.js'\nimport * as Address from './Address.js'\nimport * as Authorization from './Authorization.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type {\n  Assign,\n  Compute,\n  PartialBy,\n  UnionPartialBy,\n} from './internal/types.js'\nimport * as Rlp from './Rlp.js'\nimport * as Signature from './Signature.js'\nimport * as TransactionEnvelope from './TxEnvelope.js'\nimport * as TxEnvelopeEip1559 from './TxEnvelopeEip1559.js'\n\nexport type TxEnvelopeEip7702<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = Type,\n> = Compute<\n  TransactionEnvelope.Base<type, signed, bigintType, numberType> & {\n    /** EIP-2930 Access List. */\n    accessList?: AccessList.AccessList | undefined\n    /** EIP-7702 Authorization List. */\n    authorizationList: Authorization.ListSigned<bigintType, numberType>\n    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */\n    maxFeePerGas?: bigintType | undefined\n    /** Max priority fee per gas (in wei). */\n    maxPriorityFeePerGas?: bigintType | undefined\n  }\n>\n\nexport type Rpc<signed extends boolean = boolean> = TxEnvelopeEip7702<\n  signed,\n  Hex.Hex,\n  Hex.Hex,\n  '0x4'\n>\n\nexport type Serialized = `${SerializedType}${string}`\n\nexport type Signed = TxEnvelopeEip7702<true>\n\nexport const serializedType = '0x04' as const\nexport type SerializedType = typeof serializedType\n\nexport const type = 'eip7702' as const\nexport type Type = typeof type\n\n/**\n * Asserts a {@link ox#TxEnvelopeEip7702.TxEnvelopeEip7702} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip7702, Value } from 'ox'\n *\n * TxEnvelopeEip7702.assert({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: FeeCapTooHighError:\n * // @error: The fee cap (`masFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope: PartialBy<TxEnvelopeEip7702, 'type'>) {\n  const { authorizationList } = envelope\n  if (authorizationList) {\n    for (const authorization of authorizationList) {\n      const { address, chainId } = authorization\n      if (address) Address.assert(address, { strict: false })\n      if (Number(chainId) < 0)\n        throw new TransactionEnvelope.InvalidChainIdError({ chainId })\n    }\n  }\n  TxEnvelopeEip1559.assert(\n    envelope as {} as TxEnvelopeEip1559.TxEnvelopeEip1559,\n  )\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | Address.assert.ErrorType\n    | TransactionEnvelope.InvalidChainIdError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#TxEnvelopeEip7702.TxEnvelopeEip7702} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TxEnvelopeEip7702.deserialize('0x04ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   type: 'eip7702',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(\n  serialized: Serialized,\n): Compute<TxEnvelopeEip7702> {\n  const transactionArray = Rlp.toHex(Hex.slice(serialized, 1))\n\n  const [\n    chainId,\n    nonce,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    gas,\n    to,\n    value,\n    data,\n    accessList,\n    authorizationList,\n    yParity,\n    r,\n    s,\n  ] = transactionArray as readonly Hex.Hex[]\n\n  if (!(transactionArray.length === 10 || transactionArray.length === 13))\n    throw new TransactionEnvelope.InvalidSerializedError({\n      attributes: {\n        chainId,\n        nonce,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n        gas,\n        to,\n        value,\n        data,\n        accessList,\n        authorizationList,\n        ...(transactionArray.length > 9\n          ? {\n              yParity,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serialized,\n      type,\n    })\n\n  let transaction = {\n    chainId: Number(chainId),\n    type,\n  } as TxEnvelopeEip7702\n  if (Hex.validate(to) && to !== '0x') transaction.to = to\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas)\n  if (Hex.validate(data) && data !== '0x') transaction.data = data\n  if (Hex.validate(nonce))\n    transaction.nonce = nonce === '0x' ? 0n : BigInt(nonce)\n  if (Hex.validate(value) && value !== '0x') transaction.value = BigInt(value)\n  if (Hex.validate(maxFeePerGas) && maxFeePerGas !== '0x')\n    transaction.maxFeePerGas = BigInt(maxFeePerGas)\n  if (Hex.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas)\n  if (accessList!.length !== 0 && accessList !== '0x')\n    transaction.accessList = AccessList.fromTupleList(accessList as never)\n  if (authorizationList !== '0x')\n    transaction.authorizationList = Authorization.fromTupleList(\n      authorizationList as never,\n    )\n\n  const signature =\n    r && s && yParity ? Signature.fromTuple([yParity, r, s]) : undefined\n  if (signature)\n    transaction = {\n      ...transaction,\n      ...signature,\n    } as TxEnvelopeEip7702\n\n  assert(transaction)\n\n  return transaction\n}\n\nexport declare namespace deserialize {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an arbitrary transaction object into an EIP-7702 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { Authorization, Secp256k1, TxEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TxEnvelopeEip7702.from({ // [!code focus]\n *   authorizationList, // [!code focus]\n *   chainId: 1, // [!code focus]\n *   maxFeePerGas: Value.fromGwei('10'), // [!code focus]\n *   maxPriorityFeePerGas: Value.fromGwei('1'), // [!code focus]\n *   to: '0x0000000000000000000000000000000000000000', // [!code focus]\n *   value: Value.fromEther('1'), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TxEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TxEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TxEnvelopeEip7702.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-7702 Transaction Envelope from a {@link ox#TxEnvelopeEip7702.Serialized} value.\n *\n * ```ts twoslash\n * import { TxEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TxEnvelopeEip7702.from('0x04f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-7702 Transaction Envelope.\n */\nexport function from<\n  const envelope extends UnionPartialBy<TxEnvelopeEip7702, 'type'> | Serialized,\n  const signature extends Signature.Signature | undefined = undefined,\n>(\n  envelope: envelope | UnionPartialBy<TxEnvelopeEip7702, 'type'> | Serialized,\n  options: from.Options<signature> = {},\n): from.ReturnType<envelope, signature> {\n  const { signature } = options\n\n  const envelope_ = (\n    typeof envelope === 'string' ? deserialize(envelope) : envelope\n  ) as TxEnvelopeEip7702\n\n  assert(envelope_)\n\n  return {\n    ...envelope_,\n    ...(signature ? Signature.from(signature) : {}),\n    type: 'eip7702',\n  } as never\n}\n\nexport declare namespace from {\n  type Options<signature extends Signature.Signature | undefined = undefined> =\n    {\n      signature?: signature | Signature.Signature | undefined\n    }\n\n  type ReturnType<\n    envelope extends UnionPartialBy<TxEnvelopeEip7702, 'type'> | Hex.Hex =\n      | TxEnvelopeEip7702\n      | Hex.Hex,\n    signature extends Signature.Signature | undefined = undefined,\n  > = Compute<\n    envelope extends Hex.Hex\n      ? TxEnvelopeEip7702\n      : Assign<\n          envelope,\n          (signature extends Signature.Signature ? Readonly<signature> : {}) & {\n            readonly type: 'eip7702'\n          }\n        >\n  >\n\n  type ErrorType =\n    | deserialize.ErrorType\n    | assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the payload to sign for a {@link ox#TxEnvelopeEip7702.TxEnvelopeEip7702}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TxEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TxEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TxEnvelopeEip7702.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(\n  envelope: TxEnvelopeEip7702,\n): getSignPayload.ReturnType {\n  return hash(envelope, { presign: true })\n}\n\nexport declare namespace getSignPayload {\n  type ReturnType = Hex.Hex\n\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes a {@link ox#TxEnvelopeEip7702.TxEnvelopeEip7702}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TxEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TxEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TxEnvelopeEip7702.from(envelope, { signature })\n *\n * const hash = TxEnvelopeEip7702.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-7702 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash<presign extends boolean = false>(\n  envelope: TxEnvelopeEip7702<presign extends true ? false : true>,\n  options: hash.Options<presign> = {},\n): hash.ReturnType {\n  const { presign } = options\n  return Hash.keccak256(\n    serialize({\n      ...envelope,\n      ...(presign\n        ? {\n            r: undefined,\n            s: undefined,\n            yParity: undefined,\n          }\n        : {}),\n    }),\n  )\n}\n\nexport declare namespace hash {\n  type Options<presign extends boolean = false> = {\n    /** Whether to hash this transaction for signing. @default false */\n    presign?: presign | boolean | undefined\n  }\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | serialize.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#TxEnvelopeEip7702.TxEnvelopeEip7702}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Authorization, Secp256k1, TxEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TxEnvelopeEip7702.from({\n *   authorizationList,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TxEnvelopeEip7702.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TxEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TxEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TxEnvelopeEip7702.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(\n  envelope: PartialBy<TxEnvelopeEip7702, 'type'>,\n  options: serialize.Options = {},\n): Serialized {\n  const {\n    authorizationList,\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n    input,\n  } = envelope\n\n  assert(envelope)\n\n  const accessTupleList = AccessList.toTupleList(accessList)\n  const authorizationTupleList = Authorization.toTupleList(authorizationList)\n\n  const signature = Signature.extract(options.signature || envelope)\n\n  const serialized = [\n    Hex.fromNumber(chainId),\n    nonce ? Hex.fromNumber(nonce) : '0x',\n    maxPriorityFeePerGas ? Hex.fromNumber(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? Hex.fromNumber(maxFeePerGas) : '0x',\n    gas ? Hex.fromNumber(gas) : '0x',\n    to ?? '0x',\n    value ? Hex.fromNumber(value) : '0x',\n    data ?? input ?? '0x',\n    accessTupleList,\n    authorizationTupleList,\n    ...(signature ? Signature.toTuple(signature) : []),\n  ]\n\n  return Hex.concat(serializedType, Rlp.fromHex(serialized)) as Serialized\n}\n\nexport declare namespace serialize {\n  type Options = {\n    /** Signature to append to the serialized Transaction Envelope. */\n    signature?: Signature.Signature | undefined\n  }\n\n  type ErrorType =\n    | assert.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Signature.toTuple.ErrorType\n    | Hex.concat.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Validates a {@link ox#TxEnvelopeEip7702.TxEnvelopeEip7702}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip7702, Value } from 'ox'\n *\n * const valid = TxEnvelopeEip7702.validate({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope: PartialBy<TxEnvelopeEip7702, 'type'>) {\n  try {\n    assert(envelope)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as Address from './Address.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type {\n  Assign,\n  Branded,\n  Compute,\n  PartialBy,\n  UnionPartialBy,\n} from './internal/types.js'\nimport * as Rlp from './Rlp.js'\nimport * as Signature from './Signature.js'\nimport * as TransactionEnvelope from './TxEnvelope.js'\n\nexport type TxEnvelopeLegacy<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = Type,\n> = Compute<\n  PartialBy<\n    TransactionEnvelope.Base<type, signed, bigintType, numberType>,\n    'chainId'\n  > & {\n    /** Base fee per gas. */\n    gasPrice?: bigintType | undefined\n  }\n>\n\nexport type Rpc<signed extends boolean = boolean> = TxEnvelopeLegacy<\n  signed,\n  Hex.Hex,\n  Hex.Hex,\n  '0x0'\n>\n\nexport type Serialized = Branded<`0x${string}`, 'legacy'>\n\nexport type Signed = TxEnvelopeLegacy<true>\n\nexport const type = 'legacy'\nexport type Type = typeof type\n\n/**\n * Asserts a {@link ox#TxEnvelopeLegacy.TxEnvelopeLegacy} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeLegacy, Value } from 'ox'\n *\n * TxEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope: PartialBy<TxEnvelopeLegacy, 'type'>) {\n  const { chainId, gasPrice, to } = envelope\n  if (to) Address.assert(to, { strict: false })\n  if (typeof chainId !== 'undefined' && chainId <= 0)\n    throw new TransactionEnvelope.InvalidChainIdError({ chainId })\n  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)\n    throw new TransactionEnvelope.GasPriceTooHighError({ gasPrice })\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | Address.assert.ErrorType\n    | TransactionEnvelope.InvalidChainIdError\n    | TransactionEnvelope.GasPriceTooHighError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#TxEnvelopeLegacy.TxEnvelopeLegacy} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeLegacy } from 'ox'\n *\n * const envelope = TxEnvelopeLegacy.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'legacy',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(serialized: Hex.Hex): Compute<TxEnvelopeLegacy> {\n  const tuple = Rlp.toHex(serialized)\n\n  const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] =\n    tuple as readonly Hex.Hex[]\n\n  if (!(tuple.length === 6 || tuple.length === 9))\n    throw new TransactionEnvelope.InvalidSerializedError({\n      attributes: {\n        nonce,\n        gasPrice,\n        gas,\n        to,\n        value,\n        data,\n        ...(tuple.length > 6\n          ? {\n              v: chainIdOrV_,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serialized,\n      type,\n    })\n\n  const transaction = {\n    type,\n  } as TxEnvelopeLegacy\n  if (Hex.validate(to) && to !== '0x') transaction.to = to\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas)\n  if (Hex.validate(data) && data !== '0x') transaction.data = data\n  if (Hex.validate(nonce))\n    transaction.nonce = nonce === '0x' ? 0n : BigInt(nonce)\n  if (Hex.validate(value) && value !== '0x') transaction.value = BigInt(value)\n  if (Hex.validate(gasPrice) && gasPrice !== '0x')\n    transaction.gasPrice = BigInt(gasPrice)\n\n  if (tuple.length === 6) return transaction\n\n  const chainIdOrV =\n    Hex.validate(chainIdOrV_) && chainIdOrV_ !== '0x'\n      ? Number(chainIdOrV_ as Hex.Hex)\n      : 0\n\n  if (s === '0x' && r === '0x') {\n    if (chainIdOrV > 0) transaction.chainId = Number(chainIdOrV)\n    return transaction\n  }\n\n  const v = chainIdOrV\n  const chainId: number | undefined = Math.floor((v - 35) / 2)\n  if (chainId > 0) transaction.chainId = chainId\n  else if (v !== 27 && v !== 28) throw new Signature.InvalidVError({ value: v })\n\n  transaction.yParity = Signature.vToYParity(v)\n  transaction.v = v\n  transaction.s = s === '0x' ? 0n : BigInt(s!)\n  transaction.r = r === '0x' ? 0n : BigInt(r!)\n\n  assert(transaction)\n\n  return transaction\n}\n\nexport declare namespace deserialize {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an arbitrary transaction object into a legacy Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TxEnvelopeLegacy.from({\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TxEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TxEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TxEnvelopeLegacy.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an legacy Transaction Envelope from a {@link ox#TxEnvelopeLegacy.Serialized} value.\n *\n * ```ts twoslash\n * import { TxEnvelopeLegacy } from 'ox'\n *\n * const envelope = TxEnvelopeLegacy.from('0xf858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'legacy',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A legacy Transaction Envelope.\n */\nexport function from<\n  const envelope extends UnionPartialBy<TxEnvelopeLegacy, 'type'> | Hex.Hex,\n  const signature extends Signature.Signature | undefined = undefined,\n>(\n  envelope: envelope | UnionPartialBy<TxEnvelopeLegacy, 'type'> | Hex.Hex,\n  options: from.Options<signature> = {},\n): from.ReturnType<envelope, signature> {\n  const { signature } = options\n\n  const envelope_ = (\n    typeof envelope === 'string' ? deserialize(envelope) : envelope\n  ) as TxEnvelopeLegacy\n\n  assert(envelope_)\n\n  const signature_ = (() => {\n    if (!signature) return {}\n    const s = Signature.from(signature) as any\n    s.v = Signature.yParityToV(s.yParity)\n    return s\n  })()\n\n  return {\n    ...envelope_,\n    ...signature_,\n    type: 'legacy',\n  } as never\n}\n\nexport declare namespace from {\n  type Options<signature extends Signature.Signature | undefined = undefined> =\n    {\n      signature?: signature | Signature.Signature | undefined\n    }\n\n  type ReturnType<\n    envelope extends UnionPartialBy<TxEnvelopeLegacy, 'type'> | Hex.Hex =\n      | TxEnvelopeLegacy\n      | Hex.Hex,\n    signature extends Signature.Signature | undefined = undefined,\n  > = Compute<\n    envelope extends Hex.Hex\n      ? TxEnvelopeLegacy\n      : Assign<\n          envelope,\n          (signature extends Signature.Signature\n            ? Readonly<\n                signature & {\n                  v: signature['yParity'] extends 0 ? 27 : 28\n                }\n              >\n            : {}) & {\n            readonly type: 'legacy'\n          }\n        >\n  >\n\n  type ErrorType =\n    | deserialize.ErrorType\n    | assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the payload to sign for a {@link ox#TxEnvelopeLegacy.TxEnvelopeLegacy}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TxEnvelopeLegacy } from 'ox'\n *\n * const envelope = TxEnvelopeLegacy.from({\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TxEnvelopeLegacy.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(\n  envelope: TxEnvelopeLegacy<false>,\n): getSignPayload.ReturnType {\n  return hash(envelope, { presign: true })\n}\n\nexport declare namespace getSignPayload {\n  type ReturnType = Hex.Hex\n\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes a {@link ox#TxEnvelopeLegacy.TxEnvelopeLegacy}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TxEnvelopeLegacy } from 'ox'\n *\n * const envelope = TxEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TxEnvelopeLegacy.from(envelope, { signature })\n *\n * const hash = TxEnvelopeLegacy.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The Legacy Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash<presign extends boolean = false>(\n  envelope: TxEnvelopeLegacy<presign extends true ? false : true>,\n  options: hash.Options<presign> = {},\n): hash.ReturnType {\n  const { presign } = options\n  return Hash.keccak256(\n    serialize({\n      ...envelope,\n      ...(presign\n        ? {\n            r: undefined,\n            s: undefined,\n            yParity: undefined,\n            v: undefined,\n          }\n        : {}),\n    }),\n  )\n}\n\nexport declare namespace hash {\n  type Options<presign extends boolean = false> = {\n    /** Whether to hash this transaction for signing. @default false */\n    presign?: presign | boolean | undefined\n  }\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | serialize.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#TxEnvelopeLegacy.TxEnvelopeLegacy}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TxEnvelopeLegacy } from 'ox'\n *\n * const envelope = TxEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TxEnvelopeLegacy.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TxEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TxEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TxEnvelopeLegacy.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(\n  envelope: PartialBy<TxEnvelopeLegacy, 'type'>,\n  options: serialize.Options = {},\n): Serialized {\n  const { chainId = 0, gas, data, input, nonce, to, value, gasPrice } = envelope\n\n  assert(envelope)\n\n  let serialized = [\n    nonce ? Hex.fromNumber(nonce) : '0x',\n    gasPrice ? Hex.fromNumber(gasPrice) : '0x',\n    gas ? Hex.fromNumber(gas) : '0x',\n    to ?? '0x',\n    value ? Hex.fromNumber(value) : '0x',\n    data ?? input ?? '0x',\n  ]\n\n  const signature = (() => {\n    if (options.signature)\n      return {\n        r: options.signature.r,\n        s: options.signature.s,\n        v: Signature.yParityToV(options.signature.yParity),\n      }\n\n    if (typeof envelope.r === 'undefined' || typeof envelope.s === 'undefined')\n      return undefined\n    return {\n      r: envelope.r,\n      s: envelope.s,\n      v: envelope.v!,\n    }\n  })()\n\n  if (signature) {\n    const v = (() => {\n      // EIP-155 (inferred chainId)\n      if (signature.v >= 35) {\n        const inferredChainId = Math.floor((signature.v - 35) / 2)\n        if (inferredChainId > 0) return signature.v\n        return 27 + (signature.v === 35 ? 0 : 1)\n      }\n\n      // EIP-155 (explicit chainId)\n      if (chainId > 0) return chainId * 2 + 35 + signature.v - 27\n\n      // Pre-EIP-155 (no chainId)\n      const v = 27 + (signature.v === 27 ? 0 : 1)\n      if (signature.v !== v)\n        throw new Signature.InvalidVError({ value: signature.v })\n      return v\n    })()\n\n    serialized = [\n      ...serialized,\n      Hex.fromNumber(v),\n      signature.r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(signature.r)),\n      signature.s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(signature.s)),\n    ]\n  } else if (chainId > 0)\n    serialized = [...serialized, Hex.fromNumber(chainId), '0x', '0x']\n\n  return Rlp.fromHex(serialized) as never\n}\n\nexport declare namespace serialize {\n  type Options = {\n    /** Signature to append to the serialized Transaction Envelope. */\n    signature?: Signature.Signature | undefined\n  }\n\n  type ErrorType =\n    | assert.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Hex.trimLeft.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Signature.InvalidVError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#TxEnvelopeLegacy.TxEnvelopeLegacy} to an {@link ox#TxEnvelopeLegacy.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TxEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TxEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TxEnvelopeLegacy.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The legacy transaction envelope to convert.\n * @returns An RPC-formatted legacy transaction envelope.\n */\nexport function toRpc(envelope: Omit<TxEnvelopeLegacy, 'type'>): Rpc {\n  const signature = Signature.extract(envelope)!\n\n  return {\n    ...envelope,\n    chainId:\n      typeof envelope.chainId === 'number'\n        ? Hex.fromNumber(envelope.chainId)\n        : undefined,\n    data: envelope.data ?? envelope.input,\n    type: '0x0',\n    ...(typeof envelope.gas === 'bigint'\n      ? { gas: Hex.fromNumber(envelope.gas) }\n      : {}),\n    ...(typeof envelope.nonce === 'bigint'\n      ? { nonce: Hex.fromNumber(envelope.nonce) }\n      : {}),\n    ...(typeof envelope.value === 'bigint'\n      ? { value: Hex.fromNumber(envelope.value) }\n      : {}),\n    ...(typeof envelope.gasPrice === 'bigint'\n      ? { gasPrice: Hex.fromNumber(envelope.gasPrice) }\n      : {}),\n    ...(signature\n      ? {\n          ...Signature.toRpc(signature),\n          v: signature.yParity === 0 ? '0x1b' : '0x1c',\n        }\n      : {}),\n  } as never\n}\n\nexport declare namespace toRpc {\n  export type ErrorType = Signature.extract.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Validates a {@link ox#TxEnvelopeLegacy.TxEnvelopeLegacy}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeLegacy, Value } from 'ox'\n *\n * const valid = TxEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope: PartialBy<TxEnvelopeLegacy, 'type'>) {\n  try {\n    assert(envelope)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import type * as Address from './Address.js'\nimport type * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\n\n/**\n * Encodes data with a validator in [ERC-191 format](https://eips.ethereum.org/EIPS/eip-191#version-0x00): `0x19 ‖ 0x00 ‖ <intended validator address> ‖ <data to sign>`.\n *\n * @example\n * ```ts twoslash\n * import { Hex, ValidatorData } from 'ox'\n *\n * const encoded = ValidatorData.encode({\n *   data: Hex.fromString('hello world'),\n *   validator: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n * })\n * // @log: '0x1900d8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * // @log: '0x19 ‖ 0x00 ‖ 0xd8da6bf26964af9d7eed9e03e53415d37aa96045 ‖ \"hello world\"'\n * ```\n *\n * @param value - The data to encode.\n * @returns The encoded personal sign message.\n */\nexport function encode(value: encode.Value): Hex.Hex {\n  const { data, validator } = value\n  return Hex.concat(\n    // Validator Data Format: `0x19 ‖ 0x00 ‖ <intended validator address> ‖ <data to sign>`\n    '0x19',\n    '0x00',\n    validator,\n    Hex.from(data),\n  )\n}\n\nexport declare namespace encode {\n  type Value = {\n    data: Hex.Hex | Bytes.Bytes\n    validator: Address.Address\n  }\n\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Gets the payload to use for signing [ERC-191 formatted](https://eips.ethereum.org/EIPS/eip-191#0x00) data with an intended validator.\n *\n * @example\n * ```ts twoslash\n * import { Hex, Secp256k1, ValidatorData } from 'ox'\n *\n * const payload = ValidatorData.getSignPayload({ // [!code focus]\n *   data: Hex.fromString('hello world'), // [!code focus]\n *   validator: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045', // [!code focus]\n * }) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param value - The data to get the sign payload for.\n * @returns The payload to use for signing.\n */\nexport function getSignPayload(value: getSignPayload.Value): Hex.Hex {\n  return Hash.keccak256(encode(value))\n}\n\nexport declare namespace getSignPayload {\n  type Value = {\n    data: Hex.Hex | Bytes.Bytes\n    validator: Address.Address\n  }\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | encode.ErrorType\n    | Errors.GlobalErrorType\n}\n", "import { p256 } from '@noble/curves/p256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\nimport * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\n\n/**\n * Generates an ECDSA P256 key pair that includes:\n *\n * - a `privateKey` of type [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n *\n * - a `publicKey` of type {@link ox#Hex.Hex} or {@link ox#Bytes.Bytes}\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param options - Options for creating the key pair.\n * @returns The key pair.\n */\nexport async function createKeyPair(\n  options: createKeyPair.Options = {},\n): Promise<createKeyPair.ReturnType> {\n  const { extractable = false } = options\n  const keypair = await globalThis.crypto.subtle.generateKey(\n    {\n      name: 'ECDSA',\n      namedCurve: 'P-256',\n    },\n    extractable,\n    ['sign', 'verify'],\n  )\n  const publicKey_raw = await globalThis.crypto.subtle.exportKey(\n    'raw',\n    keypair.publicKey,\n  )\n  const publicKey = PublicKey.from(new Uint8Array(publicKey_raw))\n  return {\n    privateKey: keypair.privateKey,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options = {\n    /** A boolean value indicating whether it will be possible to export the private key using `globalThis.crypto.subtle.exportKey()`. */\n    extractable?: boolean | undefined\n  }\n\n  type ReturnType = Compute<{\n    privateKey: CryptoKey\n    publicKey: PublicKey.PublicKey\n  }>\n\n  type ErrorType = PublicKey.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Generates an ECDH P256 key pair for key agreement that includes:\n *\n * - a `privateKey` of type [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * - a `publicKey` of type {@link ox#PublicKey.PublicKey}\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPairECDH()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param options - Options for creating the key pair.\n * @returns The key pair.\n */\nexport async function createKeyPairECDH(\n  options: createKeyPairECDH.Options = {},\n): Promise<createKeyPairECDH.ReturnType> {\n  const { extractable = false } = options\n  const keypair = await globalThis.crypto.subtle.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: 'P-256',\n    },\n    extractable,\n    ['deriveKey', 'deriveBits'],\n  )\n  const publicKey_raw = await globalThis.crypto.subtle.exportKey(\n    'raw',\n    keypair.publicKey,\n  )\n  const publicKey = PublicKey.from(new Uint8Array(publicKey_raw))\n  return {\n    privateKey: keypair.privateKey,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPairECDH {\n  type Options = {\n    /** A boolean value indicating whether it will be possible to export the private key using `globalThis.crypto.subtle.exportKey()`. */\n    extractable?: boolean | undefined\n  }\n\n  type ReturnType = Compute<{\n    privateKey: CryptoKey\n    publicKey: PublicKey.PublicKey\n  }>\n\n  type ErrorType = PublicKey.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key using Web Crypto APIs.\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey: privateKeyA } = await WebCryptoP256.createKeyPairECDH()\n * const { publicKey: publicKeyB } = await WebCryptoP256.createKeyPairECDH()\n *\n * const sharedSecret = await WebCryptoP256.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport async function getSharedSecret<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getSharedSecret.Options<as>,\n): Promise<getSharedSecret.ReturnType<as>> {\n  const { as = 'Hex', privateKey, publicKey } = options\n\n  if (privateKey.algorithm.name === 'ECDSA') {\n    throw new Error(\n      'privateKey is not compatible with ECDH. please use `createKeyPairECDH` to create an ECDH key.',\n    )\n  }\n\n  const publicKeyCrypto = await globalThis.crypto.subtle.importKey(\n    'raw',\n    PublicKey.toBytes(publicKey),\n    { name: 'ECDH', namedCurve: 'P-256' },\n    false,\n    [],\n  )\n\n  const sharedSecretBuffer = await globalThis.crypto.subtle.deriveBits(\n    {\n      name: 'ECDH',\n      public: publicKeyCrypto,\n    },\n    privateKey,\n    256, // 32 bytes * 8 bits/byte\n  )\n\n  const sharedSecret = new Uint8Array(sharedSecretBuffer)\n  if (as === 'Hex') return Hex.fromBytes(sharedSecret) as never\n  return sharedSecret as never\n}\n\nexport declare namespace getSharedSecret {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned shared secret.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to use for the shared secret computation (must be a CryptoKey for ECDH).\n     */\n    privateKey: CryptoKey\n    /**\n     * Public key to use for the shared secret computation.\n     */\n    publicKey: PublicKey.PublicKey<boolean>\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | PublicKey.toBytes.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs a payload with the provided `CryptoKey` private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   r: 151231...4423n,\n * // @log:   s: 516123...5512n,\n * // @log: }\n * ```\n *\n * @param options - Options for signing the payload.\n * @returns The P256 ECDSA {@link ox#Signature.Signature}.\n */\nexport async function sign(\n  options: sign.Options,\n): Promise<Signature.Signature<false>> {\n  const { payload, privateKey } = options\n  const signature = await globalThis.crypto.subtle.sign(\n    {\n      name: 'ECDSA',\n      hash: 'SHA-256',\n    },\n    privateKey,\n    Bytes.from(payload),\n  )\n  const signature_bytes = Bytes.fromArray(new Uint8Array(signature))\n  const r = Bytes.toBigInt(Bytes.slice(signature_bytes, 0, 32))\n  let s = Bytes.toBigInt(Bytes.slice(signature_bytes, 32, 64))\n  if (s > p256.CURVE.n / 2n) s = p256.CURVE.n - s\n  return { r, s }\n}\n\nexport declare namespace sign {\n  type Options = {\n    /** Payload to sign. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** ECDSA private key. */\n    privateKey: CryptoKey\n  }\n\n  type ErrorType = Bytes.fromArray.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const signature = await WebCryptoP256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = await WebCryptoP256.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport async function verify(options: verify.Options): Promise<boolean> {\n  const { payload, signature } = options\n\n  const publicKey = await globalThis.crypto.subtle.importKey(\n    'raw',\n    PublicKey.toBytes(options.publicKey),\n    { name: 'ECDSA', namedCurve: 'P-256' },\n    true,\n    ['verify'],\n  )\n\n  return await globalThis.crypto.subtle.verify(\n    {\n      name: 'ECDSA',\n      hash: 'SHA-256',\n    },\n    publicKey,\n    Bytes.concat(Bytes.fromNumber(signature.r), Bytes.fromNumber(signature.s)),\n    Bytes.from(payload),\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** Public key that signed the payload. */\n    publicKey: PublicKey.PublicKey<boolean>\n    /** Signature of the payload. */\n    signature: Signature.Signature<false>\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import { x25519 } from '@noble/curves/ed25519'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\n/** Re-export of noble/curves X25519 utilities. */\nexport const noble = x25519\n\n/**\n * Creates a new X25519 key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { X25519 } from 'ox'\n *\n * const { privateKey, publicKey } = X25519.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nexport function createKeyPair<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: createKeyPair.Options<as> = {},\n): createKeyPair.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const privateKey = randomPrivateKey({ as })\n  const publicKey = getPublicKey({ privateKey, as })\n\n  return {\n    privateKey: privateKey as never,\n    publicKey: publicKey as never,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private and public keys.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> = {\n    privateKey:\n      | (as extends 'Bytes' ? Bytes.Bytes : never)\n      | (as extends 'Hex' ? Hex.Hex : never)\n    publicKey:\n      | (as extends 'Bytes' ? Bytes.Bytes : never)\n      | (as extends 'Hex' ? Hex.Hex : never)\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | randomPrivateKey.ErrorType\n    | getPublicKey.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the X25519 public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { X25519 } from 'ox'\n *\n * const publicKey = X25519.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getPublicKey.Options<as>,\n): getPublicKey.ReturnType<as> {\n  const { as = 'Hex', privateKey } = options\n  const privateKeyBytes = Bytes.from(privateKey)\n  const publicKeyBytes = x25519.getPublicKey(privateKeyBytes)\n  if (as === 'Hex') return Hex.fromBytes(publicKeyBytes) as never\n  return publicKeyBytes as never\n}\n\nexport declare namespace getPublicKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned public key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to compute the public key from.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes a shared secret using X25519 elliptic curve Diffie-Hellman between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { X25519 } from 'ox'\n *\n * const { privateKey: privateKeyA } = X25519.createKeyPair()\n * const { publicKey: publicKeyB } = X25519.createKeyPair()\n *\n * const sharedSecret = X25519.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport function getSharedSecret<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getSharedSecret.Options<as>,\n): getSharedSecret.ReturnType<as> {\n  const { as = 'Hex', privateKey, publicKey } = options\n  const privateKeyBytes = Bytes.from(privateKey)\n  const publicKeyBytes = Bytes.from(publicKey)\n  const sharedSecretBytes = x25519.getSharedSecret(\n    privateKeyBytes,\n    publicKeyBytes,\n  )\n  if (as === 'Hex') return Hex.fromBytes(sharedSecretBytes) as never\n  return sharedSecretBytes as never\n}\n\nexport declare namespace getSharedSecret {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned shared secret.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to use for the shared secret computation.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n    /**\n     * Public key to use for the shared secret computation.\n     */\n    publicKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random X25519 private key.\n *\n * @example\n * ```ts twoslash\n * import { X25519 } from 'ox'\n *\n * const privateKey = X25519.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: randomPrivateKey.Options<as> = {},\n): randomPrivateKey.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const bytes = x25519.utils.randomPrivateKey()\n  if (as === 'Hex') return Hex.fromBytes(bytes) as never\n  return bytes as never\n}\n\nexport declare namespace randomPrivateKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n", "import { Bytes } from '../../index.js'\nimport * as Ens from '../Ens.js'\nimport type * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\n\n/**\n * @internal\n * Encodes a [DNS packet](https://docs.ens.domains/resolution/names#dns) into a ByteArray containing a UDP payload.\n */\nexport function packetToBytes(packet: string): Bytes.Bytes {\n  // strip leading and trailing `.`\n  const value = packet.replace(/^\\.|\\.$/gm, '')\n  if (value.length === 0) return new Uint8Array(1)\n\n  const bytes = new Uint8Array(Bytes.fromString(value).byteLength + 2)\n\n  let offset = 0\n  const list = value.split('.')\n  for (let i = 0; i < list.length; i++) {\n    let encoded = Bytes.fromString(list[i]!)\n    // if the length is > 255, make the encoded label value a labelhash\n    // this is compatible with the universal resolver\n    if (encoded.byteLength > 255)\n      encoded = Bytes.fromString(wrapLabelhash(Ens.labelhash(list[i]!)))\n    bytes[offset] = encoded.length\n    bytes.set(encoded, offset + 1)\n    offset += encoded.length + 1\n  }\n\n  if (bytes.byteLength !== offset + 1) return bytes.slice(0, offset + 1)\n\n  return bytes\n}\n\nexport declare namespace packetToBytes {\n  type ErrorType =\n    | wrapLabelhash.ErrorType\n    | Ens.labelhash.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function wrapLabelhash(hash: Hex.Hex): `[${string}]` {\n  return `[${hash.slice(2)}]`\n}\n\nexport declare namespace wrapLabelhash {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function unwrapLabelhash(label: string): Hex.Hex | null {\n  if (label.length !== 66) return null\n  if (label.indexOf('[') !== 0) return null\n  if (label.indexOf(']') !== 65) return null\n  const hash = `0x${label.slice(1, 65)}`\n  if (!Hex.validate(hash, { strict: true })) return null\n  return hash\n}\n\nexport declare namespace unwrapLabelhash {\n  type ErrorType = Hex.validate.ErrorType | Errors.GlobalErrorType\n}\n", "import * as Ens from 'ox/Ens'\nimport type { ErrorType } from '../../errors/utils.js'\n\nexport type NormalizeErrorType = ErrorType\n\n/**\n * @description Normalizes ENS name according to ENSIP-15.\n *\n * @example\n * normalize('wevm.eth')\n * 'wevm.eth'\n *\n * @see https://docs.ens.domains/contract-api-reference/name-processing#normalising-names\n * @see https://github.com/ensdomains/docs/blob/9edf9443de4333a0ea7ec658a870672d5d180d53/ens-improvement-proposals/ensip-15-normalization-standard.md\n */\nexport function normalize(name: string) {\n  return Ens.normalize(name)\n}\n", null, null],
  "mappings": "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;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAI;EAAI;EAAI;EAAI;EAAI;EAClD;EAAI;EAAI;EAAG;EAAG;EAAG;EAAI;EAAI;EAAG;EAAG;EAAI;EAAG;EAAG;EAAI;EAAG;EAAG;EACnD;EAAI;EAAG;EAAI;EAAG;EAAG;EAAG;EAAI;EAAI;EAAI;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EACnD;EAAG;EAAG;EAAG;EAAG;EAAI;EAAI;EAAI;EAAI;EAAG;EAAG;EAAG;EAAI;EAAG;EAAG;EAAI;EACnD;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAI;EAAI;EAAI;EAAG;EAAI;EAAI;EAAG;EAAG;EAAG;EAClD;EAAG;EAAI;EAAG;EAAI;EAAG;EAAI;EAAG;EAAG;EAAG;EAAI;EAAG;EAAG;EAAI;EAAI;EAAG;EACnD;EAAI;EAAG;EAAG;EAAI;EAAI;EAAI;EAAG;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAClD;EAAI;EAAI;EAAG;EAAI;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EAAI;EAAG;EAAG;EAAG;EAAG;EAClD;EAAG;EAAI;EAAI;EAAG;EAAI;EAAG;EAAG;EAAG;EAAI;EAAG;EAAI;EAAG;EAAG;EAAG;EAAI;EACnD;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAI;EAAI;EAAG;EAAI;EAAG;EAAI;EAAI;EACnD;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAI;EAAI;EAAI;EAAI;EAAI;EAClD;EAAI;EAAI;EAAG;EAAG;EAAG;EAAI;EAAI;EAAG;EAAG;EAAI;EAAG;EAAG;EAAI;EAAG;EAAG;;EAEnD;EAAI;EAAG;EAAI;EAAG;EAAG;EAAG;EAAI;EAAI;EAAI;EAAI;EAAG;EAAG;EAAG;EAAG;EAAG;EACnD;EAAG;EAAG;EAAG;EAAG;EAAI;EAAI;EAAI;EAAI;EAAG;EAAG;EAAG;EAAI;EAAG;EAAG;EAAI;EACnD;EAAG;EAAG;EAAG;EAAG;EAAG;EAAG;EAAI;EAAI;EAAI;EAAG;EAAI;EAAI;EAAG;EAAG;EAAG;EACl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",
  "names": ["themeMode", "themeVariables", "format", "from", "format", "from", "decode", "encode", "format", "from", "fromAbi", "isEqual", "index", "value", "input", "decode", "log", "fromAbi", "size", "encode", "args", "abiEvent", "fromString", "format", "from", "type", "from", "size", "fromBytes", "fromHex", "fromString", "toBytes", "toHex", "toString", "from", "fromBytes", "from", "fromHex", "fromString", "toBytes", "toHex", "toString", "create", "buffer", "to", "to", "create", "stem", "subIndex", "value", "internal", "bit", "from", "toBytes", "toHex", "from", "sha256", "from", "size", "to", "length", "toHex", "toBytes", "hash", "fromRpc", "toRpc", "toRpc", "fromNumber", "fromRpc", "validate", "hash", "validate", "size", "getPublicKey", "point", "size", "getPublicKey", "from", "fromBytes", "fromHex", "toBytes", "toHex", "toBytes", "toHex", "fromBytes", "fromHex", "from", "from", "fromBytes", "slice", "createKeyPair", "getPublicKey", "noble", "randomPrivateKey", "sign", "verify", "Fp", "randomBytes", "y", "y2", "uvRatio", "adjustScalarBytes", "z", "G", "cofactor", "hash", "getPublicKey", "concatBytes", "sign", "verify", "_0n", "_1n", "_2n", "validateOpts", "type", "adjustScalarBytes", "_0n", "_1n", "_2n", "_8n", "_8n", "_8n", "_2n", "y", "_1n", "mod", "_0n", "z", "noble", "createKeyPair", "randomPrivateKey", "getPublicKey", "sign", "verify", "fromRpc", "toRpc", "fromRpc", "validate", "toRpc", "fromNumber", "path", "index", "decrypt", "encrypt", "pbkdf2", "pbkdf2Async", "scrypt", "scryptAsync", "abool", "abytes", "aexists", "aoutput", "abytes", "u8", "u32", "clean", "utf8ToBytes", "toBytes", "utf8ToBytes", "concatBytes", "abytes", "equalBytes", "abytes", "isLE", "abool", "u32", "toBytes", "abytes", "aexists", "clean", "aoutput", "BLOCK_SIZE", "POLY", "mul2", "clean", "sbox", "sbox2", "abytes", "u32", "encrypt", "t0", "t1", "t2", "t3", "decrypt", "ctr", "i", "u8", "isLE", "equalBytes", "abytes", "u32", "encrypt", "decrypt", "ctr", "concatBytes", "equalBytes", "decrypt", "encrypt", "pbkdf2", "pbkdf2Async", "scrypt", "scryptAsync", "crypto", "wordlist", "random", "validate", "random", "wordlist", "path", "validate", "encode", "encode", "from", "concat", "fromString", "size", "from", "parseError", "BaseError", "from", "EventEmitter", "from", "parseError", "from", "options", "from", "create", "create", "data", "size", "statement", "from", "path", "isEqual", "fromRpc", "toRpc", "fromRpc", "toRpc", "fromNumber", "assert", "from", "getSignPayload", "hash", "toRpc", "validate", "assert", "to", "toHex", "slice", "validate", "fromTupleList", "from", "getSignPayload", "hash", "toTupleList", "fromNumber", "concat", "fromHex", "toRpc", "assert", "deserialize", "from", "getSignPayload", "hash", "serialize", "serializedType", "toRpc", "type", "validate", "serializedType", "type", "assert", "to", "deserialize", "toHex", "slice", "validate", "fromTupleList", "from", "getSignPayload", "hash", "serialize", "toTupleList", "fromNumber", "concat", "fromHex", "toRpc", "assert", "deserialize", "from", "getSignPayload", "hash", "serialize", "serializedType", "toRpc", "type", "validate", "serializedType", "type", "assert", "hash", "size", "slice", "deserialize", "toHex", "to", "validate", "fromTupleList", "from", "getSignPayload", "serialize", "toTupleList", "fromNumber", "concat", "fromHex", "toRpc", "assert", "deserialize", "from", "getSignPayload", "hash", "serialize", "serializedType", "type", "validate", "serializedType", "type", "assert", "deserialize", "toHex", "slice", "to", "validate", "fromTupleList", "from", "getSignPayload", "hash", "serialize", "toTupleList", "fromNumber", "concat", "fromHex", "assert", "deserialize", "from", "getSignPayload", "hash", "serialize", "toRpc", "type", "validate", "type", "assert", "to", "deserialize", "toHex", "validate", "from", "getSignPayload", "hash", "serialize", "fromNumber", "v", "fromHex", "toRpc", "encode", "getSignPayload", "encode", "concat", "from", "getSignPayload", "createKeyPair", "sign", "verify", "createKeyPair", "from", "toBytes", "sign", "verify", "createKeyPair", "getPublicKey", "getSharedSecret", "noble", "randomPrivateKey", "noble", "createKeyPair", "randomPrivateKey", "getPublicKey", "getSharedSecret", "hash", "validate", "fromString", "normalize", "ConstantsUtil", "normalize", "type", "modal", "ConstantsUtil"]
}
