import {
  create,
  extraEntropy,
  from as from2,
  keccak256,
  sha2562,
  toBytes as toBytes2,
  toHex
} from "./chunk-7AMAZXZZ.js";
import {
  BaseError2 as BaseError,
  InvalidLengthError,
  concat2 as concat,
  concat3 as concat2,
  from2 as from,
  fromBytes,
  fromHex2 as fromHex,
  fromNumber2 as fromNumber,
  fromString,
  fromString2,
  toBytes2 as toBytes,
  toString
} from "./chunk-6LMF3UXO.js";
import {
  Field,
  createCurve,
  createHasher,
  mapToCurveSimpleSWU,
  sha256,
  sha384,
  sha512
} from "./chunk-JDRRK33R.js";
import {
  __export
} from "./chunk-ONY6HBPH.js";

// node_modules/@noble/curves/esm/nist.js
var Fp256 = Field(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
var p256_a = Fp256.create(BigInt("-3"));
var p256_b = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
var p256 = createCurve({
  a: p256_a,
  b: p256_b,
  Fp: Fp256,
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
  h: BigInt(1),
  lowS: false
}, sha256);
var secp256r1 = p256;
var p256_mapSWU = (() => mapToCurveSimpleSWU(Fp256, {
  A: p256_a,
  B: p256_b,
  Z: Fp256.create(BigInt("-10"))
}))();
var p256_hasher = (() => createHasher(secp256r1.ProjectivePoint, (scalars) => p256_mapSWU(scalars[0]), {
  DST: "P256_XMD:SHA-256_SSWU_RO_",
  encodeDST: "P256_XMD:SHA-256_SSWU_NU_",
  p: Fp256.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var Fp384 = Field(BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"));
var p384_a = Fp384.create(BigInt("-3"));
var p384_b = BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef");
var p384 = createCurve({
  a: p384_a,
  b: p384_b,
  Fp: Fp384,
  n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),
  Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),
  Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),
  h: BigInt(1),
  lowS: false
}, sha384);
var secp384r1 = p384;
var p384_mapSWU = (() => mapToCurveSimpleSWU(Fp384, {
  A: p384_a,
  B: p384_b,
  Z: Fp384.create(BigInt("-12"))
}))();
var p384_hasher = (() => createHasher(secp384r1.ProjectivePoint, (scalars) => p384_mapSWU(scalars[0]), {
  DST: "P384_XMD:SHA-384_SSWU_RO_",
  encodeDST: "P384_XMD:SHA-384_SSWU_NU_",
  p: Fp384.ORDER,
  m: 1,
  k: 192,
  expand: "xmd",
  hash: sha384
}))();
var Fp521 = Field(BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
var p521_a = Fp521.create(BigInt("-3"));
var p521_b = BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00");
var p521 = createCurve({
  a: p521_a,
  b: p521_b,
  Fp: Fp521,
  n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),
  Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),
  Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"),
  h: BigInt(1),
  lowS: false,
  allowedPrivateKeyLengths: [130, 131, 132]
  // P521 keys are variable-length. Normalize to 132b
}, sha512);
var secp521r1 = p521;
var p521_mapSWU = (() => mapToCurveSimpleSWU(Fp521, {
  A: p521_a,
  B: p521_b,
  Z: Fp521.create(BigInt("-4"))
}))();
var p521_hasher = (() => createHasher(secp521r1.ProjectivePoint, (scalars) => p521_mapSWU(scalars[0]), {
  DST: "P521_XMD:SHA-512_SSWU_RO_",
  encodeDST: "P521_XMD:SHA-512_SSWU_NU_",
  p: Fp521.ORDER,
  m: 1,
  k: 256,
  expand: "xmd",
  hash: sha512
}))();

// node_modules/@noble/curves/esm/p256.js
var p2562 = p256;
var secp256r12 = p256;
var hashToCurve = (() => p256_hasher.hashToCurve)();
var encodeToCurve = (() => p256_hasher.encodeToCurve)();

// node_modules/ox/_esm/core/P256.js
var P256_exports = {};
__export(P256_exports, {
  createKeyPair: () => createKeyPair,
  getPublicKey: () => getPublicKey,
  getSharedSecret: () => getSharedSecret,
  noble: () => noble,
  randomPrivateKey: () => randomPrivateKey,
  recoverPublicKey: () => recoverPublicKey,
  sign: () => sign,
  verify: () => verify
});
var noble = secp256r12;
function createKeyPair(options = {}) {
  const { as = "Hex" } = options;
  const privateKey = randomPrivateKey({ as });
  const publicKey = getPublicKey({ privateKey });
  return {
    privateKey,
    publicKey
  };
}
function getPublicKey(options) {
  const { privateKey } = options;
  const point = secp256r12.ProjectivePoint.fromPrivateKey(typeof privateKey === "string" ? privateKey.slice(2) : fromBytes(privateKey).slice(2));
  return from2(point);
}
function getSharedSecret(options) {
  const { as = "Hex", privateKey, publicKey } = options;
  const point = secp256r12.ProjectivePoint.fromHex(toHex(publicKey).slice(2));
  const privateKeyHex = typeof privateKey === "string" ? privateKey.slice(2) : fromBytes(privateKey).slice(2);
  const sharedPoint = point.multiply(secp256r12.utils.normPrivateKeyToScalar(privateKeyHex));
  const sharedSecret = sharedPoint.toRawBytes(true);
  if (as === "Hex")
    return fromBytes(sharedSecret);
  return sharedSecret;
}
function randomPrivateKey(options = {}) {
  const { as = "Hex" } = options;
  const bytes = secp256r12.utils.randomPrivateKey();
  if (as === "Hex")
    return fromBytes(bytes);
  return bytes;
}
function recoverPublicKey(options) {
  const { payload, signature } = options;
  const { r, s, yParity } = signature;
  const signature_ = new secp256r12.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);
  const payload_ = payload instanceof Uint8Array ? fromBytes(payload) : payload;
  const point = signature_.recoverPublicKey(payload_.substring(2));
  return from2(point);
}
function sign(options) {
  const { extraEntropy: extraEntropy2 = extraEntropy, hash, payload, privateKey } = options;
  const { r, s, recovery } = secp256r12.sign(payload instanceof Uint8Array ? payload : fromHex(payload), privateKey instanceof Uint8Array ? privateKey : fromHex(privateKey), {
    extraEntropy: typeof extraEntropy2 === "boolean" ? extraEntropy2 : from(extraEntropy2).slice(2),
    lowS: true,
    ...hash ? { prehash: true } : {}
  });
  return {
    r,
    s,
    yParity: recovery
  };
}
function verify(options) {
  const { hash, payload, publicKey, signature } = options;
  return secp256r12.verify(signature, payload instanceof Uint8Array ? payload : fromHex(payload), toHex(publicKey).substring(2), ...hash ? [{ prehash: true, lowS: true }] : []);
}

// node_modules/ox/_esm/core/WebAuthnP256.js
var WebAuthnP256_exports = {};
__export(WebAuthnP256_exports, {
  CredentialCreationFailedError: () => CredentialCreationFailedError,
  CredentialRequestFailedError: () => CredentialRequestFailedError,
  createChallenge: () => createChallenge,
  createCredential: () => createCredential,
  getAttestationObject: () => getAttestationObject,
  getAuthenticatorData: () => getAuthenticatorData,
  getClientDataJSON: () => getClientDataJSON,
  getCredentialCreationOptions: () => getCredentialCreationOptions,
  getCredentialRequestOptions: () => getCredentialRequestOptions,
  getSignPayload: () => getSignPayload,
  sign: () => sign2,
  verify: () => verify2
});

// node_modules/ox/_esm/core/Base64.js
var Base64_exports = {};
__export(Base64_exports, {
  fromBytes: () => fromBytes2,
  fromHex: () => fromHex2,
  fromString: () => fromString3,
  toBytes: () => toBytes3,
  toHex: () => toHex2,
  toString: () => toString2
});
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var integerToCharacter = Object.fromEntries(Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").map((a, i) => [i, a.charCodeAt(0)]));
var characterToInteger = {
  ...Object.fromEntries(Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").map((a, i) => [a.charCodeAt(0), i])),
  ["=".charCodeAt(0)]: 0,
  ["-".charCodeAt(0)]: 62,
  ["_".charCodeAt(0)]: 63
};
function fromBytes2(value, options = {}) {
  const { pad = true, url = false } = options;
  const encoded = new Uint8Array(Math.ceil(value.length / 3) * 4);
  for (let i = 0, j = 0; j < value.length; i += 4, j += 3) {
    const y = (value[j] << 16) + (value[j + 1] << 8) + (value[j + 2] | 0);
    encoded[i] = integerToCharacter[y >> 18];
    encoded[i + 1] = integerToCharacter[y >> 12 & 63];
    encoded[i + 2] = integerToCharacter[y >> 6 & 63];
    encoded[i + 3] = integerToCharacter[y & 63];
  }
  const k = value.length % 3;
  const end = Math.floor(value.length / 3) * 4 + (k && k + 1);
  let base64 = decoder.decode(new Uint8Array(encoded.buffer, 0, end));
  if (pad && k === 1)
    base64 += "==";
  if (pad && k === 2)
    base64 += "=";
  if (url)
    base64 = base64.replaceAll("+", "-").replaceAll("/", "_");
  return base64;
}
function fromHex2(value, options = {}) {
  return fromBytes2(fromHex(value), options);
}
function fromString3(value, options = {}) {
  return fromBytes2(fromString(value), options);
}
function toBytes3(value) {
  const base64 = value.replace(/=+$/, "");
  const size = base64.length;
  const decoded = new Uint8Array(size + 3);
  encoder.encodeInto(base64 + "===", decoded);
  for (let i = 0, j = 0; i < base64.length; i += 4, j += 3) {
    const x = (characterToInteger[decoded[i]] << 18) + (characterToInteger[decoded[i + 1]] << 12) + (characterToInteger[decoded[i + 2]] << 6) + characterToInteger[decoded[i + 3]];
    decoded[j] = x >> 16;
    decoded[j + 1] = x >> 8 & 255;
    decoded[j + 2] = x & 255;
  }
  const decodedSize = (size >> 2) * 3 + (size % 4 && size % 4 - 1);
  return new Uint8Array(decoded.buffer, 0, decodedSize);
}
function toHex2(value) {
  return fromBytes(toBytes3(value));
}
function toString2(value) {
  return toString(toBytes3(value));
}

// node_modules/ox/_esm/core/Cbor.js
var Cbor_exports = {};
__export(Cbor_exports, {
  ArrayTooLargeError: () => ArrayTooLargeError,
  ByteStringTooLargeError: () => ByteStringTooLargeError,
  InvalidAdditionalInfoError: () => InvalidAdditionalInfoError,
  InvalidIndefiniteLengthChunkError: () => InvalidIndefiniteLengthChunkError,
  InvalidMajorTypeError: () => InvalidMajorTypeError,
  InvalidSimpleValueError: () => InvalidSimpleValueError,
  NumberTooLargeError: () => NumberTooLargeError,
  ObjectTooLargeError: () => ObjectTooLargeError,
  StringTooLargeError: () => StringTooLargeError,
  UnexpectedTokenError: () => UnexpectedTokenError,
  Unsupported64BitIntegerError: () => Unsupported64BitIntegerError,
  UnsupportedBigIntError: () => UnsupportedBigIntError,
  UnsupportedTagError: () => UnsupportedTagError,
  decode: () => decode,
  encode: () => encode
});
function encode(data, options = {}) {
  const { as = "Hex" } = options;
  const encodable = getEncodable(data);
  const cursor = create(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (as === "Hex")
    return fromBytes(cursor.bytes);
  return cursor.bytes;
}
function decode(data) {
  const bytes = (() => {
    if (typeof data === "string") {
      if (data.length > 3 && data.length % 2 !== 0)
        throw new InvalidLengthError(data);
      return fromHex(data);
    }
    return data;
  })();
  const cursor = create(bytes);
  return decodeCursor(cursor);
}
var InvalidMajorTypeError = class extends BaseError {
  constructor({ majorType }) {
    super(`Invalid CBOR major type: ${majorType}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cbor.InvalidMajorTypeError"
    });
  }
};
var InvalidAdditionalInfoError = class extends BaseError {
  constructor({ additionalInfo }) {
    super(`Invalid CBOR additional info: ${additionalInfo}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cbor.InvalidAdditionalInfoError"
    });
  }
};
var Unsupported64BitIntegerError = class extends BaseError {
  constructor() {
    super("64-bit integers are not supported in CBOR decoding.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cbor.Unsupported64BitIntegerError"
    });
  }
};
var UnsupportedTagError = class extends BaseError {
  constructor({ tag }) {
    super(`CBOR tagged data (tag ${tag}) is not yet supported.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cbor.UnsupportedTagError"
    });
  }
};
var InvalidIndefiniteLengthChunkError = class extends BaseError {
  constructor({ type }) {
    super(`Invalid chunk type in indefinite-length ${type}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cbor.InvalidIndefiniteLengthChunkError"
    });
  }
};
var InvalidSimpleValueError = class extends BaseError {
  constructor({ value }) {
    super(`Invalid CBOR simple value: ${value}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cbor.InvalidSimpleValueError"
    });
  }
};
var UnsupportedBigIntError = class extends BaseError {
  constructor() {
    super("BigInt values are not supported in CBOR encoding.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cbor.UnsupportedBigIntError"
    });
  }
};
var UnexpectedTokenError = class extends BaseError {
  constructor({ token }) {
    super(`Unexpected token: ${token}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cbor.UnexpectedTokenError"
    });
  }
};
var NumberTooLargeError = class extends BaseError {
  constructor({ number }) {
    super(`Number exceeds maximum safe integer (${Number.MAX_SAFE_INTEGER}): ${number}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cbor.NumberTooLargeError"
    });
  }
};
var StringTooLargeError = class extends BaseError {
  constructor({ size }) {
    super(`String length exceeds maximum (4294967295): ${size}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cbor.StringTooLargeError"
    });
  }
};
var ArrayTooLargeError = class extends BaseError {
  constructor({ size }) {
    super(`Array length exceeds maximum (4294967295): ${size}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cbor.ArrayTooLargeError"
    });
  }
};
var ObjectTooLargeError = class extends BaseError {
  constructor({ size }) {
    super(`Object size exceeds maximum (4294967295): ${size}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cbor.ObjectTooLargeError"
    });
  }
};
var ByteStringTooLargeError = class extends BaseError {
  constructor({ size }) {
    super(`Byte string length exceeds maximum (4294967295): ${size}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cbor.ByteStringTooLargeError"
    });
  }
};
function getEncodable(value) {
  if (typeof value === "undefined")
    return { length: 1, encode: (cursor) => cursor.pushUint8(247) };
  if (value === null)
    return { length: 1, encode: (cursor) => cursor.pushUint8(246) };
  if (typeof value === "boolean")
    return {
      length: 1,
      encode: (cursor) => cursor.pushUint8(value ? 245 : 244)
    };
  if (typeof value === "number")
    return getEncodable.number(value);
  if (typeof value === "bigint")
    throw new UnsupportedBigIntError();
  if (typeof value === "string")
    return getEncodable.string(value);
  if (Array.isArray(value))
    return getEncodable.array(value);
  if (value instanceof Uint8Array)
    return getEncodable.byteString(value);
  if (value instanceof ArrayBuffer)
    return getEncodable.byteString(new Uint8Array(value));
  if (ArrayBuffer.isView(value))
    return getEncodable.byteString(new Uint8Array(value.buffer, value.byteOffset, value.byteLength));
  if (value instanceof Map)
    return getEncodable.map(value);
  if (typeof value === "object")
    return getEncodable.object(value);
  throw new UnexpectedTokenError({ token: String(value) });
}
(function(getEncodable2) {
  function number(value) {
    if (!Number.isSafeInteger(value)) {
      const float32 = Math.fround(value);
      if (Number.isNaN(value) || value === float32)
        return {
          length: 5,
          // 1 byte prefix + 4 bytes float32
          encode(cursor) {
            cursor.pushUint8(250);
            cursor.dataView.setFloat32(cursor.position, value, false);
            cursor.position += 4;
          }
        };
      return {
        length: 9,
        // 1 byte prefix + 8 bytes float64
        encode(cursor) {
          cursor.pushUint8(251);
          cursor.dataView.setFloat64(cursor.position, value, false);
          cursor.position += 8;
        }
      };
    }
    if (value >= 0) {
      if (value <= 23)
        return { length: 1, encode: (cursor) => cursor.pushUint8(value) };
      if (value <= 255)
        return {
          length: 2,
          // 1 byte prefix + 1 byte uint8
          encode: (cursor) => {
            cursor.pushUint8(24);
            cursor.pushUint8(value);
          }
        };
      if (value <= 65535)
        return {
          length: 3,
          // 1 byte prefix + 2 bytes uint16
          encode: (cursor) => {
            cursor.pushUint8(25);
            cursor.pushUint16(value);
          }
        };
      if (value <= 4294967295)
        return {
          length: 5,
          // 1 byte prefix + 4 bytes uint32
          encode: (cursor) => {
            cursor.pushUint8(26);
            cursor.pushUint32(value);
          }
        };
      throw new NumberTooLargeError({ number: value.toString(10) });
    }
    const positiveNumber = -1 - value;
    if (value >= -24)
      return {
        length: 1,
        encode: (cursor) => cursor.pushUint8(32 + positiveNumber)
      };
    if (positiveNumber <= 255)
      return {
        length: 2,
        // 1 byte prefix + 1 byte uint8
        encode: (cursor) => {
          cursor.pushUint8(56);
          cursor.pushUint8(positiveNumber);
        }
      };
    if (positiveNumber <= 65535)
      return {
        length: 3,
        // 1 byte prefix + 2 bytes uint16
        encode: (cursor) => {
          cursor.pushUint8(57);
          cursor.pushUint16(positiveNumber);
        }
      };
    if (positiveNumber <= 4294967295)
      return {
        length: 5,
        // 1 byte prefix + 4 bytes uint32
        encode: (cursor) => {
          cursor.pushUint8(58);
          cursor.pushUint32(positiveNumber);
        }
      };
    throw new NumberTooLargeError({ number: value.toString(10) });
  }
  getEncodable2.number = number;
  function string(value) {
    const encoded = fromString(value);
    const size = encoded.length;
    if (size <= 23)
      return {
        length: 1 + size,
        // 1 byte prefix + size bytes
        encode(cursor) {
          cursor.pushUint8(96 + size);
          if (size > 0)
            cursor.pushBytes(encoded);
        }
      };
    if (size <= 255)
      return {
        length: 2 + size,
        // 1 byte prefix + 1 byte uint8 + size bytes
        encode(cursor) {
          cursor.pushUint8(120);
          cursor.pushUint8(size);
          cursor.pushBytes(encoded);
        }
      };
    if (size <= 65535)
      return {
        length: 3 + size,
        // 1 byte prefix + 2 bytes uint16 + size bytes
        encode(cursor) {
          cursor.pushUint8(121);
          cursor.pushUint16(size);
          cursor.pushBytes(encoded);
        }
      };
    if (size <= 4294967295)
      return {
        length: 5 + size,
        // 1 byte prefix + 4 bytes uint32 + size bytes
        encode(cursor) {
          cursor.pushUint8(122);
          cursor.pushUint32(size);
          cursor.pushBytes(encoded);
        }
      };
    throw new StringTooLargeError({ size });
  }
  getEncodable2.string = string;
  function array(value) {
    const items = value.map((item) => getEncodable2(item));
    const bodyLength = items.reduce((acc, item) => acc + item.length, 0);
    const size = value.length;
    if (size <= 23)
      return {
        length: 1 + bodyLength,
        // 1 byte prefix + body length
        encode(cursor) {
          cursor.pushUint8(128 + size);
          for (const item of items)
            item.encode(cursor);
        }
      };
    if (size <= 255)
      return {
        length: 2 + bodyLength,
        // 1 byte prefix + 1 byte uint8 + body length
        encode(cursor) {
          cursor.pushUint8(152);
          cursor.pushUint8(size);
          for (const item of items)
            item.encode(cursor);
        }
      };
    if (size <= 65535)
      return {
        length: 3 + bodyLength,
        // 1 byte prefix + 2 bytes uint16 + body length
        encode(cursor) {
          cursor.pushUint8(153);
          cursor.pushUint16(size);
          for (const item of items)
            item.encode(cursor);
        }
      };
    if (size <= 4294967295)
      return {
        length: 5 + bodyLength,
        // 1 byte prefix + 4 bytes uint32 + body length
        encode(cursor) {
          cursor.pushUint8(154);
          cursor.pushUint32(size);
          for (const item of items)
            item.encode(cursor);
        }
      };
    throw new ArrayTooLargeError({ size });
  }
  getEncodable2.array = array;
  function byteString(value) {
    const size = value.byteLength;
    if (size <= 23)
      return {
        length: 1 + size,
        // 1 byte prefix + size bytes
        encode(cursor) {
          cursor.pushUint8(64 + size);
          cursor.pushBytes(value);
        }
      };
    if (size <= 255)
      return {
        length: 2 + size,
        // 1 byte prefix + 1 byte uint8 + size bytes
        encode(cursor) {
          cursor.pushUint8(88);
          cursor.pushUint8(size);
          cursor.pushBytes(value);
        }
      };
    if (size <= 65535)
      return {
        length: 3 + size,
        // 1 byte prefix + 2 bytes uint16 + size bytes
        encode(cursor) {
          cursor.pushUint8(89);
          cursor.pushUint16(size);
          cursor.pushBytes(value);
        }
      };
    if (size <= 4294967295)
      return {
        length: 5 + size,
        // 1 byte prefix + 4 bytes uint32 + size bytes
        encode(cursor) {
          cursor.pushUint8(90);
          cursor.pushUint32(size);
          cursor.pushBytes(value);
        }
      };
    throw new ByteStringTooLargeError({ size });
  }
  getEncodable2.byteString = byteString;
  function object(value) {
    const keys = Object.keys(value);
    const entries = keys.map((key) => ({
      key: getEncodable2(key),
      value: getEncodable2(value[key])
    }));
    const bodyLength = entries.reduce((acc, entry) => acc + entry.key.length + entry.value.length, 0);
    const size = keys.length;
    if (size <= 23)
      return {
        length: 1 + bodyLength,
        // 1 byte prefix + body length
        encode(cursor) {
          cursor.pushUint8(160 + size);
          for (const entry of entries) {
            entry.key.encode(cursor);
            entry.value.encode(cursor);
          }
        }
      };
    if (size <= 255)
      return {
        length: 2 + bodyLength,
        // 1 byte prefix + 1 byte uint8 + body length
        encode(cursor) {
          cursor.pushUint8(184);
          cursor.pushUint8(size);
          for (const entry of entries) {
            entry.key.encode(cursor);
            entry.value.encode(cursor);
          }
        }
      };
    if (size <= 65535)
      return {
        length: 3 + bodyLength,
        // 1 byte prefix + 2 bytes uint16 + body length
        encode(cursor) {
          cursor.pushUint8(185);
          cursor.pushUint16(size);
          for (const entry of entries) {
            entry.key.encode(cursor);
            entry.value.encode(cursor);
          }
        }
      };
    if (size <= 4294967295)
      return {
        length: 5 + bodyLength,
        // 1 byte prefix + 4 bytes uint32 + body length
        encode(cursor) {
          cursor.pushUint8(186);
          cursor.pushUint32(size);
          for (const entry of entries) {
            entry.key.encode(cursor);
            entry.value.encode(cursor);
          }
        }
      };
    throw new ObjectTooLargeError({ size });
  }
  getEncodable2.object = object;
  function map(value) {
    const entries = [];
    for (const [k, v] of value)
      entries.push({ key: getEncodable2(k), value: getEncodable2(v) });
    const bodyLength = entries.reduce((acc, entry) => acc + entry.key.length + entry.value.length, 0);
    const size = value.size;
    if (size <= 23)
      return {
        length: 1 + bodyLength,
        encode(cursor) {
          cursor.pushUint8(160 + size);
          for (const entry of entries) {
            entry.key.encode(cursor);
            entry.value.encode(cursor);
          }
        }
      };
    if (size <= 255)
      return {
        length: 2 + bodyLength,
        encode(cursor) {
          cursor.pushUint8(184);
          cursor.pushUint8(size);
          for (const entry of entries) {
            entry.key.encode(cursor);
            entry.value.encode(cursor);
          }
        }
      };
    if (size <= 65535)
      return {
        length: 3 + bodyLength,
        encode(cursor) {
          cursor.pushUint8(185);
          cursor.pushUint16(size);
          for (const entry of entries) {
            entry.key.encode(cursor);
            entry.value.encode(cursor);
          }
        }
      };
    if (size <= 4294967295)
      return {
        length: 5 + bodyLength,
        encode(cursor) {
          cursor.pushUint8(186);
          cursor.pushUint32(size);
          for (const entry of entries) {
            entry.key.encode(cursor);
            entry.value.encode(cursor);
          }
        }
      };
    throw new ObjectTooLargeError({ size });
  }
  getEncodable2.map = map;
})(getEncodable || (getEncodable = {}));
function decodeCursor(cursor) {
  const initialByte = cursor.readUint8();
  const majorType = initialByte >> 5;
  const additionalInfo = initialByte & 31;
  switch (majorType) {
    case 0:
      return decodeCursor.readUnsignedInteger(cursor, additionalInfo);
    case 1:
      return decodeCursor.readNegativeInteger(cursor, additionalInfo);
    case 2:
      return decodeCursor.readByteString(cursor, additionalInfo);
    case 3:
      return decodeCursor.readTextString(cursor, additionalInfo);
    case 4:
      return decodeCursor.readArray(cursor, additionalInfo);
    case 5:
      return decodeCursor.readMap(cursor, additionalInfo);
    case 6:
      throw new UnsupportedTagError({ tag: additionalInfo });
    case 7:
      return decodeCursor.readSimpleOrFloat(cursor, additionalInfo);
    default:
      throw new InvalidMajorTypeError({ majorType });
  }
}
(function(decodeCursor2) {
  function readLength(cursor, additionalInfo) {
    if (additionalInfo < 24)
      return additionalInfo;
    if (additionalInfo === 24)
      return cursor.readUint8();
    if (additionalInfo === 25)
      return cursor.readUint16();
    if (additionalInfo === 26)
      return cursor.readUint32();
    if (additionalInfo === 27)
      throw new Unsupported64BitIntegerError();
    throw new InvalidAdditionalInfoError({ additionalInfo });
  }
  function readUnsignedInteger(cursor, additionalInfo) {
    return readLength(cursor, additionalInfo);
  }
  decodeCursor2.readUnsignedInteger = readUnsignedInteger;
  function readNegativeInteger(cursor, additionalInfo) {
    const value = readLength(cursor, additionalInfo);
    return -1 - value;
  }
  decodeCursor2.readNegativeInteger = readNegativeInteger;
  function readByteString(cursor, additionalInfo) {
    if (additionalInfo === 31) {
      const chunks = [];
      let totalLength = 0;
      while (true) {
        const byte = cursor.inspectUint8();
        if (byte === 255) {
          cursor.readUint8();
          break;
        }
        const chunk = decodeCursor2(cursor);
        if (!(chunk instanceof Uint8Array))
          throw new InvalidIndefiniteLengthChunkError({ type: "byte string" });
        chunks.push(chunk);
        totalLength += chunk.length;
      }
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      return result;
    }
    const length = readLength(cursor, additionalInfo);
    return cursor.readBytes(length);
  }
  decodeCursor2.readByteString = readByteString;
  function readTextString(cursor, additionalInfo) {
    if (additionalInfo === 31) {
      const chunks = [];
      while (true) {
        const byte = cursor.inspectUint8();
        if (byte === 255) {
          cursor.readUint8();
          break;
        }
        const chunk = decodeCursor2(cursor);
        if (typeof chunk !== "string")
          throw new InvalidIndefiniteLengthChunkError({ type: "text string" });
        chunks.push(chunk);
      }
      return chunks.join("");
    }
    const length = readLength(cursor, additionalInfo);
    const bytes = cursor.readBytes(length);
    return toString(bytes);
  }
  decodeCursor2.readTextString = readTextString;
  function readArray(cursor, additionalInfo) {
    if (additionalInfo === 31) {
      const result2 = [];
      while (true) {
        const byte = cursor.inspectUint8();
        if (byte === 255) {
          cursor.readUint8();
          break;
        }
        result2.push(decodeCursor2(cursor));
      }
      return result2;
    }
    const length = readLength(cursor, additionalInfo);
    const result = [];
    for (let i = 0; i < length; i++) {
      result.push(decodeCursor2(cursor));
    }
    return result;
  }
  decodeCursor2.readArray = readArray;
  function readMap(cursor, additionalInfo) {
    if (additionalInfo === 31) {
      const result2 = {};
      while (true) {
        const byte = cursor.inspectUint8();
        if (byte === 255) {
          cursor.readUint8();
          break;
        }
        const key = decodeCursor2(cursor);
        const keyStr = typeof key === "string" ? key : typeof key === "number" ? String(key) : String(key);
        const value = decodeCursor2(cursor);
        result2[keyStr] = value;
      }
      return result2;
    }
    const length = readLength(cursor, additionalInfo);
    const result = {};
    for (let i = 0; i < length; i++) {
      const key = decodeCursor2(cursor);
      const keyStr = typeof key === "string" ? key : typeof key === "number" ? String(key) : String(key);
      const value = decodeCursor2(cursor);
      result[keyStr] = value;
    }
    return result;
  }
  decodeCursor2.readMap = readMap;
  function readSimpleOrFloat(cursor, additionalInfo) {
    if (additionalInfo === 20)
      return false;
    if (additionalInfo === 21)
      return true;
    if (additionalInfo === 22)
      return null;
    if (additionalInfo === 23)
      return void 0;
    if (additionalInfo === 25) {
      const bits = cursor.readUint16();
      return getFloat16(bits);
    }
    if (additionalInfo === 26) {
      const value = cursor.dataView.getFloat32(cursor.position, false);
      cursor.position += 4;
      return value;
    }
    if (additionalInfo === 27) {
      const value = cursor.dataView.getFloat64(cursor.position, false);
      cursor.position += 8;
      return value;
    }
    if (additionalInfo === 24) {
      const simpleValue = cursor.readUint8();
      if (simpleValue < 32)
        throw new InvalidSimpleValueError({ value: simpleValue });
      return void 0;
    }
    throw new InvalidAdditionalInfoError({ additionalInfo });
  }
  decodeCursor2.readSimpleOrFloat = readSimpleOrFloat;
  function getFloat16(bits) {
    const sign3 = bits >> 15 & 1;
    const exponent = bits >> 10 & 31;
    const fraction = bits & 1023;
    if (exponent === 0) {
      if (fraction === 0)
        return sign3 ? -0 : 0;
      const value2 = 2 ** -14 * (fraction / 1024);
      return sign3 ? -value2 : value2;
    }
    if (exponent === 31) {
      if (fraction === 0)
        return sign3 ? -Infinity : Infinity;
      return NaN;
    }
    const value = 2 ** (exponent - 15) * (1 + fraction / 1024);
    return sign3 ? -value : value;
  }
})(decodeCursor || (decodeCursor = {}));

// node_modules/ox/_esm/core/CoseKey.js
var CoseKey_exports = {};
__export(CoseKey_exports, {
  InvalidCoseKeyError: () => InvalidCoseKeyError,
  fromPublicKey: () => fromPublicKey,
  toPublicKey: () => toPublicKey
});
function fromPublicKey(publicKey) {
  const pkBytes = toBytes2(publicKey);
  const x = pkBytes.slice(1, 33);
  const y = pkBytes.slice(33, 65);
  return encode(/* @__PURE__ */ new Map([
    [1, 2],
    // kty: EC2
    [3, -7],
    // alg: ES256
    [-1, 1],
    // crv: P-256
    [-2, x],
    // x coordinate
    [-3, y]
    // y coordinate
  ]));
}
function toPublicKey(coseKey) {
  const decoded = decode(coseKey);
  const x = decoded["-2"];
  const y = decoded["-3"];
  if (!(x instanceof Uint8Array) || !(y instanceof Uint8Array))
    throw new InvalidCoseKeyError();
  return from2(new Uint8Array([4, ...x, ...y]));
}
var InvalidCoseKeyError = class extends BaseError {
  constructor() {
    super("COSE_Key does not contain valid P256 public key coordinates.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "CoseKey.InvalidCoseKeyError"
    });
  }
};

// node_modules/ox/_esm/core/internal/webauthn.js
function parseAsn1Signature(bytes) {
  const r_start = bytes[4] === 0 ? 5 : 4;
  const r_end = r_start + 32;
  const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2;
  const r = BigInt(fromBytes(bytes.slice(r_start, r_end)));
  const s = BigInt(fromBytes(bytes.slice(s_start)));
  return {
    r,
    s: s > p2562.CURVE.n / 2n ? p2562.CURVE.n - s : s
  };
}
async function parseCredentialPublicKey(response) {
  try {
    const publicKeyBuffer = response.getPublicKey();
    if (!publicKeyBuffer)
      throw new CredentialCreationFailedError();
    const publicKeyBytes = new Uint8Array(publicKeyBuffer);
    const cryptoKey = await crypto.subtle.importKey("spki", new Uint8Array(publicKeyBytes), {
      name: "ECDSA",
      namedCurve: "P-256",
      hash: "SHA-256"
    }, true, ["verify"]);
    const publicKey = new Uint8Array(await crypto.subtle.exportKey("raw", cryptoKey));
    return from2(publicKey);
  } catch (error) {
    if (error.message !== "Permission denied to access object")
      throw error;
    const data = new Uint8Array(response.attestationObject);
    const coordinateLength = 32;
    const cborPrefix = 88;
    const findStart = (key) => {
      const coordinate = new Uint8Array([key, cborPrefix, coordinateLength]);
      for (let i = 0; i < data.length - coordinate.length; i++)
        if (coordinate.every((byte, j) => data[i + j] === byte))
          return i + coordinate.length;
      throw new CredentialCreationFailedError();
    };
    const xStart = findStart(33);
    const yStart = findStart(34);
    return from2(new Uint8Array([
      4,
      ...data.slice(xStart, xStart + coordinateLength),
      ...data.slice(yStart, yStart + coordinateLength)
    ]));
  }
}

// node_modules/ox/_esm/core/WebAuthnP256.js
var createChallenge = Uint8Array.from([
  105,
  171,
  180,
  181,
  160,
  222,
  75,
  198,
  42,
  42,
  32,
  31,
  141,
  37,
  186,
  233
]);
async function createCredential(options) {
  const { createFn = window.navigator.credentials.create.bind(window.navigator.credentials), ...rest } = options;
  const creationOptions = getCredentialCreationOptions(rest);
  try {
    const credential = await createFn(creationOptions);
    if (!credential)
      throw new CredentialCreationFailedError();
    const response = credential.response;
    const publicKey = await parseCredentialPublicKey(response);
    return {
      id: credential.id,
      publicKey,
      raw: credential
    };
  } catch (error) {
    throw new CredentialCreationFailedError({
      cause: error
    });
  }
}
function getAuthenticatorData(options = {}) {
  const { credential, flag = 5, rpId = window.location.hostname, signCount = 0 } = options;
  const rpIdHash = sha2562(fromString2(rpId));
  const flag_bytes = fromNumber(flag, { size: 1 });
  const signCount_bytes = fromNumber(signCount, { size: 4 });
  const base = concat2(rpIdHash, flag_bytes, signCount_bytes);
  if (!credential)
    return base;
  const aaguid = fromBytes(new Uint8Array(16));
  const credentialId = fromBytes(credential.id);
  const credIdLen = fromNumber(credential.id.length, { size: 2 });
  const coseKey = fromPublicKey(credential.publicKey);
  return concat2(base, aaguid, credIdLen, credentialId, coseKey);
}
function getClientDataJSON(options) {
  const { challenge, crossOrigin = false, extraClientData, origin = window.location.origin, type = "webauthn.get" } = options;
  return JSON.stringify({
    type,
    challenge: fromHex2(challenge, { url: true, pad: false }),
    origin,
    crossOrigin,
    ...extraClientData
  });
}
function getAttestationObject(options) {
  const { attStmt = {}, authData, fmt = "none" } = options;
  return encode({
    fmt,
    attStmt,
    authData: toBytes(authData)
  });
}
function getCredentialCreationOptions(options) {
  const { attestation = "none", authenticatorSelection = {
    residentKey: "preferred",
    requireResidentKey: false,
    userVerification: "required"
  }, challenge = createChallenge, excludeCredentialIds, extensions, name: name_, rp = {
    id: window.location.hostname,
    name: window.document.title
  }, user } = options;
  const name = (user == null ? void 0 : user.name) ?? name_;
  return {
    publicKey: {
      attestation,
      authenticatorSelection,
      challenge: typeof challenge === "string" ? fromHex(challenge) : challenge,
      ...excludeCredentialIds ? {
        excludeCredentials: excludeCredentialIds == null ? void 0 : excludeCredentialIds.map((id) => ({
          id: toBytes3(id),
          type: "public-key"
        }))
      } : {},
      pubKeyCredParams: [
        {
          type: "public-key",
          alg: -7
          // p256
        }
      ],
      ...extensions && { extensions },
      rp,
      user: {
        id: (user == null ? void 0 : user.id) ?? keccak256(fromString(name), { as: "Bytes" }),
        name,
        displayName: (user == null ? void 0 : user.displayName) ?? name
      }
    }
  };
}
function getCredentialRequestOptions(options) {
  const { credentialId, challenge, extensions, rpId = window.location.hostname, userVerification = "required" } = options;
  return {
    publicKey: {
      ...credentialId ? {
        allowCredentials: Array.isArray(credentialId) ? credentialId.map((id) => ({
          id: toBytes3(id),
          type: "public-key"
        })) : [
          {
            id: toBytes3(credentialId),
            type: "public-key"
          }
        ]
      } : {},
      challenge: fromHex(challenge),
      ...extensions && { extensions },
      rpId,
      userVerification
    }
  };
}
function getSignPayload(options) {
  const { challenge, crossOrigin, extraClientData, flag, origin, rpId, signCount, userVerification = "required" } = options;
  const authenticatorData = getAuthenticatorData({
    flag,
    rpId,
    signCount
  });
  const clientDataJSON = getClientDataJSON({
    challenge,
    crossOrigin,
    extraClientData,
    origin
  });
  const clientDataJSONHash = sha2562(fromString2(clientDataJSON));
  const challengeIndex = clientDataJSON.indexOf('"challenge"');
  const typeIndex = clientDataJSON.indexOf('"type"');
  const metadata = {
    authenticatorData,
    clientDataJSON,
    challengeIndex,
    typeIndex,
    userVerificationRequired: userVerification === "required"
  };
  const payload = concat2(authenticatorData, clientDataJSONHash);
  return { metadata, payload };
}
async function sign2(options) {
  const { getFn = window.navigator.credentials.get.bind(window.navigator.credentials), ...rest } = options;
  const requestOptions = getCredentialRequestOptions(rest);
  try {
    const credential = await getFn(requestOptions);
    if (!credential)
      throw new CredentialRequestFailedError();
    const response = credential.response;
    const clientDataJSON = String.fromCharCode(...new Uint8Array(response.clientDataJSON));
    const challengeIndex = clientDataJSON.indexOf('"challenge"');
    const typeIndex = clientDataJSON.indexOf('"type"');
    const signature = parseAsn1Signature(new Uint8Array(response.signature));
    return {
      metadata: {
        authenticatorData: fromBytes(new Uint8Array(response.authenticatorData)),
        clientDataJSON,
        challengeIndex,
        typeIndex,
        userVerificationRequired: requestOptions.publicKey.userVerification === "required"
      },
      signature,
      raw: credential
    };
  } catch (error) {
    throw new CredentialRequestFailedError({
      cause: error
    });
  }
}
function verify2(options) {
  const { challenge, hash = true, metadata, publicKey, signature } = options;
  const { authenticatorData, challengeIndex, clientDataJSON, typeIndex, userVerificationRequired } = metadata;
  const authenticatorDataBytes = fromHex(authenticatorData);
  if (authenticatorDataBytes.length < 37)
    return false;
  const flag = authenticatorDataBytes[32];
  if ((flag & 1) !== 1)
    return false;
  if (userVerificationRequired && (flag & 4) !== 4)
    return false;
  if ((flag & 8) !== 8 && (flag & 16) === 16)
    return false;
  if (typeIndex !== void 0) {
    const type = '"type":"webauthn.get"';
    if (type !== clientDataJSON.slice(Number(typeIndex), Number(typeIndex) + type.length))
      return false;
  }
  const challengeMatch = challengeIndex !== void 0 ? clientDataJSON.slice(Number(challengeIndex)).match(/^"challenge":"(.*?)"/) : clientDataJSON.match(/"challenge":"(.*?)"/);
  if (!challengeMatch)
    return false;
  const [_, challenge_extracted] = challengeMatch;
  if (fromBytes(toBytes3(challenge_extracted)) !== challenge)
    return false;
  const clientDataJSONHash = sha2562(fromString(clientDataJSON), {
    as: "Bytes"
  });
  const payload = concat(authenticatorDataBytes, clientDataJSONHash);
  return verify({
    hash,
    payload,
    publicKey,
    signature
  });
}
var CredentialCreationFailedError = class extends BaseError {
  constructor({ cause } = {}) {
    super("Failed to create credential.", {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WebAuthnP256.CredentialCreationFailedError"
    });
  }
};
var CredentialRequestFailedError = class extends BaseError {
  constructor({ cause } = {}) {
    super("Failed to request credential.", {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WebAuthnP256.CredentialRequestFailedError"
    });
  }
};

// node_modules/ox/_esm/core/TransactionReceipt.js
var TransactionReceipt_exports = {};
__export(TransactionReceipt_exports, {
  fromRpc: () => fromRpc2,
  fromRpcStatus: () => fromRpcStatus,
  fromRpcType: () => fromRpcType,
  toRpc: () => toRpc2,
  toRpcStatus: () => toRpcStatus,
  toRpcType: () => toRpcType
});

// node_modules/ox/_esm/core/Log.js
var Log_exports = {};
__export(Log_exports, {
  fromRpc: () => fromRpc,
  toRpc: () => toRpc
});
function fromRpc(log, _options = {}) {
  return {
    ...log,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null
  };
}
function toRpc(log, _options = {}) {
  return {
    address: log.address,
    blockHash: log.blockHash,
    blockNumber: typeof log.blockNumber === "bigint" ? fromNumber(log.blockNumber) : null,
    data: log.data,
    logIndex: typeof log.logIndex === "number" ? fromNumber(log.logIndex) : null,
    topics: log.topics,
    transactionHash: log.transactionHash,
    transactionIndex: typeof log.transactionIndex === "number" ? fromNumber(log.transactionIndex) : null,
    removed: log.removed
  };
}

// node_modules/ox/_esm/core/TransactionReceipt.js
var fromRpcStatus = {
  "0x0": "reverted",
  "0x1": "success"
};
var toRpcStatus = {
  reverted: "0x0",
  success: "0x1"
};
var fromRpcType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
var toRpcType = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function fromRpc2(receipt) {
  if (!receipt)
    return null;
  return {
    ...receipt,
    blobGasPrice: receipt.blobGasPrice ? BigInt(receipt.blobGasPrice) : void 0,
    blobGasUsed: receipt.blobGasUsed ? BigInt(receipt.blobGasUsed) : void 0,
    blockNumber: BigInt(receipt.blockNumber ?? 0n),
    cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed ?? 0n),
    effectiveGasPrice: BigInt(receipt.effectiveGasPrice ?? 0n),
    gasUsed: BigInt(receipt.gasUsed ?? 0n),
    logs: receipt.logs.map((log) => fromRpc(log, { pending: false })),
    status: fromRpcStatus[receipt.status],
    transactionIndex: Number(receipt.transactionIndex ?? 0),
    type: fromRpcType[receipt.type] || receipt.type
  };
}
function toRpc2(receipt) {
  return {
    blobGasPrice: receipt.blobGasPrice ? fromNumber(receipt.blobGasPrice) : void 0,
    blobGasUsed: receipt.blobGasUsed ? fromNumber(receipt.blobGasUsed) : void 0,
    blockHash: receipt.blockHash,
    blockNumber: fromNumber(receipt.blockNumber),
    contractAddress: receipt.contractAddress,
    cumulativeGasUsed: fromNumber(receipt.cumulativeGasUsed),
    effectiveGasPrice: fromNumber(receipt.effectiveGasPrice),
    from: receipt.from,
    gasUsed: fromNumber(receipt.gasUsed),
    logs: receipt.logs.map(toRpc),
    logsBloom: receipt.logsBloom,
    root: receipt.root,
    status: toRpcStatus[receipt.status],
    to: receipt.to,
    transactionHash: receipt.transactionHash,
    transactionIndex: fromNumber(receipt.transactionIndex),
    type: toRpcType[receipt.type] ?? receipt.type
  };
}

export {
  p2562 as p256,
  secp256r12 as secp256r1,
  verify,
  P256_exports,
  Base64_exports,
  Cbor_exports,
  CoseKey_exports,
  verify2,
  WebAuthnP256_exports,
  fromRpc,
  toRpc,
  Log_exports,
  fromRpcType,
  toRpcType,
  fromRpc2,
  toRpc2,
  TransactionReceipt_exports
};
/*! Bundled license information:

@noble/curves/esm/nist.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/p256.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-2IUP5IGY.js.map
