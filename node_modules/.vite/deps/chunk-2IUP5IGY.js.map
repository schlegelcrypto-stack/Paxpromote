{
  "version": 3,
  "sources": ["../../@noble/curves/src/nist.ts", "../../@noble/curves/src/p256.ts", "../../ox/core/P256.ts", "../../ox/core/WebAuthnP256.ts", "../../ox/core/Base64.ts", "../../ox/core/Cbor.ts", "../../ox/core/CoseKey.ts", "../../ox/core/internal/webauthn.ts", "../../ox/core/TransactionReceipt.ts", "../../ox/core/Log.ts"],
  "sourcesContent": ["/**\n * Internal module for NIST P256, P384, P521 curves.\n * Do not use for now.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256, sha384, sha512 } from '@noble/hashes/sha2';\nimport { createCurve, type CurveFnWithCreate } from './_shortw_utils.ts';\nimport { createHasher, type Hasher } from './abstract/hash-to-curve.ts';\nimport { Field } from './abstract/modular.ts';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.ts';\n\nconst Fp256 = Field(BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'));\nconst p256_a = Fp256.create(BigInt('-3'));\nconst p256_b = BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b');\n\n/**\n * secp256r1 curve, ECDSA and ECDH methods.\n * Field: `2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n`\n */\n// prettier-ignore\nexport const p256: CurveFnWithCreate = createCurve({\n  a: p256_a,\n  b: p256_b,\n  Fp: Fp256,\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n  h: BigInt(1),\n  lowS: false\n} as const, sha256);\n/** Alias to p256. */\nexport const secp256r1: CurveFnWithCreate = p256;\n\nconst p256_mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp256, {\n    A: p256_a,\n    B: p256_b,\n    Z: Fp256.create(BigInt('-10')),\n  }))();\n\n/** Hashing / encoding to p256 points / field. RFC 9380 methods. */\nexport const p256_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(secp256r1.ProjectivePoint, (scalars: bigint[]) => p256_mapSWU(scalars[0]), {\n    DST: 'P256_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',\n    p: Fp256.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n  }))();\n\n// Field over which we'll do calculations.\nconst Fp384 = Field(\n  BigInt(\n    '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff'\n  )\n);\nconst p384_a = Fp384.create(BigInt('-3'));\n// prettier-ignore\nconst p384_b = BigInt('0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef');\n\n/**\n * secp384r1 curve, ECDSA and ECDH methods.\n * Field: `2n**384n - 2n**128n - 2n**96n + 2n**32n - 1n`.\n * */\n// prettier-ignore\nexport const p384: CurveFnWithCreate = createCurve({\n  a: p384_a,\n  b: p384_b,\n  Fp: Fp384,\n  n: BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973'),\n  Gx: BigInt('0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7'),\n  Gy: BigInt('0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f'),\n  h: BigInt(1),\n  lowS: false\n} as const, sha384);\n/** Alias to p384. */\nexport const secp384r1: CurveFnWithCreate = p384;\n\nconst p384_mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp384, {\n    A: p384_a,\n    B: p384_b,\n    Z: Fp384.create(BigInt('-12')),\n  }))();\n\n/** Hashing / encoding to p384 points / field. RFC 9380 methods. */\nexport const p384_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(secp384r1.ProjectivePoint, (scalars: bigint[]) => p384_mapSWU(scalars[0]), {\n    DST: 'P384_XMD:SHA-384_SSWU_RO_',\n    encodeDST: 'P384_XMD:SHA-384_SSWU_NU_',\n    p: Fp384.ORDER,\n    m: 1,\n    k: 192,\n    expand: 'xmd',\n    hash: sha384,\n  }))();\n\n// Field over which we'll do calculations.\nconst Fp521 = Field(\n  BigInt(\n    '0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n  )\n);\n\nconst p521_a = Fp521.create(BigInt('-3'));\nconst p521_b = BigInt(\n  '0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00'\n);\n\n/**\n * NIST secp521r1 aka p521 curve, ECDSA and ECDH methods.\n * Field: `2n**521n - 1n`.\n */\n// prettier-ignore\nexport const p521: CurveFnWithCreate = createCurve({\n  a: p521_a,\n  b: p521_b,\n  Fp: Fp521,\n  n: BigInt(\n    '0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409'\n  ),\n  Gx: BigInt(\n    '0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66'\n  ),\n  Gy: BigInt(\n    '0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650'\n  ),\n  h: BigInt(1),\n  lowS: false,\n  allowedPrivateKeyLengths: [130, 131, 132] // P521 keys are variable-length. Normalize to 132b\n} as const, sha512);\n/** Alias to p521. */\nexport const secp521r1: CurveFnWithCreate = p521;\n\nconst p521_mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp521, {\n    A: p521_a,\n    B: p521_b,\n    Z: Fp521.create(BigInt('-4')),\n  }))();\n\n/** Hashing / encoding to p521 points / field. RFC 9380 methods. */\nexport const p521_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(secp521r1.ProjectivePoint, (scalars: bigint[]) => p521_mapSWU(scalars[0]), {\n    DST: 'P521_XMD:SHA-512_SSWU_RO_',\n    encodeDST: 'P521_XMD:SHA-512_SSWU_NU_',\n    p: Fp521.ORDER,\n    m: 1,\n    k: 256,\n    expand: 'xmd',\n    hash: sha512,\n  }))();\n", "/**\n * NIST secp256r1 aka p256.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { type HTFMethod } from './abstract/hash-to-curve.ts';\nimport { p256_hasher, p256 as p256n } from './nist.ts';\nexport const p256: typeof p256n = p256n;\nexport const secp256r1: typeof p256n = p256n;\nexport const hashToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => p256_hasher.hashToCurve)();\nexport const encodeToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => p256_hasher.encodeToCurve)();\n", "import { secp256r1 } from '@noble/curves/p256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Entropy from './internal/entropy.js'\nimport * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\n\n/** Re-export of noble/curves P256 utilities. */\nexport const noble = secp256r1\n\n/**\n * Creates a new P256 ECDSA key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nexport function createKeyPair<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: createKeyPair.Options<as> = {},\n): createKeyPair.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const privateKey = randomPrivateKey({ as })\n  const publicKey = getPublicKey({ privateKey })\n\n  return {\n    privateKey: privateKey as never,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> = {\n    privateKey:\n      | (as extends 'Bytes' ? Bytes.Bytes : never)\n      | (as extends 'Hex' ? Hex.Hex : never)\n    publicKey: PublicKey.PublicKey\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | PublicKey.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the P256 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const publicKey = P256.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey(\n  options: getPublicKey.Options,\n): PublicKey.PublicKey {\n  const { privateKey } = options\n  const point = secp256r1.ProjectivePoint.fromPrivateKey(\n    typeof privateKey === 'string'\n      ? privateKey.slice(2)\n      : Hex.fromBytes(privateKey).slice(2),\n  )\n  return PublicKey.from(point)\n}\n\nexport declare namespace getPublicKey {\n  type Options = {\n    /**\n     * Private key to compute the public key from.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey: privateKeyA } = P256.createKeyPair()\n * const { publicKey: publicKeyB } = P256.createKeyPair()\n *\n * const sharedSecret = P256.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport function getSharedSecret<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getSharedSecret.Options<as>,\n): getSharedSecret.ReturnType<as> {\n  const { as = 'Hex', privateKey, publicKey } = options\n  const point = secp256r1.ProjectivePoint.fromHex(\n    PublicKey.toHex(publicKey).slice(2),\n  )\n  const privateKeyHex =\n    typeof privateKey === 'string'\n      ? privateKey.slice(2)\n      : Hex.fromBytes(privateKey).slice(2)\n  const sharedPoint = point.multiply(\n    secp256r1.utils.normPrivateKeyToScalar(privateKeyHex),\n  )\n  const sharedSecret = sharedPoint.toRawBytes(true) // compressed format\n  if (as === 'Hex') return Hex.fromBytes(sharedSecret) as never\n  return sharedSecret as never\n}\n\nexport declare namespace getSharedSecret {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned shared secret.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to use for the shared secret computation.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n    /**\n     * Public key to use for the shared secret computation.\n     */\n    publicKey: PublicKey.PublicKey<boolean>\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | PublicKey.toHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random P256 ECDSA private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: randomPrivateKey.Options<as> = {},\n): randomPrivateKey.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const bytes = secp256r1.utils.randomPrivateKey()\n  if (as === 'Hex') return Hex.fromBytes(bytes) as never\n  return bytes as never\n}\n\nexport declare namespace randomPrivateKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = P256.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nexport function recoverPublicKey(\n  options: recoverPublicKey.Options,\n): PublicKey.PublicKey {\n  const { payload, signature } = options\n  const { r, s, yParity } = signature\n  const signature_ = new secp256r1.Signature(\n    BigInt(r),\n    BigInt(s),\n  ).addRecoveryBit(yParity)\n  const payload_ =\n    payload instanceof Uint8Array ? Hex.fromBytes(payload) : payload\n  const point = signature_.recoverPublicKey(payload_.substring(2))\n  return PublicKey.from(point)\n}\n\nexport declare namespace recoverPublicKey {\n  type Options = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Signature of the payload. */\n    signature: Signature.Signature\n  }\n\n  type ErrorType =\n    | PublicKey.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs the payload with the provided private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nexport function sign(options: sign.Options): Signature.Signature {\n  const {\n    extraEntropy = Entropy.extraEntropy,\n    hash,\n    payload,\n    privateKey,\n  } = options\n  const { r, s, recovery } = secp256r1.sign(\n    payload instanceof Uint8Array ? payload : Bytes.fromHex(payload),\n    privateKey instanceof Uint8Array ? privateKey : Bytes.fromHex(privateKey),\n    {\n      extraEntropy:\n        typeof extraEntropy === 'boolean'\n          ? extraEntropy\n          : Hex.from(extraEntropy).slice(2),\n      lowS: true,\n      ...(hash ? { prehash: true } : {}),\n    },\n  )\n  return {\n    r,\n    s,\n    yParity: recovery,\n  }\n}\n\nexport declare namespace sign {\n  type Options = {\n    /**\n     * Extra entropy to add to the signing process. Setting to `false` will disable it.\n     * @default true\n     */\n    extraEntropy?: boolean | Hex.Hex | Bytes.Bytes | undefined\n    /**\n     * If set to `true`, the payload will be hashed (sha256) before being signed.\n     */\n    hash?: boolean | undefined\n    /**\n     * Payload to sign.\n     */\n    payload: Hex.Hex | Bytes.Bytes\n    /**\n     * ECDSA private key.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = P256.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport function verify(options: verify.Options): boolean {\n  const { hash, payload, publicKey, signature } = options\n  return secp256r1.verify(\n    signature,\n    payload instanceof Uint8Array ? payload : Bytes.fromHex(payload),\n    PublicKey.toHex(publicKey).substring(2),\n    ...(hash ? [{ prehash: true, lowS: true }] : []),\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** If set to `true`, the payload will be hashed (sha256) before being verified. */\n    hash?: boolean | undefined\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Public key that signed the payload. */\n    publicKey: PublicKey.PublicKey<boolean>\n    /** Signature of the payload. */\n    signature: Signature.Signature<boolean>\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as Base64 from './Base64.js'\nimport * as Bytes from './Bytes.js'\nimport * as Cbor from './Cbor.js'\nimport * as CoseKey from './CoseKey.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, OneOf } from './internal/types.js'\nimport * as internal from './internal/webauthn.js'\nimport * as P256 from './P256.js'\nimport type * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\n\n/** A WebAuthn-flavored P256 credential. */\nexport type P256Credential = {\n  id: string\n  publicKey: PublicKey.PublicKey\n  raw: internal.PublicKeyCredential\n}\n\n/** Metadata for a WebAuthn P256 signature. */\nexport type SignMetadata = Compute<{\n  authenticatorData: Hex.Hex\n  challengeIndex?: number | undefined\n  clientDataJSON: string\n  typeIndex?: number | undefined\n  userVerificationRequired?: boolean | undefined\n}>\n\nexport const createChallenge = Uint8Array.from([\n  105, 171, 180, 181, 160, 222, 75, 198, 42, 42, 32, 31, 141, 37, 186, 233,\n])\n\n/**\n * Creates a new WebAuthn P256 Credential, which can be stored and later used for signing.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' }) // [!code focus]\n * // @log: {\n * // @log:   id: 'oZ48...',\n * // @log:   publicKey: { x: 51421...5123n, y: 12345...6789n },\n * // @log:   raw: PublicKeyCredential {},\n * // @log: }\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n * ```\n *\n * @param options - Credential creation options.\n * @returns A WebAuthn P256 credential.\n */\nexport async function createCredential(\n  options: createCredential.Options,\n): Promise<P256Credential> {\n  const {\n    createFn = window.navigator.credentials.create.bind(\n      window.navigator.credentials,\n    ),\n    ...rest\n  } = options\n  const creationOptions = getCredentialCreationOptions(rest)\n  try {\n    const credential = (await createFn(\n      creationOptions as never,\n    )) as internal.PublicKeyCredential\n    if (!credential) throw new CredentialCreationFailedError()\n\n    const response = credential.response as AuthenticatorAttestationResponse\n    const publicKey = await internal.parseCredentialPublicKey(response)\n\n    return {\n      id: credential.id,\n      publicKey,\n      raw: credential,\n    }\n  } catch (error) {\n    throw new CredentialCreationFailedError({\n      cause: error as Error,\n    })\n  }\n}\n\nexport declare namespace createCredential {\n  type Options = getCredentialCreationOptions.Options & {\n    /**\n     * Credential creation function. Useful for environments that do not support\n     * the WebAuthn API natively (i.e. React Native or testing environments).\n     *\n     * @default window.navigator.credentials.create\n     */\n    createFn?:\n      | ((\n          options?: internal.CredentialCreationOptions | undefined,\n        ) => Promise<internal.Credential | null>)\n      | undefined\n  }\n\n  type ErrorType =\n    | getCredentialCreationOptions.ErrorType\n    | internal.parseCredentialPublicKey.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Gets the authenticator data which contains information about the\n * processing of an authenticator request (ie. from `WebAuthnP256.sign`).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * autenticator data. In most cases you will not need this function.\n * `authenticatorData` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const authenticatorData = WebAuthnP256.getAuthenticatorData({\n *   rpId: 'example.com',\n *   signCount: 420,\n * })\n * // @log: \"0xa379a6f6eeafb9a55e378c118034e2751e682fab9f2d30ab13d2125586ce194705000001a4\"\n * ```\n *\n * @example\n * ### With Attested Credential Data\n *\n * Include a credential ID and public key in the authenticator data (for registration responses):\n *\n * ```ts twoslash\n * import { P256, WebAuthnP256 } from 'ox'\n *\n * const { publicKey } = P256.createKeyPair()\n *\n * const authenticatorData = WebAuthnP256.getAuthenticatorData({\n *   rpId: 'example.com',\n *   flag: 0x41, // UP + AT\n *   credential: {\n *     id: new Uint8Array(32),\n *     publicKey,\n *   },\n * })\n * ```\n *\n * @param options - Options to construct the authenticator data.\n * @returns The authenticator data.\n */\nexport function getAuthenticatorData(\n  options: getAuthenticatorData.Options = {},\n): Hex.Hex {\n  const {\n    credential,\n    flag = 5,\n    rpId = window.location.hostname,\n    signCount = 0,\n  } = options\n  const rpIdHash = Hash.sha256(Hex.fromString(rpId))\n  const flag_bytes = Hex.fromNumber(flag, { size: 1 })\n  const signCount_bytes = Hex.fromNumber(signCount, { size: 4 })\n  const base = Hex.concat(rpIdHash, flag_bytes, signCount_bytes)\n\n  if (!credential) return base\n\n  // AAGUID (16 bytes of zeros)\n  const aaguid = Hex.fromBytes(new Uint8Array(16))\n\n  // Credential ID\n  const credentialId = Hex.fromBytes(credential.id)\n  const credIdLen = Hex.fromNumber(credential.id.length, { size: 2 })\n\n  // COSE public key\n  const coseKey = CoseKey.fromPublicKey(credential.publicKey)\n\n  return Hex.concat(base, aaguid, credIdLen, credentialId, coseKey)\n}\n\nexport declare namespace getAuthenticatorData {\n  type Options = {\n    /** Attested credential data to include (credential ID + public key). When set, the AT flag (0x40) should also be set. */\n    credential?:\n      | {\n          /** The credential ID as raw bytes. */\n          id: Uint8Array\n          /** The P256 public key associated with the credential. */\n          publicKey: PublicKey.PublicKey\n        }\n      | undefined\n    /** A bitfield that indicates various attributes that were asserted by the authenticator. [Read more](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data#flags) */\n    flag?: number | undefined\n    /** The [Relying Party ID](https://w3c.github.io/webauthn/#relying-party-identifier) that the credential is scoped to. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** A signature counter, if supported by the authenticator (set to 0 otherwise). */\n    signCount?: number | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Constructs the Client Data in stringified JSON format which represents client data that\n * was passed to `credentials.get()` in {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * client data. In most cases you will not need this function.\n * `clientDataJSON` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const clientDataJSON = WebAuthnP256.getClientDataJSON({\n *   challenge: '0xdeadbeef',\n *   origin: 'https://example.com',\n * })\n * // @log: \"{\"type\":\"webauthn.get\",\"challenge\":\"3q2-7w\",\"origin\":\"https://example.com\",\"crossOrigin\":false}\"\n * ```\n *\n * @param options - Options to construct the client data.\n * @returns The client data.\n */\nexport function getClientDataJSON(options: getClientDataJSON.Options): string {\n  const {\n    challenge,\n    crossOrigin = false,\n    extraClientData,\n    origin = window.location.origin,\n    type = 'webauthn.get',\n  } = options\n\n  return JSON.stringify({\n    type,\n    challenge: Base64.fromHex(challenge, { url: true, pad: false }),\n    origin,\n    crossOrigin,\n    ...extraClientData,\n  })\n}\n\nexport declare namespace getClientDataJSON {\n  type Options = {\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** If set to `true`, it means that the calling context is an `<iframe>` that is not same origin with its ancestor frames. */\n    crossOrigin?: boolean | undefined\n    /** Additional client data to include in the client data JSON. */\n    extraClientData?: Record<string, unknown> | undefined\n    /** The fully qualified origin of the relying party which has been given by the client/browser to the authenticator. */\n    origin?: string | undefined\n    /** The WebAuthn ceremony type. @default 'webauthn.get' */\n    type?: 'webauthn.create' | 'webauthn.get' | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Constructs a CBOR-encoded attestation object for testing WebAuthn registration\n * verification. Combines the authenticator data with an attestation statement.\n *\n * :::warning\n *\n * This function is mainly for testing purposes. In production, the attestation\n * object is returned by the authenticator during `navigator.credentials.create()`.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { P256, WebAuthnP256 } from 'ox'\n *\n * const { publicKey } = P256.createKeyPair()\n *\n * const attestationObject = WebAuthnP256.getAttestationObject({\n *   authData: WebAuthnP256.getAuthenticatorData({\n *     rpId: 'example.com',\n *     flag: 0x41,\n *     credential: { id: new Uint8Array(32), publicKey },\n *   }),\n * })\n * ```\n *\n * @param options - Options to construct the attestation object.\n * @returns The CBOR-encoded attestation object as a Hex string.\n */\nexport function getAttestationObject(\n  options: getAttestationObject.Options,\n): Hex.Hex {\n  const { attStmt = {}, authData, fmt = 'none' } = options\n  return Cbor.encode({\n    fmt,\n    attStmt,\n    authData: Hex.toBytes(authData),\n  })\n}\n\nexport declare namespace getAttestationObject {\n  type Options = {\n    /** Attestation statement. */\n    attStmt?: Record<string, unknown> | undefined\n    /** Authenticator data as a Hex string (from {@link ox#WebAuthnP256.(getAuthenticatorData:function)}). */\n    authData: Hex.Hex\n    /** Attestation format. @default 'none' */\n    fmt?: string | undefined\n  }\n\n  type ErrorType = Cbor.encode.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Returns the creation options for a P256 WebAuthn Credential to be used with\n * the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialCreationOptions({ name: 'Example' })\n *\n * const credential = await window.navigator.credentials.create(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential creation options.\n */\nexport function getCredentialCreationOptions(\n  options: getCredentialCreationOptions.Options,\n): internal.CredentialCreationOptions {\n  const {\n    attestation = 'none',\n    authenticatorSelection = {\n      residentKey: 'preferred',\n      requireResidentKey: false,\n      userVerification: 'required',\n    },\n    challenge = createChallenge,\n    excludeCredentialIds,\n    extensions,\n    name: name_,\n    rp = {\n      id: window.location.hostname,\n      name: window.document.title,\n    },\n    user,\n  } = options\n  const name = (user?.name ?? name_)!\n  return {\n    publicKey: {\n      attestation,\n      authenticatorSelection,\n      challenge:\n        typeof challenge === 'string' ? Bytes.fromHex(challenge) : challenge,\n      ...(excludeCredentialIds\n        ? {\n            excludeCredentials: excludeCredentialIds?.map((id) => ({\n              id: Base64.toBytes(id),\n              type: 'public-key',\n            })),\n          }\n        : {}),\n      pubKeyCredParams: [\n        {\n          type: 'public-key',\n          alg: -7, // p256\n        },\n      ],\n      ...(extensions && { extensions }),\n      rp,\n      user: {\n        id: user?.id ?? Hash.keccak256(Bytes.fromString(name), { as: 'Bytes' }),\n        name,\n        displayName: user?.displayName ?? name,\n      },\n    },\n  }\n}\n\nexport declare namespace getCredentialCreationOptions {\n  type Options = {\n    /**\n     * A string specifying the relying party's preference for how the attestation statement\n     * (i.e., provision of verifiable evidence of the authenticity of the authenticator and its data)\n     * is conveyed during credential creation.\n     */\n    attestation?:\n      | internal.PublicKeyCredentialCreationOptions['attestation']\n      | undefined\n    /**\n     * An object whose properties are criteria used to filter out the potential authenticators\n     * for the credential creation operation.\n     */\n    authenticatorSelection?:\n      | internal.PublicKeyCredentialCreationOptions['authenticatorSelection']\n      | undefined\n    /**\n     * An `ArrayBuffer`, `TypedArray`, or `DataView` used as a cryptographic challenge.\n     */\n    challenge?:\n      | Hex.Hex\n      | internal.PublicKeyCredentialCreationOptions['challenge']\n      | undefined\n    /**\n     * List of credential IDs to exclude from the creation. This property can be used\n     * to prevent creation of a credential if it already exists.\n     */\n    excludeCredentialIds?: readonly string[] | undefined\n    /**\n     * List of Web Authentication API credentials to use during creation or authentication.\n     */\n    extensions?:\n      | internal.PublicKeyCredentialCreationOptions['extensions']\n      | undefined\n    /**\n     * An object describing the relying party that requested the credential creation\n     */\n    rp?:\n      | {\n          id: string\n          name: string\n        }\n      | undefined\n    /**\n     * A numerical hint, in milliseconds, which indicates the time the calling web app is willing to wait for the creation operation to complete.\n     */\n    timeout?: internal.PublicKeyCredentialCreationOptions['timeout'] | undefined\n  } & OneOf<\n    | {\n        /** Name for the credential (user.name). */\n        name: string\n      }\n    | {\n        /**\n         * An object describing the user account for which the credential is generated.\n         */\n        user: {\n          displayName?: string\n          id?: BufferSource\n          name: string\n        }\n      }\n  >\n\n  type ErrorType =\n    | Base64.toBytes.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the request options to sign a challenge with the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialRequestOptions({\n *   challenge: '0xdeadbeef',\n * })\n *\n * const credential = await window.navigator.credentials.get(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential request options.\n */\nexport function getCredentialRequestOptions(\n  options: getCredentialRequestOptions.Options,\n): internal.CredentialRequestOptions {\n  const {\n    credentialId,\n    challenge,\n    extensions,\n    rpId = window.location.hostname,\n    userVerification = 'required',\n  } = options\n  return {\n    publicKey: {\n      ...(credentialId\n        ? {\n            allowCredentials: Array.isArray(credentialId)\n              ? credentialId.map((id) => ({\n                  id: Base64.toBytes(id),\n                  type: 'public-key',\n                }))\n              : [\n                  {\n                    id: Base64.toBytes(credentialId),\n                    type: 'public-key',\n                  },\n                ],\n          }\n        : {}),\n      challenge: Bytes.fromHex(challenge),\n      ...(extensions && { extensions }),\n      rpId,\n      userVerification,\n    },\n  }\n}\n\nexport declare namespace getCredentialRequestOptions {\n  type Options = {\n    /** The credential ID to use. */\n    credentialId?: string | string[] | undefined\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** List of Web Authentication API credentials to use during creation or authentication. */\n    extensions?:\n      | internal.PublicKeyCredentialRequestOptions['extensions']\n      | undefined\n    /** The relying party identifier to use. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** The user verification requirement. */\n    userVerification?:\n      | internal.PublicKeyCredentialRequestOptions['userVerification']\n      | undefined\n  }\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | Base64.toBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Constructs the final digest that was signed and computed by the authenticator. This payload includes\n * the cryptographic `challenge`, as well as authenticator metadata (`authenticatorData` + `clientDataJSON`).\n * This value can be also used with raw P256 verification (such as {@link ox#P256.(verify:function)} or\n * {@link ox#WebCryptoP256.(verify:function)}).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * signing payloads. In most cases you will not need this function and\n * instead use {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256, WebCryptoP256 } from 'ox'\n *\n * const { metadata, payload } = WebAuthnP256.getSignPayload({ // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000\",\n * // @log:     challengeIndex: 23,\n * // @log:     clientDataJSON: \"{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}\",\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   payload: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d9763050000000045086dcb06a5f234db625bcdc94e657f86b76b6fd3eb9c30543eabc1e577a4b0\",\n * // @log: }\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({\n *   payload,\n *   privateKey,\n * })\n * ```\n *\n * @param options - Options to construct the signing payload.\n * @returns The signing payload.\n */\nexport function getSignPayload(\n  options: getSignPayload.Options,\n): getSignPayload.ReturnType {\n  const {\n    challenge,\n    crossOrigin,\n    extraClientData,\n    flag,\n    origin,\n    rpId,\n    signCount,\n    userVerification = 'required',\n  } = options\n\n  const authenticatorData = getAuthenticatorData({\n    flag,\n    rpId,\n    signCount,\n  })\n  const clientDataJSON = getClientDataJSON({\n    challenge,\n    crossOrigin,\n    extraClientData,\n    origin,\n  })\n  const clientDataJSONHash = Hash.sha256(Hex.fromString(clientDataJSON))\n\n  const challengeIndex = clientDataJSON.indexOf('\"challenge\"')\n  const typeIndex = clientDataJSON.indexOf('\"type\"')\n\n  const metadata = {\n    authenticatorData,\n    clientDataJSON,\n    challengeIndex,\n    typeIndex,\n    userVerificationRequired: userVerification === 'required',\n  }\n\n  const payload = Hex.concat(authenticatorData, clientDataJSONHash)\n\n  return { metadata, payload }\n}\n\nexport declare namespace getSignPayload {\n  type Options = {\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** If set to `true`, it means that the calling context is an `<iframe>` that is not same origin with its ancestor frames. */\n    crossOrigin?: boolean | undefined\n    /** Additional client data to include in the client data JSON. */\n    extraClientData?: Record<string, unknown> | undefined\n    /** If set to `true`, the payload will be hashed before being returned. */\n    hash?: boolean | undefined\n    /** A bitfield that indicates various attributes that were asserted by the authenticator. [Read more](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data#flags) */\n    flag?: number | undefined\n    /** The fully qualified origin of the relying party which has been given by the client/browser to the authenticator. */\n    origin?: string | undefined\n    /** The [Relying Party ID](https://w3c.github.io/webauthn/#relying-party-identifier) that the credential is scoped to. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** A signature counter, if supported by the authenticator (set to 0 otherwise). */\n    signCount?: number | undefined\n    /** The user verification requirement that the authenticator will enforce. */\n    userVerification?:\n      | internal.PublicKeyCredentialRequestOptions['userVerification']\n      | undefined\n  }\n\n  type ReturnType = {\n    metadata: SignMetadata\n    payload: Hex.Hex\n  }\n\n  type ErrorType =\n    | Hash.sha256.ErrorType\n    | Hex.concat.ErrorType\n    | Hex.fromString.ErrorType\n    | getAuthenticatorData.ErrorType\n    | getClientDataJSON.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs a challenge using a stored WebAuthn P256 Credential. If no Credential is provided,\n * a prompt will be displayed for the user to select an existing Credential\n * that was previously registered.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({ // [!code focus]\n *   credentialId: credential.id, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: '0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000',\n * // @log:     clientDataJSON: '{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}',\n * // @log:     challengeIndex: 23,\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   signature: { r: 51231...4215n, s: 12345...6789n },\n * // @log: }\n * ```\n *\n * @param options - Options.\n * @returns The signature.\n */\nexport async function sign(options: sign.Options): Promise<sign.ReturnType> {\n  const {\n    getFn = window.navigator.credentials.get.bind(window.navigator.credentials),\n    ...rest\n  } = options\n  const requestOptions = getCredentialRequestOptions(rest)\n  try {\n    const credential = (await getFn(\n      requestOptions as never,\n    )) as internal.PublicKeyCredential\n    if (!credential) throw new CredentialRequestFailedError()\n    const response = credential.response as AuthenticatorAssertionResponse\n\n    const clientDataJSON = String.fromCharCode(\n      ...new Uint8Array(response.clientDataJSON),\n    )\n    const challengeIndex = clientDataJSON.indexOf('\"challenge\"')\n    const typeIndex = clientDataJSON.indexOf('\"type\"')\n\n    const signature = internal.parseAsn1Signature(\n      new Uint8Array(response.signature),\n    )\n\n    return {\n      metadata: {\n        authenticatorData: Hex.fromBytes(\n          new Uint8Array(response.authenticatorData),\n        ),\n        clientDataJSON,\n        challengeIndex,\n        typeIndex,\n        userVerificationRequired:\n          requestOptions.publicKey!.userVerification === 'required',\n      },\n      signature,\n      raw: credential,\n    }\n  } catch (error) {\n    throw new CredentialRequestFailedError({\n      cause: error as Error,\n    })\n  }\n}\n\nexport declare namespace sign {\n  type Options = getCredentialRequestOptions.Options & {\n    /**\n     * Credential request function. Useful for environments that do not support\n     * the WebAuthn API natively (i.e. React Native or testing environments).\n     *\n     * @default window.navigator.credentials.get\n     */\n    getFn?:\n      | ((\n          options?: internal.CredentialRequestOptions | undefined,\n        ) => Promise<internal.Credential | null>)\n      | undefined\n  }\n\n  type ReturnType = {\n    metadata: SignMetadata\n    raw: internal.PublicKeyCredential\n    signature: Signature.Signature<false>\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | getCredentialRequestOptions.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a signature using the Credential's public key and the challenge which was signed.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n *\n * const result = await WebAuthnP256.verify({ // [!code focus]\n *   metadata, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - Options.\n * @returns Whether the signature is valid.\n */\nexport function verify(options: verify.Options): boolean {\n  const { challenge, hash = true, metadata, publicKey, signature } = options\n  const {\n    authenticatorData,\n    challengeIndex,\n    clientDataJSON,\n    typeIndex,\n    userVerificationRequired,\n  } = metadata\n\n  const authenticatorDataBytes = Bytes.fromHex(authenticatorData)\n\n  // Check length of `authenticatorData`.\n  if (authenticatorDataBytes.length < 37) return false\n\n  const flag = authenticatorDataBytes[32]!\n\n  // Verify that the UP bit of the flags in authData is set.\n  if ((flag & 0x01) !== 0x01) return false\n\n  // If user verification was determined to be required, verify that\n  // the UV bit of the flags in authData is set. Otherwise, ignore the\n  // value of the UV flag.\n  if (userVerificationRequired && (flag & 0x04) !== 0x04) return false\n\n  // If the BE bit of the flags in authData is not set, verify that\n  // the BS bit is not set.\n  if ((flag & 0x08) !== 0x08 && (flag & 0x10) === 0x10) return false\n\n  // Check that response is for an authentication assertion (if typeIndex is provided)\n  if (typeIndex !== undefined) {\n    const type = '\"type\":\"webauthn.get\"'\n    if (\n      type !==\n      clientDataJSON.slice(Number(typeIndex), Number(typeIndex) + type.length)\n    )\n      return false\n  }\n\n  // Extract and validate the challenge from clientDataJSON\n  const challengeMatch =\n    challengeIndex !== undefined\n      ? clientDataJSON\n          .slice(Number(challengeIndex))\n          .match(/^\"challenge\":\"(.*?)\"/)\n      : clientDataJSON.match(/\"challenge\":\"(.*?)\"/)\n  if (!challengeMatch) return false\n\n  // Validate the challenge in the clientDataJSON.\n  const [_, challenge_extracted] = challengeMatch\n  if (Hex.fromBytes(Base64.toBytes(challenge_extracted!)) !== challenge)\n    return false\n\n  const clientDataJSONHash = Hash.sha256(Bytes.fromString(clientDataJSON), {\n    as: 'Bytes',\n  })\n  const payload = Bytes.concat(authenticatorDataBytes, clientDataJSONHash)\n\n  return P256.verify({\n    hash,\n    payload,\n    publicKey,\n    signature,\n  })\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** The challenge to verify. */\n    challenge: Hex.Hex\n    /** If set to `true`, the payload will be hashed (sha256) before being verified. */\n    hash?: boolean | undefined\n    /** The public key to verify the signature with. */\n    publicKey: PublicKey.PublicKey\n    /** The signature to verify. */\n    signature: Signature.Signature<false>\n    /** The metadata to verify the signature with. */\n    metadata: SignMetadata\n  }\n\n  type ErrorType =\n    | Base64.toBytes.ErrorType\n    | Bytes.concat.ErrorType\n    | Bytes.fromHex.ErrorType\n    | P256.verify.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** Thrown when a WebAuthn P256 credential creation fails. */\nexport class CredentialCreationFailedError extends Errors.BaseError<Error> {\n  override readonly name = 'WebAuthnP256.CredentialCreationFailedError'\n\n  constructor({ cause }: { cause?: Error | undefined } = {}) {\n    super('Failed to create credential.', {\n      cause,\n    })\n  }\n}\n\n/** Thrown when a WebAuthn P256 credential request fails. */\nexport class CredentialRequestFailedError extends Errors.BaseError<Error> {\n  override readonly name = 'WebAuthnP256.CredentialRequestFailedError'\n\n  constructor({ cause }: { cause?: Error | undefined } = {}) {\n    super('Failed to request credential.', {\n      cause,\n    })\n  }\n}\n\n// Export types required for inference.\nexport type {\n  AttestationConveyancePreference,\n  AuthenticationExtensionsClientInputs,\n  AuthenticatorAttachment,\n  AuthenticatorSelectionCriteria,\n  AuthenticatorTransport,\n  BufferSource,\n  COSEAlgorithmIdentifier,\n  Credential,\n  CredentialCreationOptions,\n  CredentialMediationRequirement,\n  CredentialRequestOptions,\n  LargeBlobSupport,\n  PrfExtension,\n  PublicKeyCredential,\n  PublicKeyCredentialCreationOptions,\n  PublicKeyCredentialDescriptor,\n  PublicKeyCredentialEntity,\n  PublicKeyCredentialParameters,\n  PublicKeyCredentialRequestOptions,\n  PublicKeyCredentialRpEntity,\n  PublicKeyCredentialType,\n  PublicKeyCredentialUserEntity,\n  ResidentKeyRequirement,\n  UserVerificationRequirement,\n} from './internal/webauthn.js'\n", "import * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\nconst decoder = /*#__PURE__*/ new TextDecoder()\n\nconst integerToCharacter = /*#__PURE__*/ Object.fromEntries(\n  Array.from(\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  ).map((a, i) => [i, a.charCodeAt(0)]),\n)\n\nconst characterToInteger = {\n  ...Object.fromEntries(\n    Array.from(\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n    ).map((a, i) => [a.charCodeAt(0), i]),\n  ),\n  ['='.charCodeAt(0)]: 0,\n  ['-'.charCodeAt(0)]: 62,\n  ['_'.charCodeAt(0)]: 63,\n} as Record<number, number>\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello world'))\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello world'), { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello wod'), { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The byte array to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nexport function fromBytes(value: Bytes.Bytes, options: fromBytes.Options = {}) {\n  const { pad = true, url = false } = options\n\n  const encoded = new Uint8Array(Math.ceil(value.length / 3) * 4)\n\n  for (let i = 0, j = 0; j < value.length; i += 4, j += 3) {\n    const y = (value[j]! << 16) + (value[j + 1]! << 8) + (value[j + 2]! | 0)\n    encoded[i] = integerToCharacter[y >> 18]!\n    encoded[i + 1] = integerToCharacter[(y >> 12) & 0x3f]!\n    encoded[i + 2] = integerToCharacter[(y >> 6) & 0x3f]!\n    encoded[i + 3] = integerToCharacter[y & 0x3f]!\n  }\n\n  const k = value.length % 3\n  const end = Math.floor(value.length / 3) * 4 + (k && k + 1)\n  let base64 = decoder.decode(new Uint8Array(encoded.buffer, 0, end))\n  if (pad && k === 1) base64 += '=='\n  if (pad && k === 2) base64 += '='\n  if (url) base64 = base64.replaceAll('+', '-').replaceAll('/', '_')\n  return base64\n}\n\nexport declare namespace fromBytes {\n  type Options = {\n    /**\n     * Whether to [pad](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) the Base64 encoded string.\n     *\n     * @default true\n     */\n    pad?: boolean | undefined\n    /**\n     * Whether to Base64 encode with [URL safe characters](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @default false\n     */\n    url?: boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Hex.Hex} to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello world'))\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello world'), { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello wod'), { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The hex value to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nexport function fromHex(value: Hex.Hex, options: fromHex.Options = {}) {\n  return fromBytes(Bytes.fromHex(value), options)\n}\n\nexport declare namespace fromHex {\n  type Options = {\n    /**\n     * Whether to [pad](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) the Base64 encoded string.\n     *\n     * @default true\n     */\n    pad?: boolean | undefined\n    /**\n     * Whether to Base64 encode with [URL safe characters](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @default false\n     */\n    url?: boolean | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a string to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello world')\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello world', { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello wod', { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The string to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nexport function fromString(value: string, options: fromString.Options = {}) {\n  return fromBytes(Bytes.fromString(value), options)\n}\n\nexport declare namespace fromString {\n  type Options = {\n    /**\n     * Whether to [pad](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) the Base64 encoded string.\n     *\n     * @default true\n     */\n    pad?: boolean | undefined\n    /**\n     * Whether to Base64 encode with [URL safe characters](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @default false\n     */\n    url?: boolean | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.toBytes('aGVsbG8gd29ybGQ=')\n * // @log: Uint8Array([104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded {@link ox#Bytes.Bytes}.\n */\nexport function toBytes(value: string): Bytes.Bytes {\n  const base64 = value.replace(/=+$/, '')\n\n  const size = base64.length\n\n  const decoded = new Uint8Array(size + 3)\n  encoder.encodeInto(base64 + '===', decoded)\n\n  for (let i = 0, j = 0; i < base64.length; i += 4, j += 3) {\n    const x =\n      (characterToInteger[decoded[i]!]! << 18) +\n      (characterToInteger[decoded[i + 1]!]! << 12) +\n      (characterToInteger[decoded[i + 2]!]! << 6) +\n      characterToInteger[decoded[i + 3]!]!\n    decoded[j] = x >> 16\n    decoded[j + 1] = (x >> 8) & 0xff\n    decoded[j + 2] = x & 0xff\n  }\n\n  const decodedSize = (size >> 2) * 3 + (size % 4 && (size % 4) - 1)\n  return new Uint8Array(decoded.buffer, 0, decodedSize)\n}\n\nexport declare namespace toBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.toHex('aGVsbG8gd29ybGQ=')\n * // @log: 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded {@link ox#Hex.Hex}.\n */\nexport function toHex(value: string): Hex.Hex {\n  return Hex.fromBytes(toBytes(value))\n}\n\nexport declare namespace toHex {\n  type ErrorType = toBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to a string.\n *\n * @example\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.toString('aGVsbG8gd29ybGQ=')\n * // @log: 'hello world'\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded string.\n */\nexport function toString(value: string): string {\n  return Bytes.toString(toBytes(value))\n}\n\nexport declare namespace toString {\n  type ErrorType = toBytes.ErrorType | Errors.GlobalErrorType\n}\n", "import * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Cursor from './internal/cursor.js'\n\n/**\n * Encodes a value into CBOR (Concise Binary Object Representation) format.\n *\n * @example\n * ```ts twoslash\n * import { Cbor } from 'ox'\n *\n * Cbor.encode([1, 2, 3])\n * // @log: '0x83010203'\n *\n * Cbor.encode({ foo: 'bar', baz: [1, 2, 3] })\n * // @log: '0xa263666f6f636261726362617a83010203'\n *\n * Cbor.encode('hello', { as: 'Bytes' })\n * // @log: Uint8Array(6) [ 101, 104, 101, 108, 108, 111 ]\n * ```\n *\n * @param data - The value to encode.\n * @param options - Encoding options.\n * @returns The CBOR-encoded value.\n */\nexport function encode<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  data: unknown,\n  options: encode.Options<as> = {},\n): encode.ReturnType<as> {\n  const { as = 'Hex' } = options\n\n  const encodable = getEncodable(data)\n  const cursor = Cursor.create(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (as === 'Hex') return Hex.fromBytes(cursor.bytes) as encode.ReturnType<as>\n  return cursor.bytes as encode.ReturnType<as>\n}\n\nexport declare namespace encode {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** The format to return the encoded value in. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Hex' ? Hex.Hex : never)\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n\n  type ErrorType =\n    | Cursor.create.ErrorType\n    | Hex.fromBytes.ErrorType\n    | UnsupportedBigIntError\n    | UnexpectedTokenError\n    | NumberTooLargeError\n    | StringTooLargeError\n    | ByteStringTooLargeError\n    | ArrayTooLargeError\n    | ObjectTooLargeError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Decodes CBOR (Concise Binary Object Representation) data into a JavaScript value.\n *\n * @example\n * ```ts twoslash\n * import { Cbor } from 'ox'\n *\n * Cbor.decode('0x83010203')\n * // @log: [1, 2, 3]\n *\n * Cbor.decode('0xa263666f6f636261726362617a83010203')\n * // @log: { foo: 'bar', baz: [1, 2, 3] }\n *\n * Cbor.decode(new Uint8Array([101, 104, 101, 108, 108, 111]))\n * // @log: 'hello'\n * ```\n *\n * @param data - The CBOR-encoded data to decode.\n * @param options - Decoding options.\n * @returns The decoded value.\n */\nexport function decode<type = unknown>(data: Hex.Hex | Bytes.Bytes): type {\n  const bytes = (() => {\n    if (typeof data === 'string') {\n      if (data.length > 3 && data.length % 2 !== 0)\n        throw new Hex.InvalidLengthError(data)\n      return Bytes.fromHex(data)\n    }\n    return data\n  })()\n\n  const cursor = Cursor.create(bytes)\n\n  return decodeCursor(cursor) as type\n}\n\nexport declare namespace decode {\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | Cursor.create.ErrorType\n    | Hex.InvalidLengthError\n    | decodeCursor.ErrorType\n    | Errors.GlobalErrorType\n}\n\nexport class InvalidMajorTypeError extends Errors.BaseError {\n  override readonly name = 'Cbor.InvalidMajorTypeError'\n\n  constructor({ majorType }: { majorType: number }) {\n    super(`Invalid CBOR major type: ${majorType}`)\n  }\n}\n\nexport class InvalidAdditionalInfoError extends Errors.BaseError {\n  override readonly name = 'Cbor.InvalidAdditionalInfoError'\n\n  constructor({ additionalInfo }: { additionalInfo: number }) {\n    super(`Invalid CBOR additional info: ${additionalInfo}`)\n  }\n}\n\nexport class Unsupported64BitIntegerError extends Errors.BaseError {\n  override readonly name = 'Cbor.Unsupported64BitIntegerError'\n\n  constructor() {\n    super('64-bit integers are not supported in CBOR decoding.')\n  }\n}\n\nexport class UnsupportedTagError extends Errors.BaseError {\n  override readonly name = 'Cbor.UnsupportedTagError'\n\n  constructor({ tag }: { tag: number }) {\n    super(`CBOR tagged data (tag ${tag}) is not yet supported.`)\n  }\n}\n\nexport class InvalidIndefiniteLengthChunkError extends Errors.BaseError {\n  override readonly name = 'Cbor.InvalidIndefiniteLengthChunkError'\n\n  constructor({ type }: { type: string }) {\n    super(`Invalid chunk type in indefinite-length ${type}`)\n  }\n}\n\nexport class InvalidSimpleValueError extends Errors.BaseError {\n  override readonly name = 'Cbor.InvalidSimpleValueError'\n\n  constructor({ value }: { value: number }) {\n    super(`Invalid CBOR simple value: ${value}`)\n  }\n}\n\nexport class UnsupportedBigIntError extends Errors.BaseError {\n  override readonly name = 'Cbor.UnsupportedBigIntError'\n\n  constructor() {\n    super('BigInt values are not supported in CBOR encoding.')\n  }\n}\n\nexport class UnexpectedTokenError extends Errors.BaseError {\n  override readonly name = 'Cbor.UnexpectedTokenError'\n\n  constructor({ token }: { token: string }) {\n    super(`Unexpected token: ${token}`)\n  }\n}\n\nexport class NumberTooLargeError extends Errors.BaseError {\n  override readonly name = 'Cbor.NumberTooLargeError'\n\n  constructor({ number }: { number: string }) {\n    super(\n      `Number exceeds maximum safe integer (${Number.MAX_SAFE_INTEGER}): ${number}`,\n    )\n  }\n}\n\nexport class StringTooLargeError extends Errors.BaseError {\n  override readonly name = 'Cbor.StringTooLargeError'\n\n  constructor({ size }: { size: number }) {\n    super(`String length exceeds maximum (4294967295): ${size}`)\n  }\n}\n\nexport class ArrayTooLargeError extends Errors.BaseError {\n  override readonly name = 'Cbor.ArrayTooLargeError'\n\n  constructor({ size }: { size: number }) {\n    super(`Array length exceeds maximum (4294967295): ${size}`)\n  }\n}\n\nexport class ObjectTooLargeError extends Errors.BaseError {\n  override readonly name = 'Cbor.ObjectTooLargeError'\n\n  constructor({ size }: { size: number }) {\n    super(`Object size exceeds maximum (4294967295): ${size}`)\n  }\n}\n\nexport class ByteStringTooLargeError extends Errors.BaseError {\n  override readonly name = 'Cbor.ByteStringTooLargeError'\n\n  constructor({ size }: { size: number }) {\n    super(`Byte string length exceeds maximum (4294967295): ${size}`)\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor.Cursor): void\n}\n\n/** @internal */\n// biome-ignore lint/correctness/noUnusedVariables: _\nfunction getEncodable(value: unknown): Encodable {\n  if (typeof value === 'undefined')\n    return { length: 1, encode: (cursor) => cursor.pushUint8(0xf7) }\n\n  if (value === null)\n    return { length: 1, encode: (cursor) => cursor.pushUint8(0xf6) }\n\n  if (typeof value === 'boolean')\n    return {\n      length: 1,\n      encode: (cursor) => cursor.pushUint8(value ? 0xf5 : 0xf4),\n    }\n\n  if (typeof value === 'number') return getEncodable.number(value as number)\n\n  if (typeof value === 'bigint') throw new UnsupportedBigIntError()\n\n  if (typeof value === 'string') return getEncodable.string(value as string)\n\n  if (Array.isArray(value)) return getEncodable.array(value)\n\n  if (value instanceof Uint8Array) return getEncodable.byteString(value)\n\n  if (value instanceof ArrayBuffer)\n    return getEncodable.byteString(new Uint8Array(value))\n\n  if (ArrayBuffer.isView(value))\n    return getEncodable.byteString(\n      new Uint8Array(value.buffer, value.byteOffset, value.byteLength),\n    )\n\n  if (value instanceof Map)\n    return getEncodable.map(value as Map<unknown, unknown>)\n\n  if (typeof value === 'object')\n    return getEncodable.object(value as Record<string, unknown>)\n\n  throw new UnexpectedTokenError({ token: String(value) })\n}\n\n/** @internal */\nnamespace getEncodable {\n  /** @internal */\n  export function number(value: number): Encodable {\n    // Handle non-safe integers (floats, NaN, Infinity)\n    if (!Number.isSafeInteger(value)) {\n      // Use Float32 if the value can be represented without precision loss\n      // This creates smaller encodings when possible (5 bytes vs 9 bytes)\n      const float32 = Math.fround(value)\n      if (Number.isNaN(value) || value === float32)\n        return {\n          length: 5, // 1 byte prefix + 4 bytes float32\n          encode(cursor) {\n            cursor.pushUint8(0xfa)\n            cursor.dataView.setFloat32(cursor.position, value, false)\n            cursor.position += 4\n          },\n        }\n      return {\n        length: 9, // 1 byte prefix + 8 bytes float64\n        encode(cursor) {\n          cursor.pushUint8(0xfb)\n          cursor.dataView.setFloat64(cursor.position, value, false)\n          cursor.position += 8\n        },\n      }\n    }\n\n    // Handle positive integers\n    if (value >= 0) {\n      if (value <= 0x17)\n        return { length: 1, encode: (cursor) => cursor.pushUint8(value) }\n      if (value <= 0xff)\n        return {\n          length: 2, // 1 byte prefix + 1 byte uint8\n          encode: (cursor) => {\n            cursor.pushUint8(0x18)\n            cursor.pushUint8(value)\n          },\n        }\n      if (value <= 0xffff)\n        return {\n          length: 3, // 1 byte prefix + 2 bytes uint16\n          encode: (cursor) => {\n            cursor.pushUint8(0x19)\n            cursor.pushUint16(value)\n          },\n        }\n      if (value <= 0xffffffff)\n        return {\n          length: 5, // 1 byte prefix + 4 bytes uint32\n          encode: (cursor) => {\n            cursor.pushUint8(0x1a)\n            cursor.pushUint32(value)\n          },\n        }\n      throw new NumberTooLargeError({ number: value.toString(10) })\n    }\n\n    // Handle negative integers\n    // CBOR encodes -n as (n-1)\n    const positiveNumber = -1 - value\n\n    if (value >= -24)\n      return {\n        length: 1,\n        encode: (cursor) => cursor.pushUint8(0x20 + positiveNumber),\n      }\n    if (positiveNumber <= 0xff)\n      return {\n        length: 2, // 1 byte prefix + 1 byte uint8\n        encode: (cursor) => {\n          cursor.pushUint8(0x38)\n          cursor.pushUint8(positiveNumber)\n        },\n      }\n    if (positiveNumber <= 0xffff)\n      return {\n        length: 3, // 1 byte prefix + 2 bytes uint16\n        encode: (cursor) => {\n          cursor.pushUint8(0x39)\n          cursor.pushUint16(positiveNumber)\n        },\n      }\n    if (positiveNumber <= 0xffffffff)\n      return {\n        length: 5, // 1 byte prefix + 4 bytes uint32\n        encode: (cursor) => {\n          cursor.pushUint8(0x3a)\n          cursor.pushUint32(positiveNumber)\n        },\n      }\n    throw new NumberTooLargeError({ number: value.toString(10) })\n  }\n\n  /** @internal */\n  export function string(value: string): Encodable {\n    const encoded = Bytes.fromString(value)\n    const size = encoded.length\n\n    if (size <= 0x17)\n      return {\n        length: 1 + size, // 1 byte prefix + size bytes\n        encode(cursor) {\n          cursor.pushUint8(0x60 + size)\n          if (size > 0) cursor.pushBytes(encoded)\n        },\n      }\n    if (size <= 0xff)\n      return {\n        length: 2 + size, // 1 byte prefix + 1 byte uint8 + size bytes\n        encode(cursor) {\n          cursor.pushUint8(0x78)\n          cursor.pushUint8(size)\n          cursor.pushBytes(encoded)\n        },\n      }\n\n    if (size <= 0xffff)\n      return {\n        length: 3 + size, // 1 byte prefix + 2 bytes uint16 + size bytes\n        encode(cursor) {\n          cursor.pushUint8(0x79)\n          cursor.pushUint16(size)\n          cursor.pushBytes(encoded)\n        },\n      }\n\n    if (size <= 0xffffffff)\n      return {\n        length: 5 + size, // 1 byte prefix + 4 bytes uint32 + size bytes\n        encode(cursor) {\n          cursor.pushUint8(0x7a)\n          cursor.pushUint32(size)\n          cursor.pushBytes(encoded)\n        },\n      }\n\n    throw new StringTooLargeError({ size })\n  }\n\n  /** @internal */\n  export function array(value: unknown[]): Encodable {\n    const items = value.map((item) => getEncodable(item))\n    const bodyLength = items.reduce((acc, item) => acc + item.length, 0)\n    const size = value.length\n\n    if (size <= 0x17)\n      return {\n        length: 1 + bodyLength, // 1 byte prefix + body length\n        encode(cursor) {\n          cursor.pushUint8(0x80 + size)\n          for (const item of items) item.encode(cursor)\n        },\n      }\n    if (size <= 0xff)\n      return {\n        length: 2 + bodyLength, // 1 byte prefix + 1 byte uint8 + body length\n        encode(cursor) {\n          cursor.pushUint8(0x98)\n          cursor.pushUint8(size)\n          for (const item of items) item.encode(cursor)\n        },\n      }\n    if (size <= 0xffff)\n      return {\n        length: 3 + bodyLength, // 1 byte prefix + 2 bytes uint16 + body length\n        encode(cursor) {\n          cursor.pushUint8(0x99)\n          cursor.pushUint16(size)\n          for (const item of items) item.encode(cursor)\n        },\n      }\n    if (size <= 0xffffffff)\n      return {\n        length: 5 + bodyLength, // 1 byte prefix + 4 bytes uint32 + body length\n        encode(cursor) {\n          cursor.pushUint8(0x9a)\n          cursor.pushUint32(size)\n          for (const item of items) item.encode(cursor)\n        },\n      }\n    throw new ArrayTooLargeError({ size })\n  }\n\n  /** @internal */\n  export function byteString(value: Uint8Array): Encodable {\n    const size = value.byteLength\n\n    if (size <= 0x17)\n      return {\n        length: 1 + size, // 1 byte prefix + size bytes\n        encode(cursor) {\n          cursor.pushUint8(0x40 + size)\n          cursor.pushBytes(value)\n        },\n      }\n    if (size <= 0xff)\n      return {\n        length: 2 + size, // 1 byte prefix + 1 byte uint8 + size bytes\n        encode(cursor) {\n          cursor.pushUint8(0x58)\n          cursor.pushUint8(size)\n          cursor.pushBytes(value)\n        },\n      }\n    if (size <= 0xffff)\n      return {\n        length: 3 + size, // 1 byte prefix + 2 bytes uint16 + size bytes\n        encode(cursor) {\n          cursor.pushUint8(0x59)\n          cursor.pushUint16(size)\n          cursor.pushBytes(value)\n        },\n      }\n    if (size <= 0xffffffff)\n      return {\n        length: 5 + size, // 1 byte prefix + 4 bytes uint32 + size bytes\n        encode(cursor) {\n          cursor.pushUint8(0x5a)\n          cursor.pushUint32(size)\n          cursor.pushBytes(value)\n        },\n      }\n    throw new ByteStringTooLargeError({ size })\n  }\n\n  /** @internal */\n  export function object(value: Record<string, unknown>): Encodable {\n    const keys = Object.keys(value)\n    const entries = keys.map((key) => ({\n      key: getEncodable(key),\n      value: getEncodable(value[key]),\n    }))\n    const bodyLength = entries.reduce(\n      (acc, entry) => acc + entry.key.length + entry.value.length,\n      0,\n    )\n    const size = keys.length\n\n    if (size <= 0x17)\n      return {\n        length: 1 + bodyLength, // 1 byte prefix + body length\n        encode(cursor) {\n          cursor.pushUint8(0xa0 + size)\n          for (const entry of entries) {\n            entry.key.encode(cursor)\n            entry.value.encode(cursor)\n          }\n        },\n      }\n    if (size <= 0xff)\n      return {\n        length: 2 + bodyLength, // 1 byte prefix + 1 byte uint8 + body length\n        encode(cursor) {\n          cursor.pushUint8(0xb8)\n          cursor.pushUint8(size)\n          for (const entry of entries) {\n            entry.key.encode(cursor)\n            entry.value.encode(cursor)\n          }\n        },\n      }\n    if (size <= 0xffff)\n      return {\n        length: 3 + bodyLength, // 1 byte prefix + 2 bytes uint16 + body length\n        encode(cursor) {\n          cursor.pushUint8(0xb9)\n          cursor.pushUint16(size)\n          for (const entry of entries) {\n            entry.key.encode(cursor)\n            entry.value.encode(cursor)\n          }\n        },\n      }\n    if (size <= 0xffffffff)\n      return {\n        length: 5 + bodyLength, // 1 byte prefix + 4 bytes uint32 + body length\n        encode(cursor) {\n          cursor.pushUint8(0xba)\n          cursor.pushUint32(size)\n          for (const entry of entries) {\n            entry.key.encode(cursor)\n            entry.value.encode(cursor)\n          }\n        },\n      }\n    throw new ObjectTooLargeError({ size })\n  }\n\n  /** @internal */\n  export function map(value: Map<unknown, unknown>): Encodable {\n    const entries: { key: Encodable; value: Encodable }[] = []\n    for (const [k, v] of value)\n      entries.push({ key: getEncodable(k), value: getEncodable(v) })\n    const bodyLength = entries.reduce(\n      (acc, entry) => acc + entry.key.length + entry.value.length,\n      0,\n    )\n    const size = value.size\n\n    if (size <= 0x17)\n      return {\n        length: 1 + bodyLength,\n        encode(cursor) {\n          cursor.pushUint8(0xa0 + size)\n          for (const entry of entries) {\n            entry.key.encode(cursor)\n            entry.value.encode(cursor)\n          }\n        },\n      }\n    if (size <= 0xff)\n      return {\n        length: 2 + bodyLength,\n        encode(cursor) {\n          cursor.pushUint8(0xb8)\n          cursor.pushUint8(size)\n          for (const entry of entries) {\n            entry.key.encode(cursor)\n            entry.value.encode(cursor)\n          }\n        },\n      }\n    if (size <= 0xffff)\n      return {\n        length: 3 + bodyLength,\n        encode(cursor) {\n          cursor.pushUint8(0xb9)\n          cursor.pushUint16(size)\n          for (const entry of entries) {\n            entry.key.encode(cursor)\n            entry.value.encode(cursor)\n          }\n        },\n      }\n    if (size <= 0xffffffff)\n      return {\n        length: 5 + bodyLength,\n        encode(cursor) {\n          cursor.pushUint8(0xba)\n          cursor.pushUint32(size)\n          for (const entry of entries) {\n            entry.key.encode(cursor)\n            entry.value.encode(cursor)\n          }\n        },\n      }\n    throw new ObjectTooLargeError({ size })\n  }\n}\n\n/** @internal */\n// biome-ignore lint/correctness/noUnusedVariables: _\nfunction decodeCursor(cursor: Cursor.Cursor): unknown {\n  const initialByte = cursor.readUint8()\n  const majorType = initialByte >> 5\n  const additionalInfo = initialByte & 0b00011111\n\n  switch (majorType) {\n    // Major type 0: Unsigned integer\n    case 0:\n      return decodeCursor.readUnsignedInteger(cursor, additionalInfo)\n\n    // Major type 1: Negative integer\n    case 1:\n      return decodeCursor.readNegativeInteger(cursor, additionalInfo)\n\n    // Major type 2: Byte string\n    case 2:\n      return decodeCursor.readByteString(cursor, additionalInfo)\n\n    // Major type 3: Text string\n    case 3:\n      return decodeCursor.readTextString(cursor, additionalInfo)\n\n    // Major type 4: Array\n    case 4:\n      return decodeCursor.readArray(cursor, additionalInfo)\n\n    // Major type 5: Map\n    case 5:\n      return decodeCursor.readMap(cursor, additionalInfo)\n\n    // Major type 6: Tagged data (not yet supported)\n    case 6:\n      throw new UnsupportedTagError({ tag: additionalInfo })\n\n    // Major type 7: Simple values and floats\n    case 7:\n      return decodeCursor.readSimpleOrFloat(cursor, additionalInfo)\n\n    default:\n      throw new InvalidMajorTypeError({ majorType })\n  }\n}\n\n/** @internal */\nnamespace decodeCursor {\n  export type ErrorType =\n    | readUnsignedInteger.ErrorType\n    | readNegativeInteger.ErrorType\n    | readByteString.ErrorType\n    | readTextString.ErrorType\n    | readArray.ErrorType\n    | readMap.ErrorType\n    | readSimpleOrFloat.ErrorType\n    | UnsupportedTagError\n    | InvalidMajorTypeError\n    | Errors.GlobalErrorType\n\n  /** @internal */\n  // biome-ignore lint/correctness/noUnusedVariables: _\n  function readLength(cursor: Cursor.Cursor, additionalInfo: number): number {\n    if (additionalInfo < 24) return additionalInfo\n    if (additionalInfo === 24) return cursor.readUint8()\n    if (additionalInfo === 25) return cursor.readUint16()\n    if (additionalInfo === 26) return cursor.readUint32()\n    if (additionalInfo === 27) throw new Unsupported64BitIntegerError()\n    throw new InvalidAdditionalInfoError({ additionalInfo })\n  }\n\n  /** @internal */\n  export declare namespace readLength {\n    type ErrorType =\n      | Unsupported64BitIntegerError\n      | InvalidAdditionalInfoError\n      | Errors.GlobalErrorType\n  }\n\n  /** @internal */\n  export function readUnsignedInteger(\n    cursor: Cursor.Cursor,\n    additionalInfo: number,\n  ): number {\n    return readLength(cursor, additionalInfo)\n  }\n\n  /** @internal */\n  export declare namespace readUnsignedInteger {\n    type ErrorType = readLength.ErrorType | Errors.GlobalErrorType\n  }\n\n  /** @internal */\n  export function readNegativeInteger(\n    cursor: Cursor.Cursor,\n    additionalInfo: number,\n  ): number {\n    const value = readLength(cursor, additionalInfo)\n    return -1 - value\n  }\n\n  /** @internal */\n  export declare namespace readNegativeInteger {\n    type ErrorType = readLength.ErrorType | Errors.GlobalErrorType\n  }\n\n  /** @internal */\n  export function readByteString(\n    cursor: Cursor.Cursor,\n    additionalInfo: number,\n  ): Bytes.Bytes {\n    // Indefinite-length byte string\n    if (additionalInfo === 31) {\n      const chunks: Bytes.Bytes[] = []\n      let totalLength = 0\n\n      while (true) {\n        const byte = cursor.inspectUint8()\n        if (byte === 0xff) {\n          cursor.readUint8() // consume the break byte\n          break\n        }\n        const chunk = decodeCursor(cursor) as Bytes.Bytes\n        if (!(chunk instanceof Uint8Array))\n          throw new InvalidIndefiniteLengthChunkError({ type: 'byte string' })\n        chunks.push(chunk)\n        totalLength += chunk.length\n      }\n\n      // Concatenate chunks\n      const result = new Uint8Array(totalLength)\n      let offset = 0\n      for (const chunk of chunks) {\n        result.set(chunk, offset)\n        offset += chunk.length\n      }\n      return result\n    }\n\n    const length = readLength(cursor, additionalInfo)\n    return cursor.readBytes(length)\n  }\n\n  /** @internal */\n  export declare namespace readByteString {\n    type ErrorType =\n      | readLength.ErrorType\n      | InvalidIndefiniteLengthChunkError\n      | Errors.GlobalErrorType\n  }\n\n  /** @internal */\n  export function readTextString(\n    cursor: Cursor.Cursor,\n    additionalInfo: number,\n  ): string {\n    // Indefinite-length text string\n    if (additionalInfo === 31) {\n      const chunks: string[] = []\n\n      while (true) {\n        const byte = cursor.inspectUint8()\n        if (byte === 0xff) {\n          cursor.readUint8() // consume the break byte\n          break\n        }\n        const chunk = decodeCursor(cursor)\n        if (typeof chunk !== 'string')\n          throw new InvalidIndefiniteLengthChunkError({ type: 'text string' })\n        chunks.push(chunk)\n      }\n\n      return chunks.join('')\n    }\n\n    const length = readLength(cursor, additionalInfo)\n    const bytes = cursor.readBytes(length)\n    return Bytes.toString(bytes)\n  }\n\n  /** @internal */\n  export declare namespace readTextString {\n    type ErrorType =\n      | readLength.ErrorType\n      | Bytes.toString.ErrorType\n      | InvalidIndefiniteLengthChunkError\n      | Errors.GlobalErrorType\n  }\n\n  /** @internal */\n  export function readArray(\n    cursor: Cursor.Cursor,\n    additionalInfo: number,\n  ): unknown[] {\n    // Indefinite-length array\n    if (additionalInfo === 31) {\n      const result: unknown[] = []\n\n      while (true) {\n        const byte = cursor.inspectUint8()\n        if (byte === 0xff) {\n          cursor.readUint8() // consume the break byte\n          break\n        }\n        result.push(decodeCursor(cursor))\n      }\n\n      return result\n    }\n\n    const length = readLength(cursor, additionalInfo)\n    const result: unknown[] = []\n\n    for (let i = 0; i < length; i++) {\n      result.push(decodeCursor(cursor))\n    }\n\n    return result\n  }\n\n  /** @internal */\n  export declare namespace readArray {\n    type ErrorType = readLength.ErrorType | Errors.GlobalErrorType\n  }\n\n  /** @internal */\n  export function readMap(\n    cursor: Cursor.Cursor,\n    additionalInfo: number,\n  ): Record<string, unknown> {\n    // Indefinite-length map\n    if (additionalInfo === 31) {\n      const result: Record<string, unknown> = {}\n\n      while (true) {\n        const byte = cursor.inspectUint8()\n        if (byte === 0xff) {\n          cursor.readUint8() // consume the break byte\n          break\n        }\n        const key = decodeCursor(cursor)\n        // Support both string and number keys (for COSE_Key with integer keys)\n        const keyStr =\n          typeof key === 'string'\n            ? key\n            : typeof key === 'number'\n              ? String(key)\n              : String(key)\n        const value = decodeCursor(cursor)\n        result[keyStr] = value\n      }\n\n      return result\n    }\n\n    const length = readLength(cursor, additionalInfo)\n    const result: Record<string, unknown> = {}\n\n    for (let i = 0; i < length; i++) {\n      const key = decodeCursor(cursor)\n      // Support both string and number keys (for COSE_Key with integer keys)\n      const keyStr =\n        typeof key === 'string'\n          ? key\n          : typeof key === 'number'\n            ? String(key)\n            : String(key)\n      const value = decodeCursor(cursor)\n      result[keyStr] = value\n    }\n\n    return result\n  }\n\n  /** @internal */\n  export declare namespace readMap {\n    type ErrorType = readLength.ErrorType | Errors.GlobalErrorType\n  }\n\n  /** @internal */\n  export function readSimpleOrFloat(\n    cursor: Cursor.Cursor,\n    additionalInfo: number,\n  ): unknown {\n    // Simple values\n    if (additionalInfo === 20) return false\n    if (additionalInfo === 21) return true\n    if (additionalInfo === 22) return null\n    if (additionalInfo === 23) return undefined\n\n    // Float16 (half-precision)\n    if (additionalInfo === 25) {\n      const bits = cursor.readUint16()\n      return getFloat16(bits)\n    }\n\n    // Float32\n    if (additionalInfo === 26) {\n      const value = cursor.dataView.getFloat32(cursor.position, false)\n      cursor.position += 4\n      return value\n    }\n\n    // Float64\n    if (additionalInfo === 27) {\n      const value = cursor.dataView.getFloat64(cursor.position, false)\n      cursor.position += 8\n      return value\n    }\n\n    // Simple value (additional byte)\n    if (additionalInfo === 24) {\n      const simpleValue = cursor.readUint8()\n      // Simple values 0-19 are assigned, 20-23 are in the initial byte\n      // 24-31 are reserved, 32-255 are unassigned\n      if (simpleValue < 32)\n        throw new InvalidSimpleValueError({ value: simpleValue })\n      // For now, treat unassigned simple values as undefined\n      return undefined\n    }\n\n    throw new InvalidAdditionalInfoError({ additionalInfo })\n  }\n\n  /** @internal */\n  export declare namespace readSimpleOrFloat {\n    type ErrorType =\n      | InvalidSimpleValueError\n      | InvalidAdditionalInfoError\n      | Errors.GlobalErrorType\n  }\n\n  /** @internal */\n  function getFloat16(bits: number): number {\n    // IEEE 754 half-precision (16-bit) float decoding\n    // Format: 1 sign bit, 5 exponent bits, 10 fraction bits\n    const sign = (bits >> 15) & 0x1\n    const exponent = (bits >> 10) & 0x1f\n    const fraction = bits & 0x3ff\n\n    // Handle special cases\n    if (exponent === 0) {\n      // Subnormal numbers or zero\n      if (fraction === 0) return sign ? -0 : 0\n      // Subnormal: (-1)^sign  2^(-14)  (0 + fraction/1024)\n      const value = 2 ** -14 * (fraction / 1024)\n      return sign ? -value : value\n    }\n\n    if (exponent === 0x1f) {\n      // Infinity or NaN\n      if (fraction === 0) return sign ? -Infinity : Infinity\n      return NaN\n    }\n\n    // Normal numbers: (-1)^sign  2^(exponent-15)  (1 + fraction/1024)\n    const value = 2 ** (exponent - 15) * (1 + fraction / 1024)\n    return sign ? -value : value\n  }\n}\n", "import * as Cbor from './Cbor.js'\nimport * as Errors from './Errors.js'\nimport type * as Hex from './Hex.js'\nimport * as PublicKey from './PublicKey.js'\n\n/**\n * Converts a P256 {@link ox#PublicKey.PublicKey} to a CBOR-encoded COSE_Key.\n *\n * The COSE_Key uses integer map keys per [RFC 9053](https://datatracker.ietf.org/doc/html/rfc9053):\n * - `1` (kty): `2` (EC2)\n * - `3` (alg): `-7` (ES256)\n * - `-1` (crv): `1` (P-256)\n * - `-2` (x): x coordinate bytes\n * - `-3` (y): y coordinate bytes\n *\n * @example\n * ```ts twoslash\n * import { CoseKey, P256 } from 'ox'\n *\n * const { publicKey } = P256.createKeyPair()\n *\n * const coseKey = CoseKey.fromPublicKey(publicKey)\n * ```\n *\n * @param publicKey - The P256 public key to convert.\n * @returns The CBOR-encoded COSE_Key as a Hex string.\n */\nexport function fromPublicKey(publicKey: PublicKey.PublicKey): Hex.Hex {\n  const pkBytes = PublicKey.toBytes(publicKey)\n  const x = pkBytes.slice(1, 33)\n  const y = pkBytes.slice(33, 65)\n  return Cbor.encode(\n    new Map<number, unknown>([\n      [1, 2], // kty: EC2\n      [3, -7], // alg: ES256\n      [-1, 1], // crv: P-256\n      [-2, x], // x coordinate\n      [-3, y], // y coordinate\n    ]),\n  )\n}\n\nexport declare namespace fromPublicKey {\n  type ErrorType =\n    | PublicKey.toBytes.ErrorType\n    | Cbor.encode.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a CBOR-encoded COSE_Key to a P256 {@link ox#PublicKey.PublicKey}.\n *\n * @example\n * ```ts twoslash\n * import { CoseKey, P256 } from 'ox'\n *\n * const { publicKey } = P256.createKeyPair()\n * const coseKey = CoseKey.fromPublicKey(publicKey)\n *\n * const publicKey2 = CoseKey.toPublicKey(coseKey)\n * ```\n *\n * @param coseKey - The CBOR-encoded COSE_Key.\n * @returns The P256 public key.\n */\nexport function toPublicKey(coseKey: Hex.Hex): PublicKey.PublicKey {\n  const decoded = Cbor.decode<Record<string, unknown>>(coseKey)\n\n  const x = decoded['-2']\n  const y = decoded['-3']\n\n  if (!(x instanceof Uint8Array) || !(y instanceof Uint8Array))\n    throw new InvalidCoseKeyError()\n\n  return PublicKey.from(new Uint8Array([0x04, ...x, ...y]))\n}\n\nexport declare namespace toPublicKey {\n  type ErrorType =\n    | Cbor.decode.ErrorType\n    | PublicKey.from.ErrorType\n    | InvalidCoseKeyError\n    | Errors.GlobalErrorType\n}\n\n/** Thrown when a COSE_Key does not contain valid P256 public key coordinates. */\nexport class InvalidCoseKeyError extends Errors.BaseError {\n  override readonly name = 'CoseKey.InvalidCoseKeyError'\n\n  constructor() {\n    super('COSE_Key does not contain valid P256 public key coordinates.')\n  }\n}\n", "import { p256 } from '@noble/curves/p256'\nimport type * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\nimport * as PublicKey from '../PublicKey.js'\nimport { CredentialCreationFailedError } from '../WebAuthnP256.js'\n\n/** @internal */\nexport type AttestationConveyancePreference =\n  | 'direct'\n  | 'enterprise'\n  | 'indirect'\n  | 'none'\n\n/** @internal */\nexport type AuthenticatorAttachment = 'cross-platform' | 'platform'\n\n/** @internal */\nexport type AuthenticatorTransport =\n  | 'ble'\n  | 'hybrid'\n  | 'internal'\n  | 'nfc'\n  | 'usb'\n\n/** @internal */\nexport type COSEAlgorithmIdentifier = number\n\n/** @internal */\nexport type CredentialMediationRequirement =\n  | 'conditional'\n  | 'optional'\n  | 'required'\n  | 'silent'\n\n/** @internal */\nexport type PublicKeyCredentialType = 'public-key'\n\n/** @internal */\nexport type ResidentKeyRequirement = 'discouraged' | 'preferred' | 'required'\n\n/** @internal */\nexport type UserVerificationRequirement =\n  | 'discouraged'\n  | 'preferred'\n  | 'required'\n\n/** @internal */\nexport type LargeBlobSupport = {\n  support: 'required' | 'preferred'\n}\n\n/** @internal */\nexport type BufferSource = ArrayBufferView | ArrayBuffer\n\n/** @internal */\nexport type PrfExtension = Record<'eval', Record<'first', Uint8Array>>\n\n/** @internal */\nexport interface AuthenticationExtensionsClientInputs {\n  appid?: string\n  credProps?: boolean\n  hmacCreateSecret?: boolean\n  minPinLength?: boolean\n  prf?: PrfExtension\n  largeBlob?: LargeBlobSupport\n}\n\n/** @internal */\nexport interface AuthenticatorSelectionCriteria {\n  authenticatorAttachment?: AuthenticatorAttachment\n  requireResidentKey?: boolean\n  residentKey?: ResidentKeyRequirement\n  userVerification?: UserVerificationRequirement\n}\n\n/** @internal */\nexport interface Credential {\n  readonly id: string\n  readonly type: string\n}\n\n/** @internal */\nexport interface CredentialCreationOptions {\n  publicKey?: PublicKeyCredentialCreationOptions\n  signal?: AbortSignal\n}\n\n/** @internal */\nexport interface CredentialRequestOptions {\n  mediation?: CredentialMediationRequirement\n  publicKey?: PublicKeyCredentialRequestOptions\n  signal?: AbortSignal\n}\n\n/** @internal */\nexport interface PublicKeyCredential extends Credential {\n  readonly authenticatorAttachment: string | null\n  readonly rawId: ArrayBuffer\n  readonly response: AuthenticatorResponse\n  getClientExtensionResults(): AuthenticationExtensionsClientOutputs\n}\n\n/** @internal */\nexport interface PublicKeyCredentialCreationOptions {\n  attestation?: AttestationConveyancePreference\n  authenticatorSelection?: AuthenticatorSelectionCriteria\n  challenge: BufferSource\n  excludeCredentials?: PublicKeyCredentialDescriptor[]\n  extensions?: AuthenticationExtensionsClientInputs\n  pubKeyCredParams: PublicKeyCredentialParameters[]\n  rp: PublicKeyCredentialRpEntity\n  timeout?: number\n  user: PublicKeyCredentialUserEntity\n}\n\n/** @internal */\nexport interface PublicKeyCredentialDescriptor {\n  id: BufferSource\n  transports?: AuthenticatorTransport[]\n  type: PublicKeyCredentialType\n}\n\n/** @internal */\nexport interface PublicKeyCredentialEntity {\n  name: string\n}\n\n/** @internal */\nexport interface PublicKeyCredentialParameters {\n  alg: COSEAlgorithmIdentifier\n  type: PublicKeyCredentialType\n}\n\n/** @internal */\nexport interface PublicKeyCredentialRequestOptions {\n  allowCredentials?: PublicKeyCredentialDescriptor[]\n  challenge: BufferSource\n  extensions?: AuthenticationExtensionsClientInputs\n  rpId?: string\n  timeout?: number\n  userVerification?: UserVerificationRequirement\n}\n\n/** @internal */\nexport interface PublicKeyCredentialRpEntity extends PublicKeyCredentialEntity {\n  id?: string\n}\n\n/** @internal */\nexport interface PublicKeyCredentialUserEntity\n  extends PublicKeyCredentialEntity {\n  displayName: string\n  id: BufferSource\n}\n\n/**\n * Parses an ASN.1 signature into a r and s value.\n *\n * @internal\n */\nexport function parseAsn1Signature(bytes: Uint8Array) {\n  const r_start = bytes[4] === 0 ? 5 : 4\n  const r_end = r_start + 32\n  const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2\n\n  const r = BigInt(Hex.fromBytes(bytes.slice(r_start, r_end)))\n  const s = BigInt(Hex.fromBytes(bytes.slice(s_start)))\n\n  return {\n    r,\n    s: s > p256.CURVE.n / 2n ? p256.CURVE.n - s : s,\n  }\n}\n\n/**\n * Parses a public key into x and y coordinates from the public key\n * defined on the credential.\n *\n * @internal\n */\nexport async function parseCredentialPublicKey(\n  response: AuthenticatorAttestationResponse,\n): Promise<PublicKey.PublicKey> {\n  try {\n    const publicKeyBuffer = response.getPublicKey()\n    if (!publicKeyBuffer) throw new CredentialCreationFailedError()\n\n    // Converting `publicKeyBuffer` throws when credential is created by 1Password Firefox Add-on\n    const publicKeyBytes = new Uint8Array(publicKeyBuffer)\n    const cryptoKey = await crypto.subtle.importKey(\n      'spki',\n      new Uint8Array(publicKeyBytes),\n      {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n        hash: 'SHA-256',\n      },\n      true,\n      ['verify'],\n    )\n    const publicKey = new Uint8Array(\n      await crypto.subtle.exportKey('raw', cryptoKey),\n    )\n    return PublicKey.from(publicKey)\n  } catch (error) {\n    // Fallback for 1Password Firefox Add-on restricts access to certain credential properties\n    // so we need to use `attestationObject` to extract the public key.\n    // https://github.com/passwordless-id/webauthn/issues/50#issuecomment-2072902094\n    if ((error as Error).message !== 'Permission denied to access object')\n      throw error\n\n    const data = new Uint8Array(response.attestationObject)\n    const coordinateLength = 0x20\n    const cborPrefix = 0x58\n\n    const findStart = (key: number) => {\n      const coordinate = new Uint8Array([key, cborPrefix, coordinateLength])\n      for (let i = 0; i < data.length - coordinate.length; i++)\n        if (coordinate.every((byte, j) => data[i + j] === byte))\n          return i + coordinate.length\n      throw new CredentialCreationFailedError()\n    }\n\n    const xStart = findStart(0x21)\n    const yStart = findStart(0x22)\n\n    return PublicKey.from(\n      new Uint8Array([\n        0x04,\n        ...data.slice(xStart, xStart + coordinateLength),\n        ...data.slice(yStart, yStart + coordinateLength),\n      ]),\n    )\n  }\n}\n\nexport declare namespace parseCredentialPublicKey {\n  type ErrorType = CredentialCreationFailedError | Errors.GlobalErrorType\n}\n", "import type * as Address from './Address.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\nimport * as Log from './Log.js'\n\n/** An Transaction Receipt as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/receipt.yaml). */\nexport type TransactionReceipt<\n  status = Status,\n  type = Type,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<{\n  /** The actual value per gas deducted from the sender's account for blob gas. Only specified for blob transactions as defined by EIP-4844. */\n  blobGasPrice?: bigintType | undefined\n  /** The amount of blob gas used. Only specified for blob transactions as defined by EIP-4844. */\n  blobGasUsed?: bigintType | undefined\n  /** Hash of block containing this transaction */\n  blockHash: Hex.Hex\n  /** Number of block containing this transaction */\n  blockNumber: bigintType\n  /** Address of new contract or `null` if no contract was created */\n  contractAddress?: Address.Address | null | undefined\n  /** Gas used by this and all preceding transactions in this block */\n  cumulativeGasUsed: bigintType\n  /** Pre-London, it is equal to the transaction's gasPrice. Post-London, it is equal to the actual gas price paid for inclusion. */\n  effectiveGasPrice: bigintType\n  /** Transaction sender */\n  from: Address.Address\n  /** Gas used by this transaction */\n  gasUsed: bigintType\n  /** List of log objects generated by this transaction */\n  logs: Log.Log<false, bigintType, numberType>[]\n  /** Logs bloom filter */\n  logsBloom: Hex.Hex\n  /** The post-transaction state root. Only specified for transactions included before the Byzantium upgrade. */\n  root?: Hex.Hex | undefined\n  /** `success` if this transaction was successful or `reverted` if it failed */\n  status: status\n  /** Transaction recipient or `null` if deploying a contract */\n  to: Address.Address | null\n  /** Hash of this transaction */\n  transactionHash: Hex.Hex\n  /** Index of this transaction in the block */\n  transactionIndex: numberType\n  /** Transaction type */\n  type: type\n}>\n\n/** An RPC Transaction Receipt as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/receipt.yaml). */\nexport type Rpc = TransactionReceipt<RpcStatus, RpcType, Hex.Hex, Hex.Hex>\n\n/**\n * Union of Transaction Receipt statuses.\n *\n * - `success`\n * - `reverted`\n */\nexport type Status = 'success' | 'reverted'\n\n/**\n * Union of RPC Transaction Receipt statuses.\n *\n * - `0x0`\n * - `0x1`\n */\nexport type RpcStatus = '0x0' | '0x1'\n\n/**\n * Union of Transaction Receipt types.\n *\n * - `legacy`\n * - `eip1559`\n * - `eip2930`\n * - `eip4844`\n * - `eip7702`\n * - any other string\n */\nexport type Type =\n  | 'legacy'\n  | 'eip1559'\n  | 'eip2930'\n  | 'eip4844'\n  | 'eip7702'\n  | (string & {})\n\n/**\n * Union of RPC Transaction Receipt types.\n *\n * - `0x0`: legacy transactions\n * - `0x1`: EIP-1559 transactions\n * - `0x2`: EIP-2930 transactions\n * - `0x3`: EIP-4844 transactions\n * - `0x4`: EIP-7702 transactions\n * - any other string\n */\nexport type RpcType = '0x0' | '0x1' | '0x2' | '0x3' | '0x4' | (string & {})\n\n/** RPC status to status mapping. */\nexport const fromRpcStatus = {\n  '0x0': 'reverted',\n  '0x1': 'success',\n} as const\n\n/** Status to RPC status mapping. */\nexport const toRpcStatus = {\n  reverted: '0x0',\n  success: '0x1',\n} as const\n\n/** RPC type to type mapping. */\nexport const fromRpcType = {\n  '0x0': 'legacy',\n  '0x1': 'eip2930',\n  '0x2': 'eip1559',\n  '0x3': 'eip4844',\n  '0x4': 'eip7702',\n} as const\n\n/** Type to RPC type mapping. */\nexport const toRpcType = {\n  legacy: '0x0',\n  eip2930: '0x1',\n  eip1559: '0x2',\n  eip4844: '0x3',\n  eip7702: '0x4',\n} as const\n\n/**\n * Converts a {@link ox#TransactionReceipt.Rpc} to an {@link ox#TransactionReceipt.TransactionReceipt}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionReceipt } from 'ox'\n *\n * const receipt = TransactionReceipt.fromRpc({\n *   blobGasPrice: '0x42069',\n *   blobGasUsed: '0x1337',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   contractAddress: null,\n *   cumulativeGasUsed: '0x82515',\n *   effectiveGasPrice: '0x21c2f6c09',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gasUsed: '0x2abba',\n *   logs: [],\n *   logsBloom:\n *     '0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000',\n *   status: '0x1',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionHash:\n *     '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   transactionIndex: '0x2',\n *   type: '0x2',\n * })\n * // @log: {\n * // @log:   blobGasPrice: 270441n,\n * // @log:   blobGasUsed: 4919n,\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: 19868015n,\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: 533781n,\n * // @log:   effectiveGasPrice: 9062804489n,\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: 175034n,\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"success\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: 2,\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an example of how to use the `TransactionReceipt.fromRpc` method to convert an RPC transaction receipt to a {@link ox#TransactionReceipt.TransactionReceipt} object.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { TransactionReceipt } from 'ox'\n *\n * const receipt = await window.ethereum!\n *   .request({\n *     method: 'eth_getTransactionReceipt',\n *     params: [\n *       '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *     ],\n *   })\n *   .then(TransactionReceipt.fromRpc) // [!code hl]\n * // @log: {\n * // @log:   blobGasPrice: 270441n,\n * // @log:   blobGasUsed: 4919n,\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: 19868015n,\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: 533781n,\n * // @log:   effectiveGasPrice: 9062804489n,\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: 175034n,\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"success\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: 2,\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param receipt - The RPC receipt to convert.\n * @returns An instantiated {@link ox#TransactionReceipt.TransactionReceipt}.\n */\nexport function fromRpc<const receipt extends Rpc | null>(\n  receipt: receipt | Rpc | null,\n): receipt extends Rpc ? TransactionReceipt : null {\n  if (!receipt) return null as never\n\n  return {\n    ...receipt,\n    blobGasPrice: receipt.blobGasPrice\n      ? BigInt(receipt.blobGasPrice)\n      : undefined,\n    blobGasUsed: receipt.blobGasUsed ? BigInt(receipt.blobGasUsed) : undefined,\n    blockNumber: BigInt(receipt.blockNumber ?? 0n),\n    cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed ?? 0n),\n    effectiveGasPrice: BigInt(receipt.effectiveGasPrice ?? 0n),\n    gasUsed: BigInt(receipt.gasUsed ?? 0n),\n    logs: receipt.logs.map((log) => Log.fromRpc(log, { pending: false })),\n    status: fromRpcStatus[receipt.status],\n    transactionIndex: Number(receipt.transactionIndex ?? 0),\n    type: (fromRpcType as any)[receipt.type] || receipt.type,\n  } as never\n}\n\nexport declare namespace fromRpc {\n  export type ErrorType = Log.fromRpc.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#TransactionReceipt.TransactionReceipt} to a {@link ox#TransactionReceipt.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionReceipt } from 'ox'\n *\n * const receipt = TransactionReceipt.toRpc({\n *   blobGasPrice: 270441n,\n *   blobGasUsed: 4919n,\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: 19868015n,\n *   contractAddress: null,\n *   cumulativeGasUsed: 533781n,\n *   effectiveGasPrice: 9062804489n,\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gasUsed: 175034n,\n *   logs: [],\n *   logsBloom:\n *     '0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000',\n *   root: undefined,\n *   status: 'success',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionHash:\n *     '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   transactionIndex: 2,\n *   type: 'eip1559',\n * })\n * // @log: {\n * // @log:   blobGasPrice: \"0x042069\",\n * // @log:   blobGasUsed: \"0x1337\",\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: \"0x012f296f\",\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: \"0x082515\",\n * // @log:   effectiveGasPrice: \"0x021c2f6c09\",\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: \"0x02abba\",\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"0x1\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: \"0x02\",\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * @param receipt - The receipt to convert.\n * @returns An RPC receipt.\n */\nexport function toRpc(receipt: TransactionReceipt): Rpc {\n  return {\n    blobGasPrice: receipt.blobGasPrice\n      ? Hex.fromNumber(receipt.blobGasPrice)\n      : undefined,\n    blobGasUsed: receipt.blobGasUsed\n      ? Hex.fromNumber(receipt.blobGasUsed)\n      : undefined,\n    blockHash: receipt.blockHash,\n    blockNumber: Hex.fromNumber(receipt.blockNumber),\n    contractAddress: receipt.contractAddress,\n    cumulativeGasUsed: Hex.fromNumber(receipt.cumulativeGasUsed),\n    effectiveGasPrice: Hex.fromNumber(receipt.effectiveGasPrice),\n    from: receipt.from,\n    gasUsed: Hex.fromNumber(receipt.gasUsed),\n    logs: receipt.logs.map(Log.toRpc as never),\n    logsBloom: receipt.logsBloom,\n    root: receipt.root,\n    status: toRpcStatus[receipt.status],\n    to: receipt.to,\n    transactionHash: receipt.transactionHash,\n    transactionIndex: Hex.fromNumber(receipt.transactionIndex),\n    type: (toRpcType as any)[receipt.type] ?? receipt.type,\n  }\n}\n\nexport declare namespace toRpc {\n  export type ErrorType = Hex.fromNumber.ErrorType | Errors.GlobalErrorType\n}\n", "import type * as Address from './Address.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\n\n/** A Log as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/receipt.yaml). */\nexport type Log<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<{\n  /** The address from which this log originated */\n  address: Address.Address\n  /** Hash of block containing this log or `null` if pending */\n  blockHash: pending extends true ? null : Hex.Hex\n  /** Number of block containing this log or `null` if pending */\n  blockNumber: pending extends true ? null : bigintType\n  /** Contains the non-integered arguments of the log */\n  data: Hex.Hex\n  /** Index of this log within its block or `null` if pending */\n  logIndex: pending extends true ? null : numberType\n  /** List of topics associated with this log */\n  topics: [Hex.Hex, ...(readonly Hex.Hex[])]\n  /** Hash of the transaction that created this log or `null` if pending */\n  transactionHash: pending extends true ? null : Hex.Hex\n  /** Index of the transaction that created this log or `null` if pending */\n  transactionIndex: pending extends true ? null : numberType\n  /** `true` if this filter has been destroyed and is invalid */\n  removed: boolean\n}>\n\n/** An RPC Log as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/receipt.yaml). */\nexport type Rpc<pending extends boolean = false> = Log<\n  pending,\n  Hex.Hex,\n  Hex.Hex\n>\n\n/**\n * Converts a {@link ox#Log.Rpc} to an {@link ox#Log.Log}.\n *\n * @example\n * ```ts twoslash\n * import { Log } from 'ox'\n *\n * const log = Log.fromRpc({\n *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x0000000000000000000000000000000000000000000000000000000000000000',\n *     '0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1',\n *     '0x000000000000000000000000000000000000000000000000000000000000025b',\n *   ],\n *   data: '0x',\n *   blockHash:\n *     '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n *   blockNumber: '0x12d846c',\n *   transactionHash:\n *     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n *   transactionIndex: '0x91',\n *   logIndex: '0x10f',\n *   removed: false,\n * })\n * // @log: {\n * // @log:   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * // @log:   blockHash: '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n * // @log:   blockNumber: 19760236n,\n * // @log:   data: '0x',\n * // @log:   logIndex: 271,\n * // @log:   removed: false,\n * // @log:   topics: [\n * // @log:     \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n * // @log:     \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n * // @log:     \"0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1\",\n * // @log:     \"0x000000000000000000000000000000000000000000000000000000000000025b\",\n * // @log:   transactionHash:\n * // @log:     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n * // @log:   transactionIndex: 145,\n * // @log: }\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an example of how to use `Log.fromRpc` to instantiate a {@link ox#Log.Log} from an RPC log.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiEvent, Hex, Log } from 'ox'\n *\n * const transfer = AbiEvent.from(\n *   'event Transfer(address indexed from, address indexed to, uint256 indexed value)',\n * )\n *\n * const { topics } = AbiEvent.encode(transfer)\n *\n * const logs = await window.ethereum!.request({\n *   method: 'eth_getLogs',\n *   params: [\n *     {\n *       address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *       fromBlock: Hex.fromNumber(19760235n),\n *       toBlock: Hex.fromNumber(19760240n),\n *       topics,\n *     },\n *   ],\n * })\n *\n * const log = Log.fromRpc(logs[0]) // [!code focus]\n * // @log: {\n * // @log:   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * // @log:   blockHash: '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n * // @log:   blockNumber: 19760236n,\n * // @log:   data: '0x',\n * // @log:   logIndex: 271,\n * // @log:   removed: false,\n * // @log:   topics: [\n * // @log:     \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n * // @log:     \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n * // @log:     \"0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1\",\n * // @log:     \"0x000000000000000000000000000000000000000000000000000000000000025b\",\n * // @log:   transactionHash:\n * // @log:     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n * // @log:   transactionIndex: 145,\n * // @log: }\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param log - The RPC log to convert.\n * @returns An instantiated {@link ox#Log.Log}.\n */\nexport function fromRpc<\n  const log extends Rpc<boolean>,\n  pending extends boolean = false,\n>(\n  log: log | Rpc<boolean>,\n  _options: fromRpc.Options<pending> = {},\n): Log<pending> {\n  return {\n    ...log,\n    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,\n    logIndex: log.logIndex ? Number(log.logIndex) : null,\n    transactionIndex: log.transactionIndex\n      ? Number(log.transactionIndex)\n      : null,\n  } as Log<pending>\n}\n\nexport declare namespace fromRpc {\n  type Options<pending extends boolean = false> = {\n    pending?: pending | boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Log.Log} to a {@link ox#Log.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Log } from 'ox'\n *\n * const log = Log.toRpc({\n *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *   blockHash:\n *     '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n *   blockNumber: 19760236n,\n *   data: '0x',\n *   logIndex: 271,\n *   removed: false,\n *   topics: [\n *     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n *     '0x0000000000000000000000000000000000000000000000000000000000000000',\n *     '0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1',\n *     '0x000000000000000000000000000000000000000000000000000000000000025b',\n *   ],\n *   transactionHash:\n *     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n *   transactionIndex: 145,\n * })\n * // @log: {\n * // @log:   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * // @log:   blockHash: '0xabe69134e80a12f6a93d0aa18215b5b86c2fb338bae911790ca374a8716e01a4',\n * // @log:   blockNumber: '0x012d846c',\n * // @log:   data: '0x',\n * // @log:   logIndex: '0x010f',\n * // @log:   removed: false,\n * // @log:   topics: [\n * // @log:     '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n * // @log:     '0x0000000000000000000000000000000000000000000000000000000000000000',\n * // @log:     '0x0000000000000000000000000c04d9e9278ec5e4d424476d3ebec70cb5d648d1',\n * // @log:     '0x000000000000000000000000000000000000000000000000000000000000025b',\n * // @log:   ],\n * // @log:   transactionHash:\n * // @log:     '0xcfa52db0bc2cb5bdcb2c5bd8816df7a2f018a0e3964ab1ef4d794cf327966e93',\n * // @log:   transactionIndex: '0x91',\n * // @log: }\n * ```\n *\n * @param log - The log to convert.\n * @returns An RPC log.\n */\nexport function toRpc<\n  const log extends Log<boolean>,\n  pending extends boolean = false,\n>(log: log, _options: toRpc.Options<pending> = {}): Rpc<pending> {\n  return {\n    address: log.address,\n    blockHash: log.blockHash,\n    blockNumber:\n      typeof log.blockNumber === 'bigint'\n        ? Hex.fromNumber(log.blockNumber)\n        : null,\n    data: log.data,\n    logIndex:\n      typeof log.logIndex === 'number' ? Hex.fromNumber(log.logIndex) : null,\n    topics: log.topics,\n    transactionHash: log.transactionHash,\n    transactionIndex:\n      typeof log.transactionIndex === 'number'\n        ? Hex.fromNumber(log.transactionIndex)\n        : null,\n    removed: log.removed,\n  } as Rpc as never\n}\n\nexport declare namespace toRpc {\n  type Options<pending extends boolean = false> = {\n    pending?: pending | boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA,IAAM,QAAQ,MAAM,OAAO,oEAAoE,CAAC;AAChG,IAAM,SAAS,MAAM,OAAO,OAAO,IAAI,CAAC;AACxC,IAAM,SAAS,OAAO,oEAAoE;AAOnF,IAAM,OAA0B,YAAY;EACjD,GAAG;EACH,GAAG;EACH,IAAI;EACJ,GAAG,OAAO,oEAAoE;EAC9E,IAAI,OAAO,oEAAoE;EAC/E,IAAI,OAAO,oEAAoE;EAC/E,GAAG,OAAO,CAAC;EACX,MAAM;GACI,MAAM;AAEX,IAAM,YAA+B;AAE5C,IAAM,eAA+B,MACnC,oBAAoB,OAAO;EACzB,GAAG;EACH,GAAG;EACH,GAAG,MAAM,OAAO,OAAO,KAAK,CAAC;CAC9B,GAAE;AAGE,IAAM,eAA+C,MAC1D,aAAa,UAAU,iBAAiB,CAAC,YAAsB,YAAY,QAAQ,CAAC,CAAC,GAAG;EACtF,KAAK;EACL,WAAW;EACX,GAAG,MAAM;EACT,GAAG;EACH,GAAG;EACH,QAAQ;EACR,MAAM;CACP,GAAE;AAGL,IAAM,QAAQ,MACZ,OACE,oGAAoG,CACrG;AAEH,IAAM,SAAS,MAAM,OAAO,OAAO,IAAI,CAAC;AAExC,IAAM,SAAS,OAAO,oGAAoG;AAOnH,IAAM,OAA0B,YAAY;EACjD,GAAG;EACH,GAAG;EACH,IAAI;EACJ,GAAG,OAAO,oGAAoG;EAC9G,IAAI,OAAO,oGAAoG;EAC/G,IAAI,OAAO,oGAAoG;EAC/G,GAAG,OAAO,CAAC;EACX,MAAM;GACI,MAAM;AAEX,IAAM,YAA+B;AAE5C,IAAM,eAA+B,MACnC,oBAAoB,OAAO;EACzB,GAAG;EACH,GAAG;EACH,GAAG,MAAM,OAAO,OAAO,KAAK,CAAC;CAC9B,GAAE;AAGE,IAAM,eAA+C,MAC1D,aAAa,UAAU,iBAAiB,CAAC,YAAsB,YAAY,QAAQ,CAAC,CAAC,GAAG;EACtF,KAAK;EACL,WAAW;EACX,GAAG,MAAM;EACT,GAAG;EACH,GAAG;EACH,QAAQ;EACR,MAAM;CACP,GAAE;AAGL,IAAM,QAAQ,MACZ,OACE,uIAAuI,CACxI;AAGH,IAAM,SAAS,MAAM,OAAO,OAAO,IAAI,CAAC;AACxC,IAAM,SAAS,OACb,wIAAwI;AAQnI,IAAM,OAA0B,YAAY;EACjD,GAAG;EACH,GAAG;EACH,IAAI;EACJ,GAAG,OACD,wIAAwI;EAE1I,IAAI,OACF,wIAAwI;EAE1I,IAAI,OACF,wIAAwI;EAE1I,GAAG,OAAO,CAAC;EACX,MAAM;EACN,0BAA0B,CAAC,KAAK,KAAK,GAAG;;GAC9B,MAAM;AAEX,IAAM,YAA+B;AAE5C,IAAM,eAA+B,MACnC,oBAAoB,OAAO;EACzB,GAAG;EACH,GAAG;EACH,GAAG,MAAM,OAAO,OAAO,IAAI,CAAC;CAC7B,GAAE;AAGE,IAAM,eAA+C,MAC1D,aAAa,UAAU,iBAAiB,CAAC,YAAsB,YAAY,QAAQ,CAAC,CAAC,GAAG;EACtF,KAAK;EACL,WAAW;EACX,GAAG,MAAM;EACT,GAAG;EACH,GAAG;EACH,QAAQ;EACR,MAAM;CACP,GAAE;;;ACnJE,IAAMA,QAAqB;AAC3B,IAAMC,aAA0B;AAChC,IAAM,eAAkD,MAAM,YAAY,aAAY;AACtF,IAAM,iBAAoD,MAAM,YAAY,eAAc;;;ACVjG;;;;;;;;;;;AASO,IAAM,QAAQC;AAef,SAAU,cACd,UAAqC,CAAA,GAAE;AAEvC,QAAM,EAAE,KAAK,MAAK,IAAK;AACvB,QAAM,aAAa,iBAAiB,EAAE,GAAE,CAAE;AAC1C,QAAM,YAAY,aAAa,EAAE,WAAU,CAAE;AAE7C,SAAO;IACL;IACA;;AAEJ;AAqCM,SAAU,aACd,SAA6B;AAE7B,QAAM,EAAE,WAAU,IAAK;AACvB,QAAM,QAAQA,WAAU,gBAAgB,eACtC,OAAO,eAAe,WAClB,WAAW,MAAM,CAAC,IACd,UAAU,UAAU,EAAE,MAAM,CAAC,CAAC;AAExC,SAAiBC,MAAK,KAAK;AAC7B;AAgCM,SAAU,gBACd,SAAoC;AAEpC,QAAM,EAAE,KAAK,OAAO,YAAY,UAAS,IAAK;AAC9C,QAAM,QAAQD,WAAU,gBAAgB,QAC5B,MAAM,SAAS,EAAE,MAAM,CAAC,CAAC;AAErC,QAAM,gBACJ,OAAO,eAAe,WAClB,WAAW,MAAM,CAAC,IACd,UAAU,UAAU,EAAE,MAAM,CAAC;AACvC,QAAM,cAAc,MAAM,SACxBA,WAAU,MAAM,uBAAuB,aAAa,CAAC;AAEvD,QAAM,eAAe,YAAY,WAAW,IAAI;AAChD,MAAI,OAAO;AAAO,WAAW,UAAU,YAAY;AACnD,SAAO;AACT;AA0CM,SAAU,iBACd,UAAwC,CAAA,GAAE;AAE1C,QAAM,EAAE,KAAK,MAAK,IAAK;AACvB,QAAM,QAAQA,WAAU,MAAM,iBAAgB;AAC9C,MAAI,OAAO;AAAO,WAAW,UAAU,KAAK;AAC5C,SAAO;AACT;AAoCM,SAAU,iBACd,SAAiC;AAEjC,QAAM,EAAE,SAAS,UAAS,IAAK;AAC/B,QAAM,EAAE,GAAG,GAAG,QAAO,IAAK;AAC1B,QAAM,aAAa,IAAIA,WAAU,UAC/B,OAAO,CAAC,GACR,OAAO,CAAC,CAAC,EACT,eAAe,OAAO;AACxB,QAAM,WACJ,mBAAmB,aAAiB,UAAU,OAAO,IAAI;AAC3D,QAAM,QAAQ,WAAW,iBAAiB,SAAS,UAAU,CAAC,CAAC;AAC/D,SAAiBC,MAAK,KAAK;AAC7B;AAgCM,SAAU,KAAK,SAAqB;AACxC,QAAM,EACJ,cAAAC,gBAAuB,cACvB,MACA,SACA,WAAU,IACR;AACJ,QAAM,EAAE,GAAG,GAAG,SAAQ,IAAKF,WAAU,KACnC,mBAAmB,aAAa,UAAgB,QAAQ,OAAO,GAC/D,sBAAsB,aAAa,aAAmB,QAAQ,UAAU,GACxE;IACE,cACE,OAAOE,kBAAiB,YACpBA,gBACI,KAAKA,aAAY,EAAE,MAAM,CAAC;IACpC,MAAM;IACN,GAAI,OAAO,EAAE,SAAS,KAAI,IAAK,CAAA;GAChC;AAEH,SAAO;IACL;IACA;IACA,SAAS;;AAEb;AA+CM,SAAU,OAAO,SAAuB;AAC5C,QAAM,EAAE,MAAM,SAAS,WAAW,UAAS,IAAK;AAChD,SAAOF,WAAU,OACf,WACA,mBAAmB,aAAa,UAAgB,QAAQ,OAAO,GACrD,MAAM,SAAS,EAAE,UAAU,CAAC,GACtC,GAAI,OAAO,CAAC,EAAE,SAAS,MAAM,MAAM,KAAI,CAAE,IAAI,CAAA,CAAG;AAEpD;;;ACpVA;;;;;;;;;;;;cAAAG;EAAA,cAAAC;;;;ACAA;;mBAAAC;EAAA,eAAAC;EAAA,kBAAAC;EAAA,eAAAC;EAAA,aAAAC;EAAA,gBAAAC;;AAIA,IAAM,UAAwB,IAAI,YAAW;AAC7C,IAAM,UAAwB,IAAI,YAAW;AAE7C,IAAM,qBAAmC,OAAO,YAC9C,MAAM,KACJ,kEAAkE,EAClE,IAAI,CAAC,GAAG,MAAM,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC,CAAC,CAAC;AAGvC,IAAM,qBAAqB;EACzB,GAAG,OAAO,YACR,MAAM,KACJ,kEAAkE,EAClE,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;EAEvC,CAAC,IAAI,WAAW,CAAC,CAAC,GAAG;EACrB,CAAC,IAAI,WAAW,CAAC,CAAC,GAAG;EACrB,CAAC,IAAI,WAAW,CAAC,CAAC,GAAG;;AAyCjB,SAAUC,WAAU,OAAoB,UAA6B,CAAA,GAAE;AAC3E,QAAM,EAAE,MAAM,MAAM,MAAM,MAAK,IAAK;AAEpC,QAAM,UAAU,IAAI,WAAW,KAAK,KAAK,MAAM,SAAS,CAAC,IAAI,CAAC;AAE9D,WAAS,IAAI,GAAG,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,GAAG,KAAK,GAAG;AACvD,UAAM,KAAK,MAAM,CAAC,KAAM,OAAO,MAAM,IAAI,CAAC,KAAM,MAAM,MAAM,IAAI,CAAC,IAAK;AACtE,YAAQ,CAAC,IAAI,mBAAmB,KAAK,EAAE;AACvC,YAAQ,IAAI,CAAC,IAAI,mBAAoB,KAAK,KAAM,EAAI;AACpD,YAAQ,IAAI,CAAC,IAAI,mBAAoB,KAAK,IAAK,EAAI;AACnD,YAAQ,IAAI,CAAC,IAAI,mBAAmB,IAAI,EAAI;EAC9C;AAEA,QAAM,IAAI,MAAM,SAAS;AACzB,QAAM,MAAM,KAAK,MAAM,MAAM,SAAS,CAAC,IAAI,KAAK,KAAK,IAAI;AACzD,MAAI,SAAS,QAAQ,OAAO,IAAI,WAAW,QAAQ,QAAQ,GAAG,GAAG,CAAC;AAClE,MAAI,OAAO,MAAM;AAAG,cAAU;AAC9B,MAAI,OAAO,MAAM;AAAG,cAAU;AAC9B,MAAI;AAAK,aAAS,OAAO,WAAW,KAAK,GAAG,EAAE,WAAW,KAAK,GAAG;AACjE,SAAO;AACT;AA2DM,SAAUC,SAAQ,OAAgB,UAA2B,CAAA,GAAE;AACnE,SAAOD,WAAgB,QAAQ,KAAK,GAAG,OAAO;AAChD;AA2DM,SAAUE,YAAW,OAAe,UAA8B,CAAA,GAAE;AACxE,SAAOF,WAAgB,WAAW,KAAK,GAAG,OAAO;AACnD;AAmCM,SAAUG,SAAQ,OAAa;AACnC,QAAM,SAAS,MAAM,QAAQ,OAAO,EAAE;AAEtC,QAAM,OAAO,OAAO;AAEpB,QAAM,UAAU,IAAI,WAAW,OAAO,CAAC;AACvC,UAAQ,WAAW,SAAS,OAAO,OAAO;AAE1C,WAAS,IAAI,GAAG,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GAAG,KAAK,GAAG;AACxD,UAAM,KACH,mBAAmB,QAAQ,CAAC,CAAE,KAAM,OACpC,mBAAmB,QAAQ,IAAI,CAAC,CAAE,KAAM,OACxC,mBAAmB,QAAQ,IAAI,CAAC,CAAE,KAAM,KACzC,mBAAmB,QAAQ,IAAI,CAAC,CAAE;AACpC,YAAQ,CAAC,IAAI,KAAK;AAClB,YAAQ,IAAI,CAAC,IAAK,KAAK,IAAK;AAC5B,YAAQ,IAAI,CAAC,IAAI,IAAI;EACvB;AAEA,QAAM,eAAe,QAAQ,KAAK,KAAK,OAAO,KAAM,OAAO,IAAK;AAChE,SAAO,IAAI,WAAW,QAAQ,QAAQ,GAAG,WAAW;AACtD;AAoBM,SAAUC,OAAM,OAAa;AACjC,SAAW,UAAUD,SAAQ,KAAK,CAAC;AACrC;AAoBM,SAAUE,UAAS,OAAa;AACpC,SAAa,SAASF,SAAQ,KAAK,CAAC;AACtC;;;AChTA;;;;;;;;;;;;;;;;;;AA0BM,SAAU,OACd,MACA,UAA8B,CAAA,GAAE;AAEhC,QAAM,EAAE,KAAK,MAAK,IAAK;AAEvB,QAAM,YAAY,aAAa,IAAI;AACnC,QAAM,SAAgB,OAAO,IAAI,WAAW,UAAU,MAAM,CAAC;AAC7D,YAAU,OAAO,MAAM;AAEvB,MAAI,OAAO;AAAO,WAAW,UAAU,OAAO,KAAK;AACnD,SAAO,OAAO;AAChB;AA8CM,SAAU,OAAuB,MAA2B;AAChE,QAAM,SAAS,MAAK;AAClB,QAAI,OAAO,SAAS,UAAU;AAC5B,UAAI,KAAK,SAAS,KAAK,KAAK,SAAS,MAAM;AACzC,cAAM,IAAQ,mBAAmB,IAAI;AACvC,aAAa,QAAQ,IAAI;IAC3B;AACA,WAAO;EACT,GAAE;AAEF,QAAM,SAAgB,OAAO,KAAK;AAElC,SAAO,aAAa,MAAM;AAC5B;AAWM,IAAO,wBAAP,cAA4C,UAAS;EAGzD,YAAY,EAAE,UAAS,GAAyB;AAC9C,UAAM,4BAA4B,SAAS,EAAE;AAH7B,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAIzB;;AAGI,IAAO,6BAAP,cAAiD,UAAS;EAG9D,YAAY,EAAE,eAAc,GAA8B;AACxD,UAAM,iCAAiC,cAAc,EAAE;AAHvC,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAIzB;;AAGI,IAAO,+BAAP,cAAmD,UAAS;EAGhE,cAAA;AACE,UAAM,qDAAqD;AAH3C,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAIzB;;AAGI,IAAO,sBAAP,cAA0C,UAAS;EAGvD,YAAY,EAAE,IAAG,GAAmB;AAClC,UAAM,yBAAyB,GAAG,yBAAyB;AAH3C,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAIzB;;AAGI,IAAO,oCAAP,cAAwD,UAAS;EAGrE,YAAY,EAAE,KAAI,GAAoB;AACpC,UAAM,2CAA2C,IAAI,EAAE;AAHvC,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAIzB;;AAGI,IAAO,0BAAP,cAA8C,UAAS;EAG3D,YAAY,EAAE,MAAK,GAAqB;AACtC,UAAM,8BAA8B,KAAK,EAAE;AAH3B,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAIzB;;AAGI,IAAO,yBAAP,cAA6C,UAAS;EAG1D,cAAA;AACE,UAAM,mDAAmD;AAHzC,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAIzB;;AAGI,IAAO,uBAAP,cAA2C,UAAS;EAGxD,YAAY,EAAE,MAAK,GAAqB;AACtC,UAAM,qBAAqB,KAAK,EAAE;AAHlB,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAIzB;;AAGI,IAAO,sBAAP,cAA0C,UAAS;EAGvD,YAAY,EAAE,OAAM,GAAsB;AACxC,UACE,wCAAwC,OAAO,gBAAgB,MAAM,MAAM,EAAE;AAJ/D,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAMzB;;AAGI,IAAO,sBAAP,cAA0C,UAAS;EAGvD,YAAY,EAAE,KAAI,GAAoB;AACpC,UAAM,+CAA+C,IAAI,EAAE;AAH3C,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAIzB;;AAGI,IAAO,qBAAP,cAAyC,UAAS;EAGtD,YAAY,EAAE,KAAI,GAAoB;AACpC,UAAM,8CAA8C,IAAI,EAAE;AAH1C,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAIzB;;AAGI,IAAO,sBAAP,cAA0C,UAAS;EAGvD,YAAY,EAAE,KAAI,GAAoB;AACpC,UAAM,6CAA6C,IAAI,EAAE;AAHzC,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAIzB;;AAGI,IAAO,0BAAP,cAA8C,UAAS;EAG3D,YAAY,EAAE,KAAI,GAAoB;AACpC,UAAM,oDAAoD,IAAI,EAAE;AAHhD,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAIzB;;AAcF,SAAS,aAAa,OAAc;AAClC,MAAI,OAAO,UAAU;AACnB,WAAO,EAAE,QAAQ,GAAG,QAAQ,CAAC,WAAW,OAAO,UAAU,GAAI,EAAC;AAEhE,MAAI,UAAU;AACZ,WAAO,EAAE,QAAQ,GAAG,QAAQ,CAAC,WAAW,OAAO,UAAU,GAAI,EAAC;AAEhE,MAAI,OAAO,UAAU;AACnB,WAAO;MACL,QAAQ;MACR,QAAQ,CAAC,WAAW,OAAO,UAAU,QAAQ,MAAO,GAAI;;AAG5D,MAAI,OAAO,UAAU;AAAU,WAAO,aAAa,OAAO,KAAe;AAEzE,MAAI,OAAO,UAAU;AAAU,UAAM,IAAI,uBAAsB;AAE/D,MAAI,OAAO,UAAU;AAAU,WAAO,aAAa,OAAO,KAAe;AAEzE,MAAI,MAAM,QAAQ,KAAK;AAAG,WAAO,aAAa,MAAM,KAAK;AAEzD,MAAI,iBAAiB;AAAY,WAAO,aAAa,WAAW,KAAK;AAErE,MAAI,iBAAiB;AACnB,WAAO,aAAa,WAAW,IAAI,WAAW,KAAK,CAAC;AAEtD,MAAI,YAAY,OAAO,KAAK;AAC1B,WAAO,aAAa,WAClB,IAAI,WAAW,MAAM,QAAQ,MAAM,YAAY,MAAM,UAAU,CAAC;AAGpE,MAAI,iBAAiB;AACnB,WAAO,aAAa,IAAI,KAA8B;AAExD,MAAI,OAAO,UAAU;AACnB,WAAO,aAAa,OAAO,KAAgC;AAE7D,QAAM,IAAI,qBAAqB,EAAE,OAAO,OAAO,KAAK,EAAC,CAAE;AACzD;CAGA,SAAUG,eAAY;AAEpB,WAAgB,OAAO,OAAa;AAElC,QAAI,CAAC,OAAO,cAAc,KAAK,GAAG;AAGhC,YAAM,UAAU,KAAK,OAAO,KAAK;AACjC,UAAI,OAAO,MAAM,KAAK,KAAK,UAAU;AACnC,eAAO;UACL,QAAQ;;UACR,OAAO,QAAM;AACX,mBAAO,UAAU,GAAI;AACrB,mBAAO,SAAS,WAAW,OAAO,UAAU,OAAO,KAAK;AACxD,mBAAO,YAAY;UACrB;;AAEJ,aAAO;QACL,QAAQ;;QACR,OAAO,QAAM;AACX,iBAAO,UAAU,GAAI;AACrB,iBAAO,SAAS,WAAW,OAAO,UAAU,OAAO,KAAK;AACxD,iBAAO,YAAY;QACrB;;IAEJ;AAGA,QAAI,SAAS,GAAG;AACd,UAAI,SAAS;AACX,eAAO,EAAE,QAAQ,GAAG,QAAQ,CAAC,WAAW,OAAO,UAAU,KAAK,EAAC;AACjE,UAAI,SAAS;AACX,eAAO;UACL,QAAQ;;UACR,QAAQ,CAAC,WAAU;AACjB,mBAAO,UAAU,EAAI;AACrB,mBAAO,UAAU,KAAK;UACxB;;AAEJ,UAAI,SAAS;AACX,eAAO;UACL,QAAQ;;UACR,QAAQ,CAAC,WAAU;AACjB,mBAAO,UAAU,EAAI;AACrB,mBAAO,WAAW,KAAK;UACzB;;AAEJ,UAAI,SAAS;AACX,eAAO;UACL,QAAQ;;UACR,QAAQ,CAAC,WAAU;AACjB,mBAAO,UAAU,EAAI;AACrB,mBAAO,WAAW,KAAK;UACzB;;AAEJ,YAAM,IAAI,oBAAoB,EAAE,QAAQ,MAAM,SAAS,EAAE,EAAC,CAAE;IAC9D;AAIA,UAAM,iBAAiB,KAAK;AAE5B,QAAI,SAAS;AACX,aAAO;QACL,QAAQ;QACR,QAAQ,CAAC,WAAW,OAAO,UAAU,KAAO,cAAc;;AAE9D,QAAI,kBAAkB;AACpB,aAAO;QACL,QAAQ;;QACR,QAAQ,CAAC,WAAU;AACjB,iBAAO,UAAU,EAAI;AACrB,iBAAO,UAAU,cAAc;QACjC;;AAEJ,QAAI,kBAAkB;AACpB,aAAO;QACL,QAAQ;;QACR,QAAQ,CAAC,WAAU;AACjB,iBAAO,UAAU,EAAI;AACrB,iBAAO,WAAW,cAAc;QAClC;;AAEJ,QAAI,kBAAkB;AACpB,aAAO;QACL,QAAQ;;QACR,QAAQ,CAAC,WAAU;AACjB,iBAAO,UAAU,EAAI;AACrB,iBAAO,WAAW,cAAc;QAClC;;AAEJ,UAAM,IAAI,oBAAoB,EAAE,QAAQ,MAAM,SAAS,EAAE,EAAC,CAAE;EAC9D;AA1FgB,EAAAA,cAAA,SAAM;AA6FtB,WAAgB,OAAO,OAAa;AAClC,UAAM,UAAgB,WAAW,KAAK;AACtC,UAAM,OAAO,QAAQ;AAErB,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,KAAO,IAAI;AAC5B,cAAI,OAAO;AAAG,mBAAO,UAAU,OAAO;QACxC;;AAEJ,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,GAAI;AACrB,iBAAO,UAAU,IAAI;AACrB,iBAAO,UAAU,OAAO;QAC1B;;AAGJ,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,GAAI;AACrB,iBAAO,WAAW,IAAI;AACtB,iBAAO,UAAU,OAAO;QAC1B;;AAGJ,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,GAAI;AACrB,iBAAO,WAAW,IAAI;AACtB,iBAAO,UAAU,OAAO;QAC1B;;AAGJ,UAAM,IAAI,oBAAoB,EAAE,KAAI,CAAE;EACxC;AA3CgB,EAAAA,cAAA,SAAM;AA8CtB,WAAgB,MAAM,OAAgB;AACpC,UAAM,QAAQ,MAAM,IAAI,CAAC,SAASA,cAAa,IAAI,CAAC;AACpD,UAAM,aAAa,MAAM,OAAO,CAAC,KAAK,SAAS,MAAM,KAAK,QAAQ,CAAC;AACnE,UAAM,OAAO,MAAM;AAEnB,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,MAAO,IAAI;AAC5B,qBAAW,QAAQ;AAAO,iBAAK,OAAO,MAAM;QAC9C;;AAEJ,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,GAAI;AACrB,iBAAO,UAAU,IAAI;AACrB,qBAAW,QAAQ;AAAO,iBAAK,OAAO,MAAM;QAC9C;;AAEJ,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,GAAI;AACrB,iBAAO,WAAW,IAAI;AACtB,qBAAW,QAAQ;AAAO,iBAAK,OAAO,MAAM;QAC9C;;AAEJ,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,GAAI;AACrB,iBAAO,WAAW,IAAI;AACtB,qBAAW,QAAQ;AAAO,iBAAK,OAAO,MAAM;QAC9C;;AAEJ,UAAM,IAAI,mBAAmB,EAAE,KAAI,CAAE;EACvC;AAzCgB,EAAAA,cAAA,QAAK;AA4CrB,WAAgB,WAAW,OAAiB;AAC1C,UAAM,OAAO,MAAM;AAEnB,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,KAAO,IAAI;AAC5B,iBAAO,UAAU,KAAK;QACxB;;AAEJ,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,EAAI;AACrB,iBAAO,UAAU,IAAI;AACrB,iBAAO,UAAU,KAAK;QACxB;;AAEJ,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,EAAI;AACrB,iBAAO,WAAW,IAAI;AACtB,iBAAO,UAAU,KAAK;QACxB;;AAEJ,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,EAAI;AACrB,iBAAO,WAAW,IAAI;AACtB,iBAAO,UAAU,KAAK;QACxB;;AAEJ,UAAM,IAAI,wBAAwB,EAAE,KAAI,CAAE;EAC5C;AAvCgB,EAAAA,cAAA,aAAU;AA0C1B,WAAgB,OAAO,OAA8B;AACnD,UAAM,OAAO,OAAO,KAAK,KAAK;AAC9B,UAAM,UAAU,KAAK,IAAI,CAAC,SAAS;MACjC,KAAKA,cAAa,GAAG;MACrB,OAAOA,cAAa,MAAM,GAAG,CAAC;MAC9B;AACF,UAAM,aAAa,QAAQ,OACzB,CAAC,KAAK,UAAU,MAAM,MAAM,IAAI,SAAS,MAAM,MAAM,QACrD,CAAC;AAEH,UAAM,OAAO,KAAK;AAElB,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,MAAO,IAAI;AAC5B,qBAAW,SAAS,SAAS;AAC3B,kBAAM,IAAI,OAAO,MAAM;AACvB,kBAAM,MAAM,OAAO,MAAM;UAC3B;QACF;;AAEJ,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,GAAI;AACrB,iBAAO,UAAU,IAAI;AACrB,qBAAW,SAAS,SAAS;AAC3B,kBAAM,IAAI,OAAO,MAAM;AACvB,kBAAM,MAAM,OAAO,MAAM;UAC3B;QACF;;AAEJ,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,GAAI;AACrB,iBAAO,WAAW,IAAI;AACtB,qBAAW,SAAS,SAAS;AAC3B,kBAAM,IAAI,OAAO,MAAM;AACvB,kBAAM,MAAM,OAAO,MAAM;UAC3B;QACF;;AAEJ,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,GAAI;AACrB,iBAAO,WAAW,IAAI;AACtB,qBAAW,SAAS,SAAS;AAC3B,kBAAM,IAAI,OAAO,MAAM;AACvB,kBAAM,MAAM,OAAO,MAAM;UAC3B;QACF;;AAEJ,UAAM,IAAI,oBAAoB,EAAE,KAAI,CAAE;EACxC;AA5DgB,EAAAA,cAAA,SAAM;AA+DtB,WAAgB,IAAI,OAA4B;AAC9C,UAAM,UAAkD,CAAA;AACxD,eAAW,CAAC,GAAG,CAAC,KAAK;AACnB,cAAQ,KAAK,EAAE,KAAKA,cAAa,CAAC,GAAG,OAAOA,cAAa,CAAC,EAAC,CAAE;AAC/D,UAAM,aAAa,QAAQ,OACzB,CAAC,KAAK,UAAU,MAAM,MAAM,IAAI,SAAS,MAAM,MAAM,QACrD,CAAC;AAEH,UAAM,OAAO,MAAM;AAEnB,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,MAAO,IAAI;AAC5B,qBAAW,SAAS,SAAS;AAC3B,kBAAM,IAAI,OAAO,MAAM;AACvB,kBAAM,MAAM,OAAO,MAAM;UAC3B;QACF;;AAEJ,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,GAAI;AACrB,iBAAO,UAAU,IAAI;AACrB,qBAAW,SAAS,SAAS;AAC3B,kBAAM,IAAI,OAAO,MAAM;AACvB,kBAAM,MAAM,OAAO,MAAM;UAC3B;QACF;;AAEJ,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,GAAI;AACrB,iBAAO,WAAW,IAAI;AACtB,qBAAW,SAAS,SAAS;AAC3B,kBAAM,IAAI,OAAO,MAAM;AACvB,kBAAM,MAAM,OAAO,MAAM;UAC3B;QACF;;AAEJ,QAAI,QAAQ;AACV,aAAO;QACL,QAAQ,IAAI;QACZ,OAAO,QAAM;AACX,iBAAO,UAAU,GAAI;AACrB,iBAAO,WAAW,IAAI;AACtB,qBAAW,SAAS,SAAS;AAC3B,kBAAM,IAAI,OAAO,MAAM;AACvB,kBAAM,MAAM,OAAO,MAAM;UAC3B;QACF;;AAEJ,UAAM,IAAI,oBAAoB,EAAE,KAAI,CAAE;EACxC;AA1DgB,EAAAA,cAAA,MAAG;AA2DrB,GA7VU,iBAAA,eAAY,CAAA,EAAA;AAiWtB,SAAS,aAAa,QAAqB;AACzC,QAAM,cAAc,OAAO,UAAS;AACpC,QAAM,YAAY,eAAe;AACjC,QAAM,iBAAiB,cAAc;AAErC,UAAQ,WAAW;IAEjB,KAAK;AACH,aAAO,aAAa,oBAAoB,QAAQ,cAAc;IAGhE,KAAK;AACH,aAAO,aAAa,oBAAoB,QAAQ,cAAc;IAGhE,KAAK;AACH,aAAO,aAAa,eAAe,QAAQ,cAAc;IAG3D,KAAK;AACH,aAAO,aAAa,eAAe,QAAQ,cAAc;IAG3D,KAAK;AACH,aAAO,aAAa,UAAU,QAAQ,cAAc;IAGtD,KAAK;AACH,aAAO,aAAa,QAAQ,QAAQ,cAAc;IAGpD,KAAK;AACH,YAAM,IAAI,oBAAoB,EAAE,KAAK,eAAc,CAAE;IAGvD,KAAK;AACH,aAAO,aAAa,kBAAkB,QAAQ,cAAc;IAE9D;AACE,YAAM,IAAI,sBAAsB,EAAE,UAAS,CAAE;EACjD;AACF;CAGA,SAAUC,eAAY;AAepB,WAAS,WAAW,QAAuB,gBAAsB;AAC/D,QAAI,iBAAiB;AAAI,aAAO;AAChC,QAAI,mBAAmB;AAAI,aAAO,OAAO,UAAS;AAClD,QAAI,mBAAmB;AAAI,aAAO,OAAO,WAAU;AACnD,QAAI,mBAAmB;AAAI,aAAO,OAAO,WAAU;AACnD,QAAI,mBAAmB;AAAI,YAAM,IAAI,6BAA4B;AACjE,UAAM,IAAI,2BAA2B,EAAE,eAAc,CAAE;EACzD;AAWA,WAAgB,oBACd,QACA,gBAAsB;AAEtB,WAAO,WAAW,QAAQ,cAAc;EAC1C;AALgB,EAAAA,cAAA,sBAAmB;AAanC,WAAgB,oBACd,QACA,gBAAsB;AAEtB,UAAM,QAAQ,WAAW,QAAQ,cAAc;AAC/C,WAAO,KAAK;EACd;AANgB,EAAAA,cAAA,sBAAmB;AAcnC,WAAgB,eACd,QACA,gBAAsB;AAGtB,QAAI,mBAAmB,IAAI;AACzB,YAAM,SAAwB,CAAA;AAC9B,UAAI,cAAc;AAElB,aAAO,MAAM;AACX,cAAM,OAAO,OAAO,aAAY;AAChC,YAAI,SAAS,KAAM;AACjB,iBAAO,UAAS;AAChB;QACF;AACA,cAAM,QAAQA,cAAa,MAAM;AACjC,YAAI,EAAE,iBAAiB;AACrB,gBAAM,IAAI,kCAAkC,EAAE,MAAM,cAAa,CAAE;AACrE,eAAO,KAAK,KAAK;AACjB,uBAAe,MAAM;MACvB;AAGA,YAAM,SAAS,IAAI,WAAW,WAAW;AACzC,UAAI,SAAS;AACb,iBAAW,SAAS,QAAQ;AAC1B,eAAO,IAAI,OAAO,MAAM;AACxB,kBAAU,MAAM;MAClB;AACA,aAAO;IACT;AAEA,UAAM,SAAS,WAAW,QAAQ,cAAc;AAChD,WAAO,OAAO,UAAU,MAAM;EAChC;AAlCgB,EAAAA,cAAA,iBAAc;AA6C9B,WAAgB,eACd,QACA,gBAAsB;AAGtB,QAAI,mBAAmB,IAAI;AACzB,YAAM,SAAmB,CAAA;AAEzB,aAAO,MAAM;AACX,cAAM,OAAO,OAAO,aAAY;AAChC,YAAI,SAAS,KAAM;AACjB,iBAAO,UAAS;AAChB;QACF;AACA,cAAM,QAAQA,cAAa,MAAM;AACjC,YAAI,OAAO,UAAU;AACnB,gBAAM,IAAI,kCAAkC,EAAE,MAAM,cAAa,CAAE;AACrE,eAAO,KAAK,KAAK;MACnB;AAEA,aAAO,OAAO,KAAK,EAAE;IACvB;AAEA,UAAM,SAAS,WAAW,QAAQ,cAAc;AAChD,UAAM,QAAQ,OAAO,UAAU,MAAM;AACrC,WAAa,SAAS,KAAK;EAC7B;AA1BgB,EAAAA,cAAA,iBAAc;AAsC9B,WAAgB,UACd,QACA,gBAAsB;AAGtB,QAAI,mBAAmB,IAAI;AACzB,YAAMC,UAAoB,CAAA;AAE1B,aAAO,MAAM;AACX,cAAM,OAAO,OAAO,aAAY;AAChC,YAAI,SAAS,KAAM;AACjB,iBAAO,UAAS;AAChB;QACF;AACA,QAAAA,QAAO,KAAKD,cAAa,MAAM,CAAC;MAClC;AAEA,aAAOC;IACT;AAEA,UAAM,SAAS,WAAW,QAAQ,cAAc;AAChD,UAAM,SAAoB,CAAA;AAE1B,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,aAAO,KAAKD,cAAa,MAAM,CAAC;IAClC;AAEA,WAAO;EACT;AA5BgB,EAAAA,cAAA,YAAS;AAoCzB,WAAgB,QACd,QACA,gBAAsB;AAGtB,QAAI,mBAAmB,IAAI;AACzB,YAAMC,UAAkC,CAAA;AAExC,aAAO,MAAM;AACX,cAAM,OAAO,OAAO,aAAY;AAChC,YAAI,SAAS,KAAM;AACjB,iBAAO,UAAS;AAChB;QACF;AACA,cAAM,MAAMD,cAAa,MAAM;AAE/B,cAAM,SACJ,OAAO,QAAQ,WACX,MACA,OAAO,QAAQ,WACb,OAAO,GAAG,IACV,OAAO,GAAG;AAClB,cAAM,QAAQA,cAAa,MAAM;AACjC,QAAAC,QAAO,MAAM,IAAI;MACnB;AAEA,aAAOA;IACT;AAEA,UAAM,SAAS,WAAW,QAAQ,cAAc;AAChD,UAAM,SAAkC,CAAA;AAExC,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,YAAM,MAAMD,cAAa,MAAM;AAE/B,YAAM,SACJ,OAAO,QAAQ,WACX,MACA,OAAO,QAAQ,WACb,OAAO,GAAG,IACV,OAAO,GAAG;AAClB,YAAM,QAAQA,cAAa,MAAM;AACjC,aAAO,MAAM,IAAI;IACnB;AAEA,WAAO;EACT;AA9CgB,EAAAA,cAAA,UAAO;AAsDvB,WAAgB,kBACd,QACA,gBAAsB;AAGtB,QAAI,mBAAmB;AAAI,aAAO;AAClC,QAAI,mBAAmB;AAAI,aAAO;AAClC,QAAI,mBAAmB;AAAI,aAAO;AAClC,QAAI,mBAAmB;AAAI,aAAO;AAGlC,QAAI,mBAAmB,IAAI;AACzB,YAAM,OAAO,OAAO,WAAU;AAC9B,aAAO,WAAW,IAAI;IACxB;AAGA,QAAI,mBAAmB,IAAI;AACzB,YAAM,QAAQ,OAAO,SAAS,WAAW,OAAO,UAAU,KAAK;AAC/D,aAAO,YAAY;AACnB,aAAO;IACT;AAGA,QAAI,mBAAmB,IAAI;AACzB,YAAM,QAAQ,OAAO,SAAS,WAAW,OAAO,UAAU,KAAK;AAC/D,aAAO,YAAY;AACnB,aAAO;IACT;AAGA,QAAI,mBAAmB,IAAI;AACzB,YAAM,cAAc,OAAO,UAAS;AAGpC,UAAI,cAAc;AAChB,cAAM,IAAI,wBAAwB,EAAE,OAAO,YAAW,CAAE;AAE1D,aAAO;IACT;AAEA,UAAM,IAAI,2BAA2B,EAAE,eAAc,CAAE;EACzD;AA1CgB,EAAAA,cAAA,oBAAiB;AAqDjC,WAAS,WAAW,MAAY;AAG9B,UAAME,QAAQ,QAAQ,KAAM;AAC5B,UAAM,WAAY,QAAQ,KAAM;AAChC,UAAM,WAAW,OAAO;AAGxB,QAAI,aAAa,GAAG;AAElB,UAAI,aAAa;AAAG,eAAOA,QAAO,KAAK;AAEvC,YAAMC,SAAQ,KAAK,OAAO,WAAW;AACrC,aAAOD,QAAO,CAACC,SAAQA;IACzB;AAEA,QAAI,aAAa,IAAM;AAErB,UAAI,aAAa;AAAG,eAAOD,QAAO,YAAY;AAC9C,aAAO;IACT;AAGA,UAAM,QAAQ,MAAM,WAAW,OAAO,IAAI,WAAW;AACrD,WAAOA,QAAO,CAAC,QAAQ;EACzB;AACF,GAxTU,iBAAA,eAAY,CAAA,EAAA;;;ACvpBtB;;;;;;AA2BM,SAAU,cAAc,WAA8B;AAC1D,QAAM,UAAoBE,SAAQ,SAAS;AAC3C,QAAM,IAAI,QAAQ,MAAM,GAAG,EAAE;AAC7B,QAAM,IAAI,QAAQ,MAAM,IAAI,EAAE;AAC9B,SAAY,OACV,oBAAI,IAAqB;IACvB,CAAC,GAAG,CAAC;;IACL,CAAC,GAAG,EAAE;;IACN,CAAC,IAAI,CAAC;;IACN,CAAC,IAAI,CAAC;;IACN,CAAC,IAAI,CAAC;;GACP,CAAC;AAEN;AAyBM,SAAU,YAAY,SAAgB;AAC1C,QAAM,UAAe,OAAgC,OAAO;AAE5D,QAAM,IAAI,QAAQ,IAAI;AACtB,QAAM,IAAI,QAAQ,IAAI;AAEtB,MAAI,EAAE,aAAa,eAAe,EAAE,aAAa;AAC/C,UAAM,IAAI,oBAAmB;AAE/B,SAAiBC,MAAK,IAAI,WAAW,CAAC,GAAM,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC;AAC1D;AAWM,IAAO,sBAAP,cAA0C,UAAS;EAGvD,cAAA;AACE,UAAM,8DAA8D;AAHpD,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAIzB;;;;ACqEI,SAAU,mBAAmB,OAAiB;AAClD,QAAM,UAAU,MAAM,CAAC,MAAM,IAAI,IAAI;AACrC,QAAM,QAAQ,UAAU;AACxB,QAAM,UAAU,MAAM,QAAQ,CAAC,MAAM,IAAI,QAAQ,IAAI,QAAQ;AAE7D,QAAM,IAAI,OAAW,UAAU,MAAM,MAAM,SAAS,KAAK,CAAC,CAAC;AAC3D,QAAM,IAAI,OAAW,UAAU,MAAM,MAAM,OAAO,CAAC,CAAC;AAEpD,SAAO;IACL;IACA,GAAG,IAAIC,MAAK,MAAM,IAAI,KAAKA,MAAK,MAAM,IAAI,IAAI;;AAElD;AAQA,eAAsB,yBACpB,UAA0C;AAE1C,MAAI;AACF,UAAM,kBAAkB,SAAS,aAAY;AAC7C,QAAI,CAAC;AAAiB,YAAM,IAAI,8BAA6B;AAG7D,UAAM,iBAAiB,IAAI,WAAW,eAAe;AACrD,UAAM,YAAY,MAAM,OAAO,OAAO,UACpC,QACA,IAAI,WAAW,cAAc,GAC7B;MACE,MAAM;MACN,YAAY;MACZ,MAAM;OAER,MACA,CAAC,QAAQ,CAAC;AAEZ,UAAM,YAAY,IAAI,WACpB,MAAM,OAAO,OAAO,UAAU,OAAO,SAAS,CAAC;AAEjD,WAAiBC,MAAK,SAAS;EACjC,SAAS,OAAO;AAId,QAAK,MAAgB,YAAY;AAC/B,YAAM;AAER,UAAM,OAAO,IAAI,WAAW,SAAS,iBAAiB;AACtD,UAAM,mBAAmB;AACzB,UAAM,aAAa;AAEnB,UAAM,YAAY,CAAC,QAAe;AAChC,YAAM,aAAa,IAAI,WAAW,CAAC,KAAK,YAAY,gBAAgB,CAAC;AACrE,eAAS,IAAI,GAAG,IAAI,KAAK,SAAS,WAAW,QAAQ;AACnD,YAAI,WAAW,MAAM,CAAC,MAAM,MAAM,KAAK,IAAI,CAAC,MAAM,IAAI;AACpD,iBAAO,IAAI,WAAW;AAC1B,YAAM,IAAI,8BAA6B;IACzC;AAEA,UAAM,SAAS,UAAU,EAAI;AAC7B,UAAM,SAAS,UAAU,EAAI;AAE7B,WAAiBA,MACf,IAAI,WAAW;MACb;MACA,GAAG,KAAK,MAAM,QAAQ,SAAS,gBAAgB;MAC/C,GAAG,KAAK,MAAM,QAAQ,SAAS,gBAAgB;KAChD,CAAC;EAEN;AACF;;;AJ7MO,IAAM,kBAAkB,WAAW,KAAK;EAC7C;EAAK;EAAK;EAAK;EAAK;EAAK;EAAK;EAAI;EAAK;EAAI;EAAI;EAAI;EAAI;EAAK;EAAI;EAAK;CACtE;AAyBD,eAAsB,iBACpB,SAAiC;AAEjC,QAAM,EACJ,WAAW,OAAO,UAAU,YAAY,OAAO,KAC7C,OAAO,UAAU,WAAW,GAE9B,GAAG,KAAI,IACL;AACJ,QAAM,kBAAkB,6BAA6B,IAAI;AACzD,MAAI;AACF,UAAM,aAAc,MAAM,SACxB,eAAwB;AAE1B,QAAI,CAAC;AAAY,YAAM,IAAI,8BAA6B;AAExD,UAAM,WAAW,WAAW;AAC5B,UAAM,YAAY,MAAe,yBAAyB,QAAQ;AAElE,WAAO;MACL,IAAI,WAAW;MACf;MACA,KAAK;;EAET,SAAS,OAAO;AACd,UAAM,IAAI,8BAA8B;MACtC,OAAO;KACR;EACH;AACF;AAsEM,SAAU,qBACd,UAAwC,CAAA,GAAE;AAE1C,QAAM,EACJ,YACA,OAAO,GACP,OAAO,OAAO,SAAS,UACvB,YAAY,EAAC,IACX;AACJ,QAAM,WAAgBC,QAAWC,YAAW,IAAI,CAAC;AACjD,QAAM,aAAiB,WAAW,MAAM,EAAE,MAAM,EAAC,CAAE;AACnD,QAAM,kBAAsB,WAAW,WAAW,EAAE,MAAM,EAAC,CAAE;AAC7D,QAAM,OAAWC,QAAO,UAAU,YAAY,eAAe;AAE7D,MAAI,CAAC;AAAY,WAAO;AAGxB,QAAM,SAAa,UAAU,IAAI,WAAW,EAAE,CAAC;AAG/C,QAAM,eAAmB,UAAU,WAAW,EAAE;AAChD,QAAM,YAAgB,WAAW,WAAW,GAAG,QAAQ,EAAE,MAAM,EAAC,CAAE;AAGlE,QAAM,UAAkB,cAAc,WAAW,SAAS;AAE1D,SAAWA,QAAO,MAAM,QAAQ,WAAW,cAAc,OAAO;AAClE;AAmDM,SAAU,kBAAkB,SAAkC;AAClE,QAAM,EACJ,WACA,cAAc,OACd,iBACA,SAAS,OAAO,SAAS,QACzB,OAAO,eAAc,IACnB;AAEJ,SAAO,KAAK,UAAU;IACpB;IACA,WAAkBC,SAAQ,WAAW,EAAE,KAAK,MAAM,KAAK,MAAK,CAAE;IAC9D;IACA;IACA,GAAG;GACJ;AACH;AAgDM,SAAU,qBACd,SAAqC;AAErC,QAAM,EAAE,UAAU,CAAA,GAAI,UAAU,MAAM,OAAM,IAAK;AACjD,SAAY,OAAO;IACjB;IACA;IACA,UAAc,QAAQ,QAAQ;GAC/B;AACH;AA+BM,SAAU,6BACd,SAA6C;AAE7C,QAAM,EACJ,cAAc,QACd,yBAAyB;IACvB,aAAa;IACb,oBAAoB;IACpB,kBAAkB;KAEpB,YAAY,iBACZ,sBACA,YACA,MAAM,OACN,KAAK;IACH,IAAI,OAAO,SAAS;IACpB,MAAM,OAAO,SAAS;KAExB,KAAI,IACF;AACJ,QAAM,QAAQ,6BAAM,SAAQ;AAC5B,SAAO;IACL,WAAW;MACT;MACA;MACA,WACE,OAAO,cAAc,WAAiB,QAAQ,SAAS,IAAI;MAC7D,GAAI,uBACA;QACE,oBAAoB,6DAAsB,IAAI,CAAC,QAAQ;UACrD,IAAWC,SAAQ,EAAE;UACrB,MAAM;;UAGV,CAAA;MACJ,kBAAkB;QAChB;UACE,MAAM;UACN,KAAK;;;;MAGT,GAAI,cAAc,EAAE,WAAU;MAC9B;MACA,MAAM;QACJ,KAAI,6BAAM,OAAW,UAAgB,WAAW,IAAI,GAAG,EAAE,IAAI,QAAO,CAAE;QACtE;QACA,cAAa,6BAAM,gBAAe;;;;AAI1C;AA2FM,SAAU,4BACd,SAA4C;AAE5C,QAAM,EACJ,cACA,WACA,YACA,OAAO,OAAO,SAAS,UACvB,mBAAmB,WAAU,IAC3B;AACJ,SAAO;IACL,WAAW;MACT,GAAI,eACA;QACE,kBAAkB,MAAM,QAAQ,YAAY,IACxC,aAAa,IAAI,CAAC,QAAQ;UACxB,IAAWA,SAAQ,EAAE;UACrB,MAAM;UACN,IACF;UACE;YACE,IAAWA,SAAQ,YAAY;YAC/B,MAAM;;;UAIhB,CAAA;MACJ,WAAiB,QAAQ,SAAS;MAClC,GAAI,cAAc,EAAE,WAAU;MAC9B;MACA;;;AAGN;AAqEM,SAAU,eACd,SAA+B;AAE/B,QAAM,EACJ,WACA,aACA,iBACA,MACA,QACA,MACA,WACA,mBAAmB,WAAU,IAC3B;AAEJ,QAAM,oBAAoB,qBAAqB;IAC7C;IACA;IACA;GACD;AACD,QAAM,iBAAiB,kBAAkB;IACvC;IACA;IACA;IACA;GACD;AACD,QAAM,qBAA0BJ,QAAWC,YAAW,cAAc,CAAC;AAErE,QAAM,iBAAiB,eAAe,QAAQ,aAAa;AAC3D,QAAM,YAAY,eAAe,QAAQ,QAAQ;AAEjD,QAAM,WAAW;IACf;IACA;IACA;IACA;IACA,0BAA0B,qBAAqB;;AAGjD,QAAM,UAAcC,QAAO,mBAAmB,kBAAkB;AAEhE,SAAO,EAAE,UAAU,QAAO;AAC5B;AAwEA,eAAsBG,MAAK,SAAqB;AAC9C,QAAM,EACJ,QAAQ,OAAO,UAAU,YAAY,IAAI,KAAK,OAAO,UAAU,WAAW,GAC1E,GAAG,KAAI,IACL;AACJ,QAAM,iBAAiB,4BAA4B,IAAI;AACvD,MAAI;AACF,UAAM,aAAc,MAAM,MACxB,cAAuB;AAEzB,QAAI,CAAC;AAAY,YAAM,IAAI,6BAA4B;AACvD,UAAM,WAAW,WAAW;AAE5B,UAAM,iBAAiB,OAAO,aAC5B,GAAG,IAAI,WAAW,SAAS,cAAc,CAAC;AAE5C,UAAM,iBAAiB,eAAe,QAAQ,aAAa;AAC3D,UAAM,YAAY,eAAe,QAAQ,QAAQ;AAEjD,UAAM,YAAqB,mBACzB,IAAI,WAAW,SAAS,SAAS,CAAC;AAGpC,WAAO;MACL,UAAU;QACR,mBAAuB,UACrB,IAAI,WAAW,SAAS,iBAAiB,CAAC;QAE5C;QACA;QACA;QACA,0BACE,eAAe,UAAW,qBAAqB;;MAEnD;MACA,KAAK;;EAET,SAAS,OAAO;AACd,UAAM,IAAI,6BAA6B;MACrC,OAAO;KACR;EACH;AACF;AAyDM,SAAUC,QAAO,SAAuB;AAC5C,QAAM,EAAE,WAAW,OAAO,MAAM,UAAU,WAAW,UAAS,IAAK;AACnE,QAAM,EACJ,mBACA,gBACA,gBACA,WACA,yBAAwB,IACtB;AAEJ,QAAM,yBAA+B,QAAQ,iBAAiB;AAG9D,MAAI,uBAAuB,SAAS;AAAI,WAAO;AAE/C,QAAM,OAAO,uBAAuB,EAAE;AAGtC,OAAK,OAAO,OAAU;AAAM,WAAO;AAKnC,MAAI,6BAA6B,OAAO,OAAU;AAAM,WAAO;AAI/D,OAAK,OAAO,OAAU,MAAS,OAAO,QAAU;AAAM,WAAO;AAG7D,MAAI,cAAc,QAAW;AAC3B,UAAM,OAAO;AACb,QACE,SACA,eAAe,MAAM,OAAO,SAAS,GAAG,OAAO,SAAS,IAAI,KAAK,MAAM;AAEvE,aAAO;EACX;AAGA,QAAM,iBACJ,mBAAmB,SACf,eACG,MAAM,OAAO,cAAc,CAAC,EAC5B,MAAM,sBAAsB,IAC/B,eAAe,MAAM,qBAAqB;AAChD,MAAI,CAAC;AAAgB,WAAO;AAG5B,QAAM,CAAC,GAAG,mBAAmB,IAAI;AACjC,MAAQ,UAAiBF,SAAQ,mBAAoB,CAAC,MAAM;AAC1D,WAAO;AAET,QAAM,qBAA0BJ,QAAa,WAAW,cAAc,GAAG;IACvE,IAAI;GACL;AACD,QAAM,UAAgB,OAAO,wBAAwB,kBAAkB;AAEvE,SAAY,OAAO;IACjB;IACA;IACA;IACA;GACD;AACH;AAyBM,IAAO,gCAAP,cAAoD,UAAgB;EAGxE,YAAY,EAAE,MAAK,IAAoC,CAAA,GAAE;AACvD,UAAM,gCAAgC;MACpC;KACD;AALe,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAMzB;;AAII,IAAO,+BAAP,cAAmD,UAAgB;EAGvE,YAAY,EAAE,MAAK,IAAoC,CAAA,GAAE;AACvD,UAAM,iCAAiC;MACrC;KACD;AALe,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAMzB;;;;AKj4BF;;iBAAAO;EAAA;;eAAAC;EAAA;;;;;ACAA;;;;;AAuIM,SAAU,QAId,KACA,WAAqC,CAAA,GAAE;AAEvC,SAAO;IACL,GAAG;IACH,aAAa,IAAI,cAAc,OAAO,IAAI,WAAW,IAAI;IACzD,UAAU,IAAI,WAAW,OAAO,IAAI,QAAQ,IAAI;IAChD,kBAAkB,IAAI,mBAClB,OAAO,IAAI,gBAAgB,IAC3B;;AAER;AAyDM,SAAU,MAGd,KAAU,WAAmC,CAAA,GAAE;AAC/C,SAAO;IACL,SAAS,IAAI;IACb,WAAW,IAAI;IACf,aACE,OAAO,IAAI,gBAAgB,WACnB,WAAW,IAAI,WAAW,IAC9B;IACN,MAAM,IAAI;IACV,UACE,OAAO,IAAI,aAAa,WAAe,WAAW,IAAI,QAAQ,IAAI;IACpE,QAAQ,IAAI;IACZ,iBAAiB,IAAI;IACrB,kBACE,OAAO,IAAI,qBAAqB,WACxB,WAAW,IAAI,gBAAgB,IACnC;IACN,SAAS,IAAI;;AAEjB;;;ADpIO,IAAM,gBAAgB;EAC3B,OAAO;EACP,OAAO;;AAIF,IAAM,cAAc;EACzB,UAAU;EACV,SAAS;;AAIJ,IAAM,cAAc;EACzB,OAAO;EACP,OAAO;EACP,OAAO;EACP,OAAO;EACP,OAAO;;AAIF,IAAM,YAAY;EACvB,QAAQ;EACR,SAAS;EACT,SAAS;EACT,SAAS;EACT,SAAS;;AAoGL,SAAUC,SACd,SAA6B;AAE7B,MAAI,CAAC;AAAS,WAAO;AAErB,SAAO;IACL,GAAG;IACH,cAAc,QAAQ,eAClB,OAAO,QAAQ,YAAY,IAC3B;IACJ,aAAa,QAAQ,cAAc,OAAO,QAAQ,WAAW,IAAI;IACjE,aAAa,OAAO,QAAQ,eAAe,EAAE;IAC7C,mBAAmB,OAAO,QAAQ,qBAAqB,EAAE;IACzD,mBAAmB,OAAO,QAAQ,qBAAqB,EAAE;IACzD,SAAS,OAAO,QAAQ,WAAW,EAAE;IACrC,MAAM,QAAQ,KAAK,IAAI,CAAC,QAAY,QAAQ,KAAK,EAAE,SAAS,MAAK,CAAE,CAAC;IACpE,QAAQ,cAAc,QAAQ,MAAM;IACpC,kBAAkB,OAAO,QAAQ,oBAAoB,CAAC;IACtD,MAAO,YAAoB,QAAQ,IAAI,KAAK,QAAQ;;AAExD;AA2DM,SAAUC,OAAM,SAA2B;AAC/C,SAAO;IACL,cAAc,QAAQ,eACd,WAAW,QAAQ,YAAY,IACnC;IACJ,aAAa,QAAQ,cACb,WAAW,QAAQ,WAAW,IAClC;IACJ,WAAW,QAAQ;IACnB,aAAiB,WAAW,QAAQ,WAAW;IAC/C,iBAAiB,QAAQ;IACzB,mBAAuB,WAAW,QAAQ,iBAAiB;IAC3D,mBAAuB,WAAW,QAAQ,iBAAiB;IAC3D,MAAM,QAAQ;IACd,SAAa,WAAW,QAAQ,OAAO;IACvC,MAAM,QAAQ,KAAK,IAAQ,KAAc;IACzC,WAAW,QAAQ;IACnB,MAAM,QAAQ;IACd,QAAQ,YAAY,QAAQ,MAAM;IAClC,IAAI,QAAQ;IACZ,iBAAiB,QAAQ;IACzB,kBAAsB,WAAW,QAAQ,gBAAgB;IACzD,MAAO,UAAkB,QAAQ,IAAI,KAAK,QAAQ;;AAEtD;",
  "names": ["p256", "secp256r1", "secp256r1", "from", "extraEntropy", "sign", "verify", "fromBytes", "fromHex", "fromString", "toBytes", "toHex", "toString", "fromBytes", "fromHex", "fromString", "toBytes", "toHex", "toString", "getEncodable", "decodeCursor", "result", "sign", "value", "toBytes", "from", "p256", "from", "sha256", "fromString", "concat", "fromHex", "toBytes", "sign", "verify", "fromRpc", "toRpc", "fromRpc", "toRpc"]
}
